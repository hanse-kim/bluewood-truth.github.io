{
    "componentChunkName": "component---src-templates-{tag}-tsx",
    "path": "/tag/graph-ql/",
    "result": {"data":{"allMdx":{"totalCount":2,"edges":[{"node":{"id":"7d9d492e-f41a-57df-8787-6c4fc3627bd3","slug":"2022/02-18-gatsby-blog-search/","frontmatter":{"title":"Gatsby 블로그 제작 - 검색 기능 구현","date":"2022-02-18","tags":["Gatsby","GraphQL"]},"rawBody":"---\r\ntitle: \"Gatsby 블로그 제작 - 검색 기능 구현\"\r\ndate: \"2022-02-18\"\r\ntags: [\"Gatsby\", \"GraphQL\"]\r\n---\r\n\r\n## 개요\r\n\r\n블로그를 단지 글을 쓰는 용도가 아니라, 이전에 정리해둔 정보를 다시 찾아보는 용도로 쓴다면 검색 기능은 필수적이다. 이 글이 올라갈 때는 블로그에 멀쩡히 검색 기능이 붙어 있겠지만 사실 이건 며칠간의 삽질의 결과물이다.\r\n\r\n#### 핵심 개념\r\n\r\n검색에는 세 가지 요소가 필요하다.\r\n\r\n- 속도와 성능을 위해 데이터를 검색에 알맞은 형태로 바꿔놓은 **인덱스(index)**\r\n- 인덱스와 검색어를 이용해 검색을 수행하고 매칭된 결과를 리턴하는 **검색 엔진(search engine)**\r\n- 사용자로 하여금 검색 기능을 사용할 수 있게 해주는 **검색 UI(search UI)**\r\n\r\n일반적으로 검색 엔진 라이브러리라고 하면 raw data로부터 인덱스를 생성하고, 인덱스와 검색어를 통해 검색을 수행하는 것까지를 전부 담당한다.\r\n\r\n[공식 문서](https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-search/)에 따르면, Gatsby 사이트에 검색 기능을 추가하는 방법으로는 `js-search` 라이브러리나 `gatsby-plugin-local-search`과 같은 플러그인을 이용해 client-side 검색을 추가하는 방법이 있고, 혹은 Algolia나 ElasticSearch와 같은 API 기반의 외부 검색 엔진을 사용하는 방법이 있다.\r\n\r\n전자의 경우 모든 검색 처리를 브라우저에서 수행하므로 사이트 규모가 커질수록 방문자가 다운로드해야 할 인덱스의 크기가 커지는 단점이 있다. 반면 검색 엔진 API의 경우 이러한 단점을 해소할 수 있지만 일반적으로 무료 플랜은 호스팅이나 월별 요청 수에 제한이 있고, 온전한 기능을 사용하려면 유료 플랜을 사용해야 한다.\r\n\r\n\r\n\r\n## 진행과정\r\n\r\n자료의 수가 적은 나로서는 검색 엔진 API의 이점이 적어 client-side 검색을 택했다. 그래서 `gatsby-plugin-local-search` 플러그인을 사용하고, `react-use-flexsearch` 라이브러리를 이용해 검색결과를 표시하려 했다.\r\n\r\n결론부터 말하자면 플러그인이나 라이브러리를 통한 검색 기능 구현은 잘 되지 않았다. 결국 다소 비효율적인 방법으로나마 직접 client-side 검색 기능을 구현하게 되었다. 아래는 그동안 겪은 이슈를 나열한 것이다.\r\n\r\n#### `gatsby-plugin-local-search` 플러그인 이슈\r\n\r\n> - `gatsby-plugin-local-search`란 그 이름대로 local search, 즉 client-side 검색 기능을 위한 플러그인이다.\r\n> - `gatsby-config.js`를 통해 검색에 사용할 쿼리, 필드, 검색 결과로 받을 값 등을 설정할 수 있고, 검색 엔진으로는 FlexSearch와 Lunr 중 하나를 선택해서 사용할 수 있다. 공식 문서에서는 성능이 뛰어난 FlexSearch를 추천하고 있다.\r\n\r\n- 이슈라고 하기엔 뭣하지만 FlexSearch의 최신버전은 0.7.21인데 반해 이 플러그인에선 0.6.32버전을 쓴다. 0.6 -> 0.7로 넘어가면서 바뀐 부분이 제법 많으므로 공식문서를 참고할 때 버전을 잘 확인해야 한다.\r\n\r\n#### `react-use-flexsearch` 라이브러리 이슈\r\n\r\n> - `react-use-flexsearch`란 FlexSearch로 생성한 인덱스와 스토어를 사용해 검색을 수행할 수 있는 hook을 제공하는 라이브러리다.\r\n> - FlexSearch는 구버전인 0.6.22를 사용한다. 오랫동안 업데이트되지 않은 라이브러리라 비슷한 기능이라면 직접 구현하는 편이 낫지 않을까 싶다.\r\n\r\n- 타입 정의가 되어 있지 않다. TypeScript에서 사용하려면 별도의 타입 정의 파일을 추가해줘야 한다.\r\n\r\n- 인덱스 생성 시 옵션값을 넘길 방법이 없다. FlexSearch는 인덱스 객체를 생성할 때 옵션을 통해 인코더나 토큰화 함수를 설정할 수 있고, 특히 인코더는 인덱스 추가 뿐만 아니라 검색어에도 적용된다. 하지만 옵션을 받지 않으므로 인덱스 객체는 Built-in 함수를 사용하게 되고, 결국 후술할 문제로 인해 이 라이브러리를 사용하면 원천적으로 한글 검색이 되지 않는다.\r\n\r\n  ![react-use-flexsearch-1](.\\react-use-flexsearch-1.png)\r\n\r\n- `Index.search(query, searchOptions)`라는, 존재하지 않는 사용법으로 메서드를  사용하고 있다. 공식문서에 명시된 사용법은 `Index.search(string, <limit>, <callback>)`와 `Index.search(<options>)` 뿐이다.\r\n\r\n  ![react-use-flexsearch-2](.\\react-use-flexsearch-2.png)\r\n\r\n#### FlexSearch 라이브러리 이슈\r\n\r\n> - FlexSearch란 텍스트 검색 라이브러리다.\r\n> - 처음에 인덱스를 생성하고, <키, 텍스트> 쌍으로 검색 대상이 될 데이터를 넣고, 인덱스에 추가한 데이터에 대해 검색을 수행할 수 있다. 인덱스 생성 시에 문자열 인코딩이나 토큰화 함수를 포함한 다양한 옵션을 줄 수 있다.\r\n\r\n- Index Option의 `encode`는 공식문서의 설명과 달리 `string` 타입의 인코더 명(`\"simple\"`, `\"balance\"` 등)을 받으면 오류가 난다.\r\n\r\n  ```javascript\r\n  // flexsearch/src/index.js를 보면 이런 식으로 this.encode를 초기화하고\r\n  this.encode = options[\"encode\"] || (charset && charset.encode) || default_encoder;\r\n  \r\n  // (문자열이면 built-in 함수로 교체하는 일 없이) 바로 이런 식으로 사용한다\r\n  content = this.encode(content);\r\n  ```\r\n\r\n  따라서 특정한 build-in 인코더를 사용하고 싶다면 옵션 중 `charset`을 `\"latin:(인코더명)\"`과 같은 형태로 지정해야 한다.\r\n\r\n- `encode` 옵션을 주지 않았을 경우 built-in 인코더를 사용하는데, 알파벳과 숫자를 제외한 모든 문자를 제거하는 과정이 인코딩 과정에 포함되어 있다. 이 때문에 별도의 함수를 `encode` 옵션에 넣어주지 않으면 한글은 인덱스에 추가되지도 않고 검색도 되지 않는다.\r\n\r\n- 공식문서에서 소개하는 중국어, 일본어, 한국어용 인코딩 설정은 다음과 같다.\r\n\r\n  ![flexsearch](.\\flexsearch.png)\r\n\r\n  하지만 이는 어디까지나 예시일 뿐이고 실제로 이 설정을 넣으면 검색이 제대로 되지 않는다.\r\n\r\n  - `.replace(/[\\x00-\\x7F]/g, '')`: ASCII 문자를 제거 -> 영어나 숫자 검색이 불가능해진다.\r\n  - `.split('')`: 한 글자씩 쪼갬 -> 검색 정확도가 크게 떨어진다. `encode` 함수는 검색어에도 적용이 되기 때문에 한 글자씩 쪼갠 인덱스를 한 글자씩 쪼갠 검색어로 검색을 하게 된다. 예를 들어 \"**포트**\"라고 검색을 하면 \"**포트**\", \"**포**스**트**\", \"**포**인**트**\" 등이 전부 검색된다.\r\n\r\n  따라서 적절한 한국어 검색을 위해선 별도의 인코더, 토큰화 함수를 마련해야 한다.\r\n\r\n결론적으로 FlexSearch를 사용하기 위해서는 한국어용 `encode`, `tokenize` 옵션이 필수적인데, 아무래도 직접 구현할 만한 게 아니라서 FlexSearch 사용은 포기해야 했다. 영어와 한국어라는 언어의 차이 때문에 발생한 문제인 만큼 대부분의 검색 라이브러리는 동일한 문제를 안고 있을 거라 생각했고, 실제로 `gatsby-plugin-local-search`에서 지원하는 다른 검색엔진 라이브러리인 Lunr도 마찬가지였다.\r\n\r\n\r\n\r\n#### 검색 기능 직접 구현하기\r\n\r\n결국 raw data로부터 직접 검색하는 기능을 구현하기로 했다. 구상한 검색 과정은 다음과 같다.\r\n\r\n1. 검색어와 포스트를 인코딩한다. (현재는 `toLowerCase`만)\r\n2. 모든 포스트에 대해 검색어로 `String.match()`를 수행하고, 매치된 수가 1 이상인 포스트만 결과 리스트(`newResults`)에 저장한다.\r\n3. 매치된 갯수를 정확도의 척도로 삼고, 결과 리스트를 정확도의 내림차순으로 정렬하여 사용한다.\r\n\r\n포스트의 갯수를 n, 포스트 당 평균 글자수를 m이라 하면 한 번 검색할 때마다 O(n * m)의 시간복잡도를 갖는 셈이다. 성능을 조금이라도 개선하기 위해 다음과 같은 최적화 방법을 생각했다.\r\n\r\n- 검색어는 기본적으로 길이가 2 이상인 것만 사용한다. 한 글자로는 의미가 잘 전달되지 않고 원하는 결과를 찾기도 힘들기 때문이다.\r\n- 검색어에 대한 결과값은 세션 스토리지에 캐싱하여 사용한다. 로컬 스토리지가 아니라 세션 스토리지인 이유는, 새로운 포스트가 올라오면 기존의 검색 결과는 의미가 없어지기 때문에 브라우저가 오랫동안 검색 결과를 갖고 있을 필요가 없다고 생각했기 때문이다.\r\n- 검색 기능을 change 이벤트 핸들러로 사용할 때, 입력 중 검색 기능이 작동하는 것을 방지하기 위해 debounce를 적용한다. throttle이 아닌 이유는 검색은 연속된 이벤트의 도중보다는 연속된 이벤트의 끝이 더 의미가 있기 때문이다.\r\n- 검색은 비동기적으로 수행하도록 한다.\r\n\r\n그래서 완성된 코드는 다음과 같다.\r\n\r\n- `src/hooks/useSearch.ts`\r\n\r\n  ```typescript\r\n  import {useEffect, useState} from 'react';\r\n  import _ from 'lodash';\r\n  import {\r\n    escapedRegExp,\r\n    getProperty,\r\n    getStorageItem,\r\n    setStorageItem,\r\n  } from 'src/utils/common';\r\n  \r\n  interface Options {\r\n    searchFrom: string;\r\n    refBy: string;\r\n    limit?: number;\r\n    cacheKey?: string;\r\n    debounceWait?: number;\r\n    minKeywordLength?: number;\r\n  }\r\n  \r\n  const useSearch = <T extends Record<string, any>>(\r\n    dataList: T[],\r\n    {\r\n      searchFrom,\r\n      refBy,\r\n      limit = 20,\r\n      cacheKey = 'search',\r\n      debounceWait = 300,\r\n      minKeywordLength = 2,\r\n    }: Options\r\n  ) => {\r\n    const [results, setResults] = useState<T[]>([]);\r\n    const [store, setStore] = useState<Record<string, T>>({});\r\n  \r\n    useEffect(() => {\r\n      const storageKey = `store_${cacheKey}`;\r\n      const cachedStore = getStorageItem(storageKey, sessionStorage);\r\n      if (cachedStore) {\r\n        setStore(cachedStore);\r\n        return;\r\n      }\r\n  \r\n      const store: Record<string, T> = {};\r\n      dataList.forEach((data) => {\r\n        const refKey = getProperty(refBy.split('.'), data);\r\n        store[refKey] = data;\r\n      });\r\n  \r\n      setStorageItem(storageKey, store, sessionStorage);\r\n      setStore(store);\r\n    }, [dataList, refBy, cacheKey]);\r\n  \r\n    const encode = (str: string) => {\r\n      return str.toLowerCase();\r\n    };\r\n  \r\n    const search = async (query: string) => {\r\n      query = encode(query);\r\n      const storageKey = `query_${cacheKey}_${query}`;\r\n      const cachedResults = getStorageItem<string[]>(storageKey, sessionStorage);\r\n      if (cachedResults) {\r\n        setResults(cachedResults.map((result) => store[result]));\r\n        return;\r\n      }\r\n  \r\n      const hitCount: Record<string, number> = {};\r\n      let newResults: string[] = [];\r\n  \r\n      dataList.forEach((data) => {\r\n        if (query.length < minKeywordLength) return;\r\n  \r\n        const searchString = encode(getProperty(searchFrom, data));\r\n        const refKey = getProperty(refBy, data);\r\n        const re = escapedRegExp(query, 'g');\r\n  \r\n        if (!hitCount[refKey]) hitCount[refKey] = 0;\r\n        const hit = searchString.match(re);\r\n        if (hit) hitCount[refKey] += hit.length;\r\n  \r\n        if (hitCount[refKey] > 0) newResults.push(refKey);\r\n      });\r\n  \r\n      newResults = newResults\r\n        .sort((a, b) => hitCount[b] - hitCount[a])\r\n        .slice(0, limit);\r\n      setStorageItem(storageKey, newResults, sessionStorage);\r\n      setResults(newResults.map((result) => store[result]));\r\n    };\r\n  \r\n    const handleSearchInputChange = _.debounce(\r\n      (e: React.ChangeEvent<HTMLInputElement>) => search(e.target.value),\r\n      debounceWait\r\n    );\r\n  \r\n    return {search, results, handleSearchInputChange};\r\n  };\r\n  \r\n  export default useSearch;\r\n  ```\r\n\r\n- `src/utils/common.ts`\r\n\r\n  ```typescript\r\n  ...\r\n  \r\n  export const getStorageItem = <T = any>(\r\n    key: string,\r\n    storage = localStorage\r\n  ): T => {\r\n    return JSON.parse(`${storage.getItem(key)}`);\r\n  };\r\n  \r\n  export const setStorageItem = (\r\n    key: string,\r\n    data: any,\r\n    storage = localStorage\r\n  ) => {\r\n    storage.setItem(key, JSON.stringify(data));\r\n  };\r\n  \r\n  export const getProperty = (\r\n    query: string | string[],\r\n    obj: any,\r\n    separator = '.'\r\n  ): any => {\r\n    if (typeof query === 'string') query = query.split(separator);\r\n    const nextKey = query.shift();\r\n    if (!nextKey || !obj) return obj;\r\n    return getProperty(query, obj[nextKey]);\r\n  };\r\n  \r\n  export const escapedRegExp = (str: string, flags?: string) => {\r\n    return new RegExp(_.escapeRegExp(str), flags);\r\n  };\r\n  ```\r\n\r\n  \r\n\r\n\r\n- `src/views/searchModal/index.tsx`\r\n\r\n  ```tsx\r\n  import React from 'react';\r\n  import {graphql, useStaticQuery} from 'gatsby';\r\n  import useSearch from 'src/hooks/useSearch';\r\n  import {MdxNode} from 'src/types';\r\n  import {getPostUrl} from 'src/utils/common';\r\n  \r\n  export const pageQuery = graphql`\r\n    {\r\n      allMdx(sort: {fields: frontmatter___date, order: DESC}) {\r\n        nodes {\r\n          slug\r\n          frontmatter {\r\n            title\r\n            tags\r\n          }\r\n          rawBody\r\n        }\r\n      }\r\n    }\r\n  `;\r\n  \r\n  const SearchModal = () => {\r\n    const {\r\n      allMdx: {nodes},\r\n    } = useStaticQuery<{allMdx: {nodes: MdxNode[]}}>(pageQuery);\r\n    const {results, handleSearchInputChange} = useSearch(\r\n      nodes,\r\n      'rawBody',\r\n      'slug',\r\n      {\r\n        cacheKey: 'search-modal',\r\n      }\r\n    );\r\n  \r\n    return (\r\n      <div\r\n        style={{\r\n          width: '500px',\r\n          position: 'absolute',\r\n          top: '20%',\r\n          left: '50%',\r\n          backgroundColor: 'white',\r\n          border: '1px solid black',\r\n        }}\r\n      >\r\n        <input onChange={handleSearchInputChange} />\r\n        <ul>\r\n          {results.map((result) => (\r\n            <li key={result.slug}>\r\n              <a href={getPostUrl(result.slug)}>\r\n                <div>{result.frontmatter.tags}</div>\r\n                <h4>{result.frontmatter.title}</h4>\r\n              </a>\r\n            </li>\r\n          ))}\r\n        </ul>\r\n      </div>\r\n    );\r\n  };\r\n  \r\n  export default SearchModal;\r\n  ```\r\n\r\n- 결과\r\n\r\n![Search](https://lh3.googleusercontent.com/pw/AM-JKLWjFgS7lvr_INbby6lcBxZWssKwCWPkQoM5P6UK4dEwWgYENiYmA3qeW1vhyms8iceTTiV2phHo1bXezOSmfR4EmFAV877iftbymi_1uDOcPJxeGHt1CoUezTXqjv1iNl2o7f0j3ywrkaO36UVwP1Fw=w480-h356-no?authuser=0)\r\n\r\n- 세션 스토리지\r\n\r\n![session storage](.\\session-storage.png)\r\n\r\n이로써 검색 기능이 구현되었고 세션 스토리지에 검색 데이터도 잘 저장되는 것을 확인할 수 있다.\r\n\r\n\r\n\r\n## 후기\r\n\r\n처음에 플러그인과 라이브러리를 사용하며 '이게 왜 안 되지' 싶은 것들을 하나하나 찾다 보니 생각보다 시간이 많이 걸렸다. 그래도 라이브러리 코드를 뒤져가며 원인을 하나씩 살펴보는 건 나름대로 즐거운 경험이었다. FlexSearch에서 찾은 이슈는 추후에 PR을 넣을 예정인데 받아들여질지 어떨지는 잘 모르겠다.\r\n\r\n여하튼 이것으로 블로그로서 갖추어야 할 기본적인 기능들은 모두 갖춘 셈이다. 나머지 필요한 기능들은 디자인 적용 후에 하나씩 추가해나갈 예정이다.\r\n\r\n","excerpt":"개요 블로그를 단지 글을 쓰는 용도가 아니라, 이전에 정리해둔 정보를 다시 찾아보는 용도로 쓴다면 검색 기능은 필수적이다. 이 글이 올라갈 때는 블로그에 멀쩡히 검색 기능이 붙어 있겠지만 사실 이건 며칠간의 삽질의 결과물이다. 핵심 개념 검색에는 세 가지 요소가 필요하다. 속도와 성능을 위해 데이터를 검색에 알맞은 형태로 바꿔놓은  인덱스(index…"}},{"node":{"id":"31555a52-8aa1-52fa-8bc1-69fcc2f83bcf","slug":"2022/02-16-gatsby-blog/","frontmatter":{"title":"Gatsby 블로그 제작 - 페이지 생성","date":"2022-02-16","tags":["React","Gatsby","GraphQL"]},"rawBody":"---\r\ntitle: \"Gatsby 블로그 제작 - 페이지 생성\"\r\ndate: \"2022-02-16\"\r\ntags: [\"React\", \"Gatsby\", \"GraphQL\"]\r\n---\r\n\r\n## 개요\r\n\r\n#### 어떤 블로그를 만들까?\r\n\r\n내가 블로그를 하려는 이유는 기본적으로 공부한 내용을 정리하고 찾아보기 위함이다. 이에 필요한 기능들을 생각해봤다.\r\n\r\n- 기본적으로 Jekyll처럼 마크다운 파일을 이용해 정적 페이지를 생성\r\n- 전체 포스트 목록을 볼 수 있는 페이지\r\n- 태그별 포스트 목록을 볼 수 있는 페이지\r\n  - 각 포스트 목록은 페이지네이션함\r\n\r\n- 블로그 내 포스트 검색 기능\r\n\r\n우선은 이 정도가 필요할 듯하다. 기본적인 컨셉은 위키처럼 원하는 내용을 쉽게 찾아볼 수 있도록 검색과 하이퍼링크를 적극적으로 활용하고 싶다.\r\n\r\n#### 왜 Gatsby인가?\r\n\r\n예전에 정적 사이트 생성기 Jekyll로 블로그를 만들어보면서 고생한 적이 있다. Jekyll은 일단 Ruby 언어로 만들어져 환경 세팅부터 빌드까지의 과정이 복잡했고, 마음에 드는 테마를 찾아도 내 입맛에 맞게 커스터마이징하기가 너무 번거로웠다.\r\n\r\n그래서 이번에는 React 기반의 정적 사이트 생성기인 Gatsby를 사용하기로 했다. 처음에는 단순히 내게 익숙한 React 기반이라는 점 때문에 택했지만, 실제로 사용해보면서 매우 매력적인 프레임워크임을 알게 되었다. \r\n\r\n#### Gatsby란?\r\n\r\nGraphQL로 데이터를 다루고, React로 컴포넌트를 만들고, 빌드 결과물로서 정적인 파일들을 생성하는 프론트엔드 프레임워크이다.\r\n\r\n일반적인 React App은 빌드시 텅 빈 HTML과 JavaScript 파일을 생성한다. 이를 실행하면 JavaScript 코드를 통해 HTML 내용물을 렌더링하게 된다. 반면 Gatsby는 빌드 시 렌더링을 마친 정적 페이지들을 생성하고, 필요하다면 JavaScript 코드를 통해 추가적인 동작을 하게 된다.\r\n\r\nGatsby는 다음과 같은 장점이 있다.\r\n\r\n- 코드 분할, 이미지 최적화, 중요한 스타일(critical style)의 인라인화, 레이지 로딩, 리소스 프리페치 등을 통해 뛰어난 성능을 보여준다.\r\n- 노드(node)라는 데이터 단위를 통한 유연한 데이터 구조와 다양한 플러그인을 통해 다양한 파일, 데이터베이스, CMS의 데이터를 다룰 수 있고, 쉽게 원하는 기능을 추가할 수 있다.\r\n- 빌드된 정적 파일들은 서버와 완전히 분리되어 있으므로 데이터베이스는 악의적인 요청이나 DDOS 공격 등에 대해 안전하다.\r\n\r\n덧붙여서 공식 문서의 튜토리얼([#](https://www.gatsbyjs.com/docs/tutorial/))이 아주 알차다. React나 GraphQL을 전혀 모르더라도 충분히 따라갈 수 있도록 step-by-step으로 친절하게 설명이 되어 있다. 만약 GraphQL, 혹은 React을 처음 배운다면 Gatsby로 시작해보는 것도 좋은 선택일 것이다.\r\n\r\n#### 주요 개념\r\n\r\n![Gatsby](.\\Gatsby.jpg)\r\n\r\n- Gatsby 사이트에서 사용되는 모든 데이터는 **GraphQL 데이터 계층(data layer)**에 위치한다.\r\n- 로컬 파일, 데이터베이스, CMS 등 다양한 데이터 **소스(source)**들은 **source plugin**을 통해 데이터 계층에 추가될 수 있다.\r\n- 데이터 계층의 정보들은 **노드(node)**라는 데이터 단위로 존재한다.\r\n- **transformer plugin**을 통해 기존 노드들로부터 새로운 노드들을 생성할 수 있다.\r\n\r\n>  예를 들어 컴퓨터의 파일시스템에 접근하게 해주는 `gatsby-source-filesystem` 플러그인을 이용해 특정 경로의 로컬 파일을 File 노드로서 데이터 계층에 추가할 수 있다.\r\n>\r\n> 그리고 `gatsby-plugin-mdx` 플러그인을 사용하면 확장자가 `.mdx`인 File 노드들로부터 MDX 노드를 만들 수 있다. MDX 노드는 `.mdx`파일의 특성에 맞게 처리되어 파일 최상단의 YAML 정보, mdx 포맷으로 변환된 파일 내용 등의 정보를 포함한다.\r\n\r\n- 데이터 계층의 노드들은 **GraphQL 쿼리**를 사용해 리액트 컴포넌트에서 사용할 수 있다.\r\n- 언급했듯 다양한 플러그인을 설치하여 손쉽게 기능을 확장할 수 있다. Gatsby 플러그인을 사용하는 순서는 크게 다음과 같다.\r\n  1. `npm`으로 플러그인을 설치한다.\r\n  2. `gatsby-config.js`의 `plugins` 필드에 설치한 플러그인을 추가한다. \r\n  3. 플러그인을 사용한다.\r\n\r\n\r\n\r\n## 진행과정\r\n\r\n#### 0. Gatsby 프로젝트 생성\r\n\r\n`npm`으로 `gatsby-cli`를 전역으로 설치하면 `gatsby` 명령어를 사용할 수 있게 된다.\r\n\r\n```shell\r\n$ npm install -g gatsby-cli\r\n$ gatsby -v\r\n> Gatsby CLI version: 4.8.0\r\n```\r\n\r\n이제 Gatsby 프로젝트를 시작하기 위한 두 가지 방법이 있는데,\r\n\r\n- `gatsby new`로 시작해서 처음부터 구현하는 방법\r\n- 일종의 boilerplate인 gatsby-starter를 사용하는 방법\r\n\r\n처음에는 스타터를 이용해 빠르게 시작할까도 생각해봤지만, 새로운 React 프레임워크를 만지는 건 오랫만이라 손이 근질근질하고 직접 구현해보고픈 욕구가 생겼다. 그래서 처음부터 만들어보는 것을 택했다.\r\n\r\n`gatsby new` 명령어를 입력하면 초기설정과 함께 Gatsby 프로젝트를 생성할 수 있다. 나는 TypeScript, Emotion 정도만 선택하고 나머지는 필요할 때마다 추가하기로 했다.\r\n\r\n```shell\r\n$ gatsby new\r\n...\r\n> √ Will you be using JavaScript or TypeScript?\r\n> · TypeScript\r\n> √ Will you be using a CMS?\r\n> · No (or I'll add it later)\r\n> √ Would you like to install a styling system?\r\n> · Emotion\r\n```\r\n\r\n#### 1. 포스트 목록을 표시하기\r\n\r\n우선은 `src/posts`에 더미 `.mdx` 파일들을 20개 정도 만들었다. 대강 이런 식이다.\r\n\r\n- `posts/post1/index.mdx`\r\n\r\n\r\n```markdown\r\n---\r\ntitle: 1번째 포스트입니다\r\ndate: 2022-01-01\r\n---\r\n1번째 포스트의 내용입니다.\r\n```\r\n\r\n다음으로 몇 가지 필요한 플러그인을 추가했다.\r\n\r\n```shell\r\n$ npm install gatsby-plugin-root-import\r\n$ npm install gatsby-source-filesystem\r\n$ npm install gatsby-plugin-mdx @mdx-js/mdx@v1 @mdx-js/react@v1\r\n```\r\n\r\n- `gatsby-config.js`\r\n\r\n\r\n```javascript\r\nmodule.exports = {\r\n  siteMetadata: {\r\n    title: '개발하고 기록하기',\r\n  },\r\n  plugins: [\r\n    //...\r\n    'gatsby-plugin-root-import',\r\n    {\r\n      resolve: `gatsby-source-filesystem`,\r\n      options: {\r\n        name: `posts`,\r\n        path: `${__dirname}/posts/`,\r\n      },\r\n    },\r\n    {\r\n      resolve: `gatsby-plugin-mdx`,\r\n      options: {\r\n        extensions: [`.mdx`, `.md`],\r\n        gatsbyRemarkPlugins: [],\r\n      },\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n\r\n> - `siteMetadata` 필드: 말 그대로 사이트의 메타데이터를 입력할 수 있다. 이 메타데이터는 별도의 플러그인 없이 GraphQL 쿼리로 접근 가능한 데이터 중 하나다.\r\n> - `gatsby-plugin-root-import`: 절대경로 import를 사용하기 위한 플러그인.\r\n> - `gatsby-source-filesystem`: 컴퓨터의 파일시스템을 사용하기 위한 source 플러그인.\r\n> - `gatsby-plugin-mdx`: File node를 MDX node로 변환하는 transformer 플러그인.\r\n> - `@mdx-js/mdx`: MDX를 구현한 라이브러리.\r\n> - `@mdx-js/react`: MDX 구현을 React 컴포넌트에 매핑하기 위한 라이브러리.\r\n\r\n이제 `src/posts` 안에 있는 파일들은 File node로서 데이터 계층에 추가되고, 그 중 확장자가 `.mdx`인 노드들로부터 MDX node들이 생성될 것이다. `gatsby develop` 명령어로 개발자 모드로 실행하고 GraphiQL(`localhost:8000/___graphql`)로 들어가서 확인해볼 수 있다.\r\n\r\n![GraphiQL](.\\GraphiQL.png)\r\n\r\n> - id: 각 노드의 고유 id\r\n> - frontmatter: mdx 파일 최상단의 YAML 정보\r\n> - body: mdx 포맷으로 변환된 파일 내용\r\n\r\n이 GraphiQL 도구는 데이터 계층에 추가된 노드들을 탐색하고 필요한 쿼리를 작성하는 데 유용하다.\r\n\r\n이제 데이터도 추가했고 쿼리도 작성했으니 실제로 사이트에 띄워봤다.\r\n\r\n- `src/types.ts`\r\n\r\n\r\n```typescript\r\nimport {Node} from 'gatsby';\r\n\r\nexport interface SiteNode extends Node {\r\n  siteMetadata: {\r\n    title: string;\r\n  };\r\n}\r\n\r\nexport interface MdxNode extends Node {\r\n  frontmatter: {\r\n    title: string;\r\n    date: string;\r\n  };\r\n  body: string;\r\n}\r\n```\r\n\r\n- `src/components/layout.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, useStaticQuery} from 'gatsby';\r\nimport {SiteNode} from 'src/types';\r\n\r\ninterface Props {\r\n  title?: string;\r\n  children?: React.ReactNode;\r\n}\r\n\r\nconst query = graphql`\r\n  query {\r\n    site {\r\n      siteMetadata {\r\n        title\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst Layout = ({title, children}: Props) => {\r\n  const data = useStaticQuery<{site: SiteNode}>(query);\r\n  return (\r\n    <main>\r\n      <title>{title || data.site.siteMetadata.title}</title>\r\n      {children}\r\n    </main>\r\n  );\r\n};\r\n\r\nexport default Layout;\r\n```\r\n\r\n> - `Layout` 컴포넌트: 블로그의 모든 페이지에 공통적으로 들어갈 요소들을 래핑한 컴포넌트. 지금은 `title` 태그 뿐이지만 추후 header, footer 등 정적인 요소를 추가할 것이다.\r\n\r\n- `src/pages/blog/index.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\nimport {MdxNode} from 'src/types';\r\n\r\ninterface DataType {\r\n  allMdx: {\r\n    nodes: MdxNode[];\r\n  };\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  {\r\n    allMdx(sort: {order: DESC, fields: frontmatter___date}) {\r\n      nodes {\r\n        id\r\n        frontmatter {\r\n          title\r\n          date(formatString: \"YYYY-MM-DD\")\r\n        }\r\n        body\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\r\n  return (\r\n    <Layout>\r\n      <h1>Posts</h1>\r\n      <ul>\r\n        {allMdx.nodes.map((node) => (\r\n          <li key={node.id}>\r\n            <h2>{node.frontmatter.title}</h2>\r\n            <div>{node.frontmatter.date}</div>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default BlogPage;\r\n```\r\n\r\n> - 일반 컴포넌트와 페이지 컴포넌트에서 GraphQL 쿼리를 사용하는 방식이 다르다.\r\n>   - 일반 컴포넌트는 `useStaticQuery` 훅에 쿼리를 넣어 데이터를 가져올 수 있다.\r\n>   - 페이지 컴포넌트는 페이지 쿼리를 `export`하여 컴포넌트의 props로 데이터를 가져올 수 있다.\r\n\r\n- 결과 (`localhost:8000/blog`)\r\n\r\n![post 목록](.\\post-목록.png)\r\n\r\n날짜에 대해 내림차순으로 데이터를 가져왔으므로 최신순으로 포스트 목록이 잘 보인다!\r\n\r\n#### 2. MDX 파일로부터 정적 페이지 생성하기\r\n\r\nGatsby는 기본적으로 **File System Route API**라는 기능을 제공한다. `src/pages` 안에  `{nodeType.fieldName}.tsx`와 같은 식으로 페이지 템플릿 컴포넌트를 작성하면 데이터 계층의 노드를 바탕으로 동적 페이지를 생성하고 라우팅한다.\r\n\r\n- `nodeType`은 어떤 노드로부터 페이지를 만들지를 결정한다.\r\n- `fieldName`은 노드의 어떤 필드를 URL에 사용할지를 결정한다.\r\n\r\nMDX 노드는 기본적으로 `slug` 필드를 갖는데, `.mdx` 파일의 경로 + 파일이름이 `path/file-name` 꼴로 인코딩되어 있어 URL에 사용하기 적합하다. \r\n\r\n마크다운 문법이 잘 표시되는지 확인하기 위해 포스트 내용을 조금 수정했다. 그리고 포스트 템플릿 페이지를 만들고 포스트 목록 페이지에도 포스트 페이지에 접근할 수 있도록 링크를 추가했다.\r\n\r\n- `posts/post1/index.mdx`\r\n\r\n\r\n```markdown\r\n---\r\ntitle: 1번째 포스트입니다\r\ndate: 2022-01-01\r\n---\r\n1번째 포스트의 내용입니다.\r\n\r\n# heading1\r\n## heading2\r\n### heading3\r\n\r\n- first\r\n- second\r\n- third\r\n```\r\n\r\n- `src/pages/blog/post/{mdx.slug}.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, Link, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\nimport {MdxNode} from 'src/types';\r\nimport {MDXRenderer} from 'gatsby-plugin-mdx';\r\n\r\ninterface DataType {\r\n  mdx: MdxNode;\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  query ($id: String) {\r\n    mdx(id: {eq: $id}) {\r\n      frontmatter {\r\n        title\r\n        date(formatString: \"YYYY-MM-DD\")\r\n      }\r\n      body\r\n    }\r\n  }\r\n`;\r\n\r\nconst PostPage = ({data: {mdx}}: PageProps<DataType>) => {\r\n  return (\r\n    <Layout title={mdx.frontmatter.title}>\r\n      <Link to='/blog'>목록으로 가기</Link>\r\n      <h1>{mdx.frontmatter.title}</h1>\r\n      <div>작성일: {mdx.frontmatter.date}</div>\r\n      <MDXRenderer>{mdx.body}</MDXRenderer>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default PostPage;\r\n```\r\n\r\n> - 템플릿 페이지의 페이지 쿼리는 다른 페이지 쿼리와 조금 다르다. 쿼리 변수를 설정하고 원하는 노드를 찾기 위한 조건을 설정해줘야 한다. 위와 같은 경우 $id 쿼리 변수를 받아 id 필드가 $id 변수와 동일한 노드를 찾는 쿼리이다.\r\n>\r\n>   쿼리 변수로 사용될 값은 페이지 컴포넌트의 `props` 중 `pageContext`의 필드 중에서 정할 수 있는데, 일반적으로 노드 id가 사용된다.\r\n>\r\n> - `MDXRenderer` 컴포넌트를 사용해 MDX 노드의 `body`를 HTML로 바꾸어 표시할 수 있다.\r\n\r\n- `src/pages/blog/index.tsx`\r\n\r\n\r\n```tsx\r\n...\r\nexport const pageQuery = graphql`\r\n  {\r\n    allMdx(sort: {order: DESC, fields: frontmatter___date}) {\r\n      nodes {\r\n\t\t...\r\n        slug\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\r\n  return (\r\n    <Layout>\r\n      ...\r\n      <ul>\r\n        {allMdx.nodes.map((node) => (\r\n          <li key={node.id}>\r\n            <Link to={node.slug ? `/blog/post/${node.slug}` : '#'}>\r\n              <h2>{node.frontmatter.title}</h2>\r\n            </Link>\r\n            ...\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </Layout>\r\n  );\r\n};\r\n\r\n...\r\n```\r\n\r\n- 결과 (`localhost:8000/blog/post/post1/`)\r\n\r\n\r\n![포스트페이지](.\\포스트페이지.png)\r\n\r\n`.mdx` 파일로부터 페이지가 잘 생성되고, 또 Markdown 문법이 HTML 문법으로 잘 변환된 것을 확인할 수 있다.\r\n\r\n여기까지가 튜토리얼 6번까지 진행하며 구현할 수 있는 내용이다.\r\n\r\n#### 3. 태그별 목록 구현하기\r\n\r\n[Creating Tags Pages for Blog Posts](https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/)\r\n\r\n웬만한 내용은 공식홈페이지에 엄청 친절하게 쓰여 있다!\r\n\r\n우선 이런 식으로 `.mdx` 더미파일에 태그들을 적당히 추가했다.\r\n\r\n- `posts/post1/index.mdx`\r\n\r\n\r\n```markdown\r\n---\r\ntitle: 1번째 포스트입니다\r\ndate: 2022-01-01\r\ntags: [\"tag1\", \"tag2\"]\r\n---\r\n\r\n...\r\n```\r\n\r\n이제 쿼리를 통해 MDX 노드의 frontmatter 필드에서 tags 필드가 추가된 것을 확인할 수 있다.\r\n\r\n![태그 확인](.\\태그-확인.png)\r\n\r\n다음으로 태그를 통해 포스트 목록을 보여주는 페이지를 만들어야 한다. File System Route API은 별다른 설정 없이 자동으로 페이지를 생성할 수 있지만, 직접 페이지를 생성해야 할 때에는 **Gatsby Node API**을 사용해야 한다. 지금처럼 노드가 아닌 데이터를 통해 페이지를 생성하는 경우가 그렇다.\r\n\r\nGatsby Node API를 사용하여 페이지를 생성하는 과정은 다음과 같다.\r\n\r\n1. 템플릿 컴포넌트를 작성한다.\r\n2. 작성한 템플릿 컴포넌트를 `gatsby-node.js`의 `createPages`에서 사용하여 페이지를 생성한다.\r\n\r\n- `src/templates/tag.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, Link, PageProps} from 'gatsby';\r\nimport {MdxNode} from 'src/types';\r\nimport Layout from 'src/components/layout';\r\n\r\ninterface PageContextType {\r\n  tag: string;\r\n}\r\n\r\ninterface DataType {\r\n  allMdx: {\r\n    edges: {node: MdxNode}[];\r\n    totalCount: number;\r\n  };\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  query ($tag: String) {\r\n    allMdx(\r\n      limit: 2000\r\n      sort: {fields: [frontmatter___date], order: DESC}\r\n      filter: {frontmatter: {tags: {in: [$tag]}}}\r\n    ) {\r\n      totalCount\r\n      edges {\r\n        node {\r\n          slug\r\n          frontmatter {\r\n            title\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst TagPage = ({pageContext, data}: PageProps<DataType, PageContextType>) => {\r\n  const {tag} = pageContext;\r\n  const {edges, totalCount} = data.allMdx;\r\n  const tagHeader = `${totalCount} post${\r\n    totalCount === 1 ? '' : 's'\r\n  } tagged with \"${tag}\"`;\r\n\r\n  return (\r\n    <Layout>\r\n      <h1>{tagHeader}</h1>\r\n      <ul>\r\n        {edges.map(({node}) => {\r\n          const {slug} = node;\r\n          const {title} = node.frontmatter;\r\n          return (\r\n            <li key={slug}>\r\n              <Link to={node.slug ? `/blog/post/${node.slug}` : '#'}>\r\n                {title}\r\n              </Link>\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n      <Link to='/blog/tags'>All tags</Link>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default TagPage;\r\n```\r\n\r\n- `gatsby-node.js`\r\n\r\n\r\n```tsx\r\nconst path = require('path');\r\nconst _ = require('lodash');\r\n\r\nexports.onPostBuild = ({reporter}) => reporter.info('Page build is done!');\r\nexports.createPages = async ({graphql, actions}) => {\r\n  const {createPage} = actions;\r\n  const result = await graphql(`\r\n    query {\r\n      tagsGroup: allMdx(limit: 2000) {\r\n        tags: group(field: frontmatter___tags) {\r\n          value: fieldValue\r\n          totalCount\r\n        }\r\n      }\r\n    }\r\n  `);\r\n\r\n  if (result.errors) {\r\n    reporter.panicOnBuild(`Error while running GraphQL query.`);\r\n    return;\r\n  }\r\n\r\n  const tags = result.data.tagsGroup.tags;\r\n  tags.forEach((tag) => {\r\n    createPage({\r\n      path: `/blog/tags/${_.kebabCase(tag.value)}/`,\r\n      component: path.resolve('src/templates/tag.tsx'),\r\n      context: {\r\n        tag: tag.value,\r\n      },\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n- `src/pages/blog/tags.tsx`\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport kebabCase from 'lodash/kebabCase';\r\nimport {Link, graphql, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\n\r\ninterface DataType {\r\n  tagsGroup: {\r\n    tags: {\r\n      value: string;\r\n      totalCount: number;\r\n    }[];\r\n  };\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  query {\r\n    tagsGroup: allMdx(limit: 2000) {\r\n      tags: group(field: frontmatter___tags) {\r\n        value: fieldValue\r\n        totalCount\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst TagsPage = ({\r\n  data: {\r\n    tagsGroup: {tags},\r\n  },\r\n}: PageProps<DataType>) => (\r\n  <Layout>\r\n    <div>\r\n      <h1>Tags</h1>\r\n      <ul>\r\n        {tags.map((tag) => (\r\n          <li key={tag.value}>\r\n            <Link to={`/blog/tags/${kebabCase(tag.value)}/`}>\r\n              {tag.value} ({tag.totalCount})\r\n            </Link>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  </Layout>\r\n);\r\n\r\nexport default TagsPage;\r\n```\r\n\r\n> - 템플릿 컴포넌트는 앞서 작성한 템플릿 페이지 컴포넌트와 거의 유사하다. `pageContext`의 `tag` 값을 쿼리 변수로 사용하고 이 쿼리 변수를 `frontmatter`의 `tags`가 포함하는 MDX 노드들을 가져온다.\r\n>\r\n> - `gatsby-node.js`에서는 Graphql 쿼리를 날려 결과값을 받아오고, 이 결과값과 템플릿 컴포넌트를 이용해 페이지를 생성한다.\r\n>\r\n> - 추가적으로 태그 목록을 확인할 수 있는 페이지를 만들었다.\r\n>\r\n> - 페이지가 잘 생성되었는지 궁금할 때엔 GraphiQL에서 다음과 같은 쿼리를 날려보면 쉽게 확인할 수 있다.\r\n>\r\n>   ```\r\n>   // GraphQL query\r\n>   {\r\n>     allSitePage {\r\n>       nodes {\r\n>         path\r\n>       }\r\n>     }\r\n>   }\r\n>                                               \r\n>   // 결과 예\r\n>   {\r\n>     \"data\": {\r\n>       \"allSitePage\": {\r\n>         \"nodes\": [\r\n>           {\r\n>             \"path\": \"/blog/tags/tag-0/\"\r\n>           },\r\n>           {\r\n>             \"path\": \"/blog/tags/tag-1/\"\r\n>           },\r\n>           ...\r\n>         ]\r\n>       }\r\n>     },\r\n>     \"extensions\": {}\r\n>   }\r\n>   ```\r\n\r\n- 결과1 (`localhost:8000/blog/tags`)\r\n\r\n\r\n![tags](.\\tags.png)\r\n\r\n- 결과2 (`localhost:8000/blog/tags/tag-1`)\r\n\r\n\r\n![tag1](.\\tag1.png)\r\n\r\n태그 목록으로부터 페이지가 잘 생성된 것을 확인할 수 있다.\r\n\r\n#### 중간 정리\r\n\r\n어느 정도 기능이 자리잡은 만큼 코드를 한번 정리했다.\r\n\r\n- URL을 간소화하기 위해 `/blog` 아래에 위치한 페이지들을 전부 루트 위치로 이동시켰다.\r\n\r\n- 여러 페이지에서 사용되는 UI요소를 컴포넌트로 분리했다. (`/blog`, `/tag/{tag}`에서 사용되는 포스트 목록 등)\r\n\r\n- 여러 곳에서 쓰이는 로직은 `src/utils.ts`로 분리했다.\r\n\r\n- `src/components/postList/index.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {MdxNode} from 'src/types';\r\nimport PostItem from './PostItem';\r\n\r\nconst PostList = ({nodes}: {nodes: MdxNode[]}) => {\r\n  return (\r\n    <ul>\r\n      {nodes.map((node) => (\r\n        <PostItem key={node.id} node={node} />\r\n      ))}\r\n    </ul>\r\n  );\r\n};\r\n\r\nexport default PostList;\r\n```\r\n\r\n- `src/components/postList/postItem.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {Link} from 'gatsby';\r\nimport {MdxNode} from 'src/types';\r\nimport {getPostUrl} from 'src/utils';\r\nimport TagButton from 'src/components/tagButton';\r\n\r\nconst PostItem = ({node}: {node: MdxNode}) => {\r\n  return (\r\n    <div>\r\n      <Link to={getPostUrl(node.slug)}>\r\n        <h2>{node.frontmatter.title}</h2>\r\n        <div>{node.frontmatter.date}</div>\r\n      </Link>\r\n      {node.frontmatter.tags.map((tag) => (\r\n        <TagButton key={tag} tag={tag} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PostItem;\r\n```\r\n\r\n- `src/utils.ts`\r\n\r\n```typescript\r\nimport _ from 'lodash';\r\n\r\nconst noUrl = '#';\r\n\r\nexport const getPostUrl = (slug?: string) => {\r\n  return slug ? `/post/${slug}` : noUrl;\r\n};\r\n\r\nexport const getTagUrl = (tag?: string) => {\r\n  return tag ? `/tag/${_.kebabCase(tag)}` : noUrl;\r\n}\r\n```\r\n\r\n그래서 여기까지 프로젝트 구조는 다음과 같다.\r\n\r\n```\r\nroot\r\n├src\r\n│├components\r\n││├layout\r\n││├postList\r\n││└tagButton\r\n│├images\r\n│├pages\r\n││├post\r\n│││└{mdx.slug}.tsx\r\n││├404.tsx\r\n││├blog.tsx\r\n││├index.tsx\r\n││└tag.tsx\r\n│├templates\r\n││└{tag}.tsx\r\n│├types.ts\r\n│└utils.ts\r\n├gatsby-config.js\r\n├gatsby-node.js\r\n├...\r\n```\r\n\r\n#### 4. 포스트 목록 페이지네이션\r\n\r\n**페이지네이션(pagination)**, 또는 페이징(paging)이란 많은 양의 데이터를 여러 페이지로 나누어 보여주는 과정을 말한다. 보여줄 데이터 양이 방대할 경우 데이터를 가져오거나 렌더링하는 과정이 오래 걸릴 수 있고, 보기에도 힘들어지므로 적절하게 페이지네이션 처리를 할 필요가 있다.\r\n\r\nGatsby 공식 문서에서 소개하는 방법([#](https://www.gatsbyjs.com/docs/adding-pagination/))은 앞서 태그 페이지를 생성한 것처럼 Gatsby Node API를 이용해 각 페이지별 정적 페이지를 생성하는 것이다. 그러나 이 방법은 페이지네이션이 필요한 페이지를 생성할 때마다 새로 `createPages()`에서 페이지 작성 코드를 추가해줘야 한다는 문제가 있다.\r\n\r\n그래서 나는 이 방법 대신 리액트 컴포넌트와 훅을 이용해 client-side 페이지네이션을 구현하기로 했다. 처음에 모든 데이터를 가져온 후 렌더링에만 페이지네이션을 적용하는 것이다. 이러면 적은 양의 데이터만 가져올 수 있다는 이점은 없어지지만, 블로그라는 사이트 특성상 데이터가 많아봐야 수백 건일 것이므로 크게 신경 쓸 부분은 아니라고 생각했다. 그리고 여전히 렌더링의 이점은 챙길 수 있다.\r\n\r\n페이지네이션에 필요한 요소로는 크게 두 가지를 생각했는데,\r\n\r\n- 원본 데이터에서 특정 페이지에 표시할 데이터를 뽑아내는 기능\r\n- 사용자가 페이지 이동을 할 수 있도록 UI를 제공하는 페이지 내비게이션\r\n\r\n전자는 훅으로, 후자는 훅과 컴포넌트로 구현했다. 특별히 신경 쓴 점이라면 재사용성을 고려해서 어떤 종류의 데이터라도 페이지네이션이 가능하도록 만들었다.\r\n\r\n- `src/hooks/usePagination.ts`\r\n\r\n\r\n```typescript\r\nimport {useCallback, useEffect, useMemo, useState} from 'react';\r\n\r\ninterface Options {\r\n  itemsPerPage?: number;\r\n  initialPage?: number;\r\n}\r\n\r\nconst usePagination = <T>(\r\n  data: T[],\r\n  {itemsPerPage = 10, initialPage}: Options = {}\r\n) => {\r\n  const [paginatedData, setPaginatedData] = useState<T[]>([]);\r\n  const [currPage, setCurrPage] = useState(initialPage || 1);\r\n\r\n  useEffect(() => {\r\n    const startIndex = (currPage - 1) * itemsPerPage;\r\n    const endIndex = currPage * itemsPerPage;\r\n    setPaginatedData(data.slice(startIndex, endIndex));\r\n  }, [data, currPage, itemsPerPage]);\r\n\r\n  const lastPage = useMemo(\r\n    () => Math.ceil(data.length / itemsPerPage),\r\n    [data.length, itemsPerPage]\r\n  );\r\n\r\n  const setPage = useCallback((page: number) => {\r\n    if (page > lastPage) page = lastPage;\r\n    if (page < 1) page = 1;\r\n    setCurrPage(page);\r\n  }, []);\r\n\r\n  return {paginatedData, currPage, setPage, lastPage};\r\n};\r\n\r\nexport default usePagination;\r\n```\r\n\r\n> - 재사용이 용이하도록 데이터의 타입은 generic type을 사용했고 페이지당 항목 수, 처음에 표시할 페이지와 같은 값들을 옵션으로 변경할 수 있게 만들었다.\r\n\r\n- `src/components/pageNav/index.tsx`\r\n\r\n\r\n```tsx\r\nimport React, {useEffect, useState} from 'react';\r\nimport {range} from 'src/utils/common';\r\nimport PageButton from './pageButton';\r\n\r\ninterface Props {\r\n  currPage: number;\r\n  lastPage: number;\r\n  setPage: (page: number) => void;\r\n  maxPageNavLength?: number;\r\n}\r\n\r\nconst PageNav = ({\r\n  currPage,\r\n  lastPage,\r\n  setPage,\r\n  maxPageNavLength = 10,\r\n}: Props) => {\r\n  const {pageList} = usePageNav(currPage, lastPage, maxPageNavLength);\r\n\r\n  return (\r\n    <div>\r\n      <PageButton\r\n        label='<'\r\n        page={pageList[0] - 1}\r\n        setPage={setPage}\r\n        disabled={pageList[0] === 1}\r\n      />\r\n      {pageList.map((page) => (\r\n        <PageButton\r\n          page={page}\r\n          setPage={setPage}\r\n          selected={currPage === page}\r\n          key={page}\r\n        />\r\n      ))}\r\n      <PageButton\r\n        label='>'\r\n        page={pageList[pageList.length - 1] + 1}\r\n        setPage={setPage}\r\n        disabled={pageList[pageList.length - 1] === lastPage}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nconst usePageNav = (\r\n  currPage: number,\r\n  lastPage: number,\r\n  maxPageNavLength: number\r\n) => {\r\n  const [pageList, setPageNavList] = useState<number[]>([]);\r\n\r\n  useEffect(() => {\r\n    const firstPageInNav = currPage - ((currPage - 1) % maxPageNavLength);\r\n    const lastPageInNav = Math.min(\r\n      firstPageInNav + maxPageNavLength,\r\n      lastPage + 1\r\n    );\r\n    setPageNavList(range(firstPageInNav, lastPageInNav));\r\n  }, [currPage, lastPage]);\r\n\r\n  return {pageList};\r\n};\r\n\r\nexport default PageNav;\r\n```\r\n\r\n> - 마찬가지로 재사용성을 위해 페이지 내비게이션의 최대길이를 받을 수 있도록 만들었다. `pageList`는 현재 페이지와 마지막 페이지를 받아 표시할 페이지의 리스트를 계산한 것이다.\r\n>\r\n>   예를 들어 최대 페이지가 15일 때, 현재 페이지가 3이면 [1, 2, ..., 10]을, 현재 페이지가 12면 [11, 12, ..., 15]를 `return`하는 식이다.\r\n>\r\n> - `usePageNav` 훅은 이 컴포넌트에서만 쓰이는 지엽적인 로직이므로 별도의 파일로 분리하지는 않았다.\r\n>\r\n> - 페이지 내비게이션의 버튼 역할을 하는 `PageButton` 컴포넌트는 페이지가 바뀔 때마다(즉 `PageNav`의 `props`가 바뀔 때마다) 내비게이션 전체가 리렌더링되는 것을 막기 위해 `React.memo()`를 적용해서 최적화했다.\r\n\r\n- `src/pages/blog.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, Link, navigate, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\nimport {MdxNode} from 'src/types';\r\nimport PostList from 'src/components/postList';\r\nimport usePagination from 'src/hooks/usePagination';\r\nimport PageNav from 'src/components/pageNav';\r\n\r\n...\r\n\r\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\r\n  const {paginatedData, currPage, lastPage, setPage} = usePagination(\r\n    allMdx.nodes,\r\n    {itemsPerPage: 3}\r\n  );\r\n\r\n  return (\r\n    <Layout>\r\n      <Link to='tags'>tags</Link>\r\n      <h1>Posts</h1>\r\n      <PostList nodes={paginatedData} />\r\n      <PageNav\r\n        currPage={currPage}\r\n        lastPage={lastPage}\r\n        setPage={setPage}\r\n        maxPageNavLength={5}\r\n      />\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default BlogPage;\r\n```\r\n\r\n> - 임시로 페이지네이션이 잘 구현되었는지 확인하기 위해 페이지당 항목 수는 3으로, 페이지 내비게이션 길이는 5로 뒀고, 현재 선택중인 페이지는 글자색을 빨간색으로 표시하게 했다.\r\n\r\n- 결과 (`localhost:8000/blog`)\r\n\r\n![pagination](https://lh3.googleusercontent.com/pw/AM-JKLWxvGAgoVHDXLt-V6zsss-FzUmTFk52laXJcdVNAXzXGUpy7jBrg7UqkHYihbMVDqHsCsD-sH4hkG4jCOGy_yidLLR_Lhd_xP6fDn113JlcQjN4YsMi-o9aM20lQzGxZjZG3UhmNjiZ9Bszw0Dsf-hM=w480-h508-no?authuser=0)\r\n\r\nclient-side 페이지네이션이 잘 구현되었다.\r\n\r\n## 후기\r\n\r\n일단 블로그로서 정말 기본적인 틀은 갖췄다. 검색 기능까지 한번에 진행하고 싶었는데 생각보다 플러그인 적용에 애를 먹어서 나중에 다시 살펴봐야 될 것 같다.\r\n\r\n현재까지 포스트 목록 표시, 포스트 페이지 생성, 태그 페이지 생성, 포스트 목록 페이지네이션 기능을 만들었고, 앞으로 추가할 예정인 기능은 우선도 순으로 다음과 같다.\r\n\r\n- 블로그 내 포스트 검색 기능 추가\r\n- 디자인 추가\r\n  - 다크모드, 반응형 디자인 적용\r\n- 댓글 기능 추가\r\n- Google Analytics 추가\r\n\r\n<br />\r\n\r\n## Issue\r\n\r\n#### 페이지 쿼리를 변경해도 반영이 되지 않는 문제\r\n\r\n- 증상: MDX 노드들을 가져오는 부분에서 중간에 페이지 쿼리에 slug 필드를 추가했을 때 변경점이 실제 데이터 fetch에 반영되지 않았다.\r\n\r\n- 원인: 쿼리를 이리저리 수정하거나 아예 지워도 이전 쿼리 상태로 동작하는 것을 보면 개발 모드에서 쿼리를 캐싱한 것이 문제가 된 것 같다.\r\n\r\n- 해결: `gatsby clean` 명령어로 캐시를 전부 날려서 해결했다.\r\n\r\n\r\n#### Gatsby Node API 사용 중 오류 발생\r\n\r\n- 증상: 공식 홈페이지의 예제를 가져와 문법만 TypeScript 문법으로 수정하고 실행했을 때 `Cannot query field \"fields\" on type \"Mdx\".`와 같은 오류들이 발생했다.\r\n- 원인: 예제는 MarkdownRemark 노드를 사용하는 것이었는데 이게 MDX 노드와 구조가 달라 발생한 문제였다. (MarkdownRemark 노드는 fields 필드 안에 body 등의 필드가 들어 있었다)\r\n- 해당 쿼리를 MDX 노드에 맞게 수정해서 해결했다.\r\n\r\n","excerpt":"개요 어떤 블로그를 만들까? 내가 블로그를 하려는 이유는 기본적으로 공부한 내용을 정리하고 찾아보기 위함이다. 이에 필요한 기능들을 생각해봤다. 기본적으로 Jekyll…"}}]}},"pageContext":{"tag":"GraphQL"}},
    "staticQueryHashes": ["2278949984","3702207254"]}