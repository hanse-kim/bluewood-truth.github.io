{
    "componentChunkName": "component---src-templates-{tag}-tsx",
    "path": "/tag/react/",
    "result": {"data":{"allMdx":{"totalCount":2,"edges":[{"node":{"id":"9eff4571-91ca-5ca6-b6f2-a7d3430d0431","slug":"2022/02-19-gatsby-blog-design/","frontmatter":{"title":"Gatsby 블로그 제작 - 디자인 및 컴포넌트 제작","date":"2022-02-19","tags":["Figma","React","Emotion"]},"rawBody":"---\r\ntitle: Gatsby 블로그 제작 - 디자인 및 컴포넌트 제작\r\ndate: 2022-02-19\r\ntags: [\"Figma\", \"React\", \"Emotion\"]\r\n---\r\n\r\n\r\n## 디자인 제작\r\n\r\n디자인 툴은 **Figma**를 사용했다. Figma에는 오토 레이아웃(Auto Layout)이라는 강력한 기능이 있어 CSS의 flex box 개념에 익숙하다면 비슷한 느낌으로 작업할 수 있다!\r\n\r\n### 디자인 과정\r\n\r\n- 전체적으로 slit gray 계열의 grayscale을 사용했고, 포인트 색상으로 파란색을 선택했다.\r\n- 컨셉은 Notion과 brunch를 참고했다. 둘 다 무언가 작성하고 읽기 위한 서비스인 만큼 읽기 좋은, 쓰기 좋은 UI/UX를 갖추고 있다고 생각했기 때문이다.\r\n- '중요한 내용 = 볼드체'라는 고정관념이 있었는데 heading에 얇은 두께를 쓰는 것도 깔끔하고 괜찮아 보인다.\r\n- 기본 텍스트도 font weight를 Regular(400)이 아닌 Light(300)로 잡고, 가장 두꺼운 두께를 Regular로 사용했다.\r\n\r\n![figma1](.\\figma1.png)\r\n\r\n![figma2](.\\figma2.png)\r\n\r\n![figma3](.\\figma3.png)\r\n\r\n<br />\r\n\r\n\r\n\r\n## 디자인 적용\r\n\r\n스타일링에는 css-in-js 라이브러리인 Emotion을 사용했다.\r\n\r\n작업에 앞서 `vscode-styled-components`라는 VSCode 플러그인을 설치했다. 아래와 같이 CSS template literal에 하이라이트와 자동완성 기능을 추가하는 플러그인이다. 전에 이런 기능을 원해서 Emotion으로 검색했을 때는 못 찾았었는데, 알고 보니 stylesd-components 라이브러리 용으로 이미 있었다. 문법이 유사하기 때문에 Emotion에서도 문제 없이 사용할 수 있다.\r\n\r\n![js-styled-component](.\\js-styled-component.png)\r\n\r\n### 글로벌 스타일 작성\r\n\r\n우선 CSS Reset 스타일을 작성했다. CSS Reset은 주로 브라우저 간의 기본 스타일 차이를 없애기 위해, 그리고 일반적으로 필요 없다고 여겨지는 스타일들(`body`의 `margin` 등)을 미리 제거하고 시작해서 반복 작업을 줄이기 위해 사용한다. 나는 [Minimal CSS Reset](https://www.digitalocean.com/community/tutorials/css-minimal-css-reset)과 [Normalize.css](http://necolas.github.io/normalize.css/)에서 필요한 부분을 가져오고 수정해서 사용하고 있다.\r\n\r\n- src/styles/cssReset.ts\r\n\r\n```typescript\r\nimport {css} from '@emotion/react';\r\n\r\nexport const cssReset = css`\r\n  html {\r\n    box-sizing: border-box;\r\n    font-size: 16px;\r\n    font-weight: 400;\r\n    line-height: 1.15;\r\n    -webkit-text-size-adjust: 100%;\r\n  }\r\n\r\n  *,\r\n  :after,\r\n  :before {\r\n    box-sizing: inherit;\r\n  }\r\n\r\n  body,\r\n  h1,\r\n  h2,\r\n  h3,\r\n  h4,\r\n  h5,\r\n  h6,\r\n  ol,\r\n  p,\r\n  ul {\r\n    margin: 0;\r\n    padding: 0;\r\n    font-weight: inherit;\r\n  }\r\n\r\n  main {\r\n    display: block;\r\n  }\r\n\r\n  ol,\r\n  ul {\r\n    list-style: none;\r\n  }\r\n\r\n  img {\r\n    border-style: none;\r\n    max-width: 100%;\r\n    height: auto;\r\n    object-fit: cover;\r\n  }\r\n\r\n  hr {\r\n    box-sizing: content-box;\r\n    height: 0;\r\n    overflow: visible;\r\n  }\r\n\r\n  a {\r\n    background-color: transparent;\r\n    color: inherit;\r\n    outline: 0;\r\n  }\r\n\r\n  a,\r\n  a:active,\r\n  a:hover {\r\n    text-decoration: none;\r\n  }\r\n\r\n  button,\r\n  input,\r\n  optgroup,\r\n  select,\r\n  textarea {\r\n    font-family: inherit;\r\n    font-size: inherit;\r\n    line-height: inherit;\r\n    margin: 0;\r\n  }\r\n`;\r\n```\r\n\r\n다음으로 스타일 변수를 작성했는데 이 부분은 어떻게 해야 할지 조금 고민이 되었다. 다크 모드까지 만드는 걸 고려하면 방법은 두 가지가 있다.\r\n\r\n- Emotion theme를 사용하기\r\n- CSS 변수와 attribute selector를 사용하기\r\n\r\n개인적으로 이런 간단한 프로젝트에선 Emotion theme는 작성할 코드량은 늘어나는데 비해 이점은 딱히 없다고 생각해서 두 번째 방법을 택했다. 나중에 찾아보니 css-in-js에서 제공하는 theme 기능보다는 CSS 변수 사용을 권장하는 글이 꽤 보였다. 하긴 같은 동작을 할 때 CSS 네이티브 기능과 JavaScript 사용을 비교하면 일반적으로 전자의 성능이 좋으니 그럴 만도 하다.\r\n\r\n- `src/styles/variables.ts`\r\n\r\n```typescript\r\nimport {css} from '@emotion/react';\r\n\r\nconst variables = css`\r\n  :root {\r\n    --color-main: #0076da;\r\n    --color-text: #1a1e21;\r\n    --color-text-footer: #3f4950;\r\n    --color-bg: #ffffff;\r\n    --color-bg-footer: #f4f5f6;\r\n    --color-border: #e6e8ea;\r\n\r\n    --font-weight-light: 300;\r\n    --font-weight-demi-light: 350;\r\n    --font-weight-regular: 400;\r\n\r\n    --font-size-default: 16px;\r\n    --font-size-h4: 18px;\r\n    --font-size-h3: 20px;\r\n    --font-size-h2: 24px;\r\n    --font-size-h1: 28px;\r\n    --font-size-sub-title: 28px;\r\n    --font-size-title: 36px;\r\n  }\r\n\r\n  [data-theme='dark'] {\r\n    --color-main: #2c93ea;\r\n    --color-text: #eff3f6;\r\n    --color-text-footer: #c6d3dc;\r\n    --color-bg: #1a1e21;\r\n    --color-bg-footer: #202d3a;\r\n    --color-border: #2d3a47;\r\n  }\r\n\r\n  @media (max-device-width: 767px) {\r\n    html {\r\n      font-size: 14px;\r\n    }\r\n\r\n    :root {\r\n      --font-size-default: 14px;\r\n      --font-size-h4: 16px;\r\n      --font-size-h3: 17.5px;\r\n      --font-size-h2: 19px;\r\n      --font-size-h1: 20.5px;\r\n      --font-size-sub-title: 21px;\r\n      --font-size-title: 24.5px;\r\n    }\r\n  }\r\n`;\r\n\r\nexport default variables;\r\n```\r\n\r\n마지막으로 위 둘을 합쳐 global styles로 만들고 `Layout` 컴포넌트에 추가했다.\r\n\r\n- `src/styles/global.ts`\r\n\r\n```typescript\r\nimport {css} from '@emotion/react';\r\nimport {cssReset} from './cssReset';\r\nimport variables from './variables';\r\n\r\nconst globalStyles = css`\r\n    ${cssReset};\r\n    ${variables};\r\n  `;\r\n\r\nexport default globalStyles;\r\n```\r\n\r\n- `src/components/layout/index.tsx`\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, useStaticQuery} from 'gatsby';\r\nimport {SiteNode} from 'src/types';\r\nimport Header from './header';\r\nimport {Global} from '@emotion/react';\r\nimport globalStyles from 'src/styles/global';\r\n\r\n...\r\n\r\nconst Layout = ({title, children}: Props) => {\r\n  const data = useStaticQuery<{site: SiteNode}>(query);\r\n  return (\r\n    <div>\r\n      <title>{title || data.site.siteMetadata.title}</title>\r\n      <Global styles={globalStyles} />\r\n      <Header />\r\n      <main>{children}</main>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Layout;\r\n```\r\n\r\n이제 스타일 적용을 위한 기본적인 준비가 끝났다.\r\n\r\n### 컴포넌트 제작\r\n\r\n컴포넌트는 크게 두 가지로 분류했다.\r\n\r\n- component: 여러 view에서 사용되는 재사용 가능한 요소들.\r\n- view: component의 조합으로 만들어지는 화면의 UI 요소. 단독으로 의미를 갖는 최소 요소. page는 이 view만을 사용하여 구성한다.\r\n\r\n![component vs view](.\\component-vs-view.png)\r\n\r\n<em class=\"caption\">나중에 변경이 있긴 했지만 일반적으로 이런 관점으로 개발을 진행했다</em>\r\n\r\n그리고 코드의 일관성을 위해 미리 규칙을 정했다.\r\n\r\n- 하나의 component는 `src/components/[컴포넌트명]` 꼴의 디렉터리 안에 작성한다.\r\n  - Emotion styled 컴포넌트만을 사용하여 하나의 파일로 작성 가능한 경우 `index.ts`만 작성한다.\r\n  - 마크업 구조가 필요한 경우 Emotion styled 컴포넌트를 담은 `styled.ts` 파일과 마크업 구조를 담은 `index.tsx` 파일을 작성한다. 외부에서는 이 `index.tsx` 파일에서 `export`한 컴포넌트만 `import {} from 'src/components/[컴포넌트명]'` 꼴로 `import`하여 사용한다.\r\n- 하나의 view는 `src/views/[컴포넌트명]` 꼴의 디렉터리 안에 작성한다.\r\n  - 기본적으로 component와 동일한 규칙을 따른다.\r\n  - 하나의 view에만 사용하는 component의 경우 해당 view 디렉터리 안에 작성한다.\r\n\r\n그리고 이건 개발 중간에 추가한 규칙이다.\r\n\r\n- `export default`를 사용하지 않는다. (단 page, template 컴포넌트는 제외)\r\n\r\n이는 [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)에서 확인한 규칙인데, 본문에선 이렇게 설명하고 있다.\r\n\r\n> 기본 내보내기(default exports)를 사용하지 마십시오. 이는 모든 가져오기(imports)가 균일한 패턴을 갖는 것을 보장합니다.\r\n>\r\n> 기본 내보내기는 표준적인 이름을 제공하지 않습니다. 따라서 잠재적인 가독성 감소를 포함해서, 개발자에게 이점이 거의 없고 유지보수를 어렵게 합니다.\r\n>\r\n> ```\r\n> import Foo from './bar';  // 허용됨\r\n> import Bar from './bar';  // 마찬가지로 허용됨\r\n> ```\r\n\r\n한 마디로 `export default`로 내보낸 모듈은 어떤 이름으로든 `import`가 가능하고, 이것이 잠재적으로 혼란을 야기할 수 있다는 것이다. 타당한 의견이고 또 `export default`를 사용하지 않는다고 문제될 만한 일도 없다고 생각해서 이를 적극 수용했다.\r\n\r\n단 프레임워크 명세상 page 컴포넌트와 template 컴포넌트는 `export default`로 내보내야 하므로 이들은 제외했다.\r\n\r\n### 마크다운 스타일 적용\r\n\r\n`@mdx-js/react`의 `MDXProvider`를 통해 마크다운에 스타일을 적용할 수 있다. TypeScript라면 우선 타입 정의 패키지를 설치해야 한다. \r\n\r\n```shell\r\n$ npm install --save-dev @types/mdx-js__react\r\n```\r\n\r\n그러면 이제 `MDXProvider`로 마크다운 렌더링에 사용할 컴포넌트를 커스터마이징 할 수 있다. 커스터마이징 가능한 컴포넌트와 그 방법은 [gatsby-plugin-mdx](https://www.gatsbyjs.com/plugins/gatsby-plugin-mdx/?=remark#mdxprovider)에서 확인할 수 있다.\r\n\r\n- `src/views/postLayout/index.tsx`\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {MDXProvider} from '@mdx-js/react';\r\nimport {MDXRenderer} from 'gatsby-plugin-mdx';\r\nimport {MdxNode} from 'src/types';\r\nimport {PostHeader} from './postHeader';\r\nimport {PostContentWrapper, PostLayoutWrapper} from './styled';\r\nimport {\r\n  Heading1,\r\n  Heading2,\r\n  Heading3,\r\n  Heading4,\r\n  OrderedList,\r\n  UnorderedList,\r\n  Paragraph,\r\n  Strong,\r\n  Anchor,\r\n  Blockquote,\r\n  ListItem,\r\n  Code,\r\n} from 'src/components/markdown';\r\n\r\ninterface Props {\r\n  backUrl?: string;\r\n  post: MdxNode;\r\n}\r\n\r\nconst components = {\r\n  p: Paragraph,\r\n  h1: Heading1,\r\n  h2: Heading2,\r\n  h3: Heading3,\r\n  h4: Heading4,\r\n  ul: UnorderedList,\r\n  ol: OrderedList,\r\n  li: ListItem,\r\n  strong: Strong,\r\n  a: Anchor,\r\n  inlineCode: Code,\r\n  blockquote: Blockquote,\r\n};\r\n\r\nexport const PostLayout = ({post, backUrl}: Props) => {\r\n  return (\r\n    <PostLayoutWrapper>\r\n      <PostHeader backUrl={backUrl || '/blog'} {...post.frontmatter} />\r\n      <PostContentWrapper>\r\n        <MDXProvider components={components}>\r\n          <MDXRenderer>{post.body}</MDXRenderer>\r\n        </MDXProvider>\r\n      </PostContentWrapper>\r\n    </PostLayoutWrapper>\r\n  );\r\n};\r\n```\r\n\r\n- 마크다운 원문\r\n\r\n```markdown\r\n# 큰 제목 1\r\n\r\n### 작은 제목 1\r\n\r\n같이, 찬미를 못하다 싸인 우리 유소년에게서 희망의 끓는다. 장식하는 인도하겠다는 피고 철환하였는가? 인간이 그들의 사랑의 봄바람을 과실이 무엇이 약동하다.\r\n\r\n청춘이 따뜻한 스며들어 시들어 군영과 새가 사막이다. 그들의 돋고, 대중을 할지니, 앞이 구하기 이상의 아름다우냐? 투명하되 곳으로 같이, 위하여 그들의 인간의 공자는 그들은 이것이다.\r\n\r\n1. 천자만홍이 바로 석가는 풀이 크고 낙원을 하는 원대하고, 방황하여도, 것이다. \r\n\r\n2. 들어 우리의 타오르고 우리는 피가 것이다.\r\n\r\n3. 트고, 그들의 타오르고 평화스러운 힘차게 뿐이다. 우리는 설산에서 그들은 피어나기 것이 남는 있는 따뜻한 피다.\r\n\r\n### 작은 제목 2\r\n\r\n- 나의 그러나 무성할 당신은 나의 라이너 계십니다. 동경과 무덤 한 언덕 나는 않은 거외다.\r\n- 나의 이제 위에 불러 써 있습니다. 나는 마리아 된 아무 너무나 하나 시인의 사랑과 소녀들의 까닭입니다.\r\n\r\n  - 릴케 밤이 이름자 이웃 사랑과 않은 봅니다.\r\n  - 불러 때 걱정도 하나에 나의 하나 이국 있습니다.\r\n\r\n### 작은 제목 3\r\n\r\n> 할지라도 바로 그것을 같은 있는 할지니, 뿐이다. 든 우리의 피부가 들어 품에 얼음 있는 것이다. 이성은 것이 못할 장식하는 인도하겠다는 발휘하기 석가는 것이다.\r\n\r\n찬미를 길을 얼마나 생생하며, 곳이 그들은 만천하의 하였으며, 찾아 황금시대다. 피가 이상 보배를 봄바람이다. 광야에서 새 꽃이 청춘에서만 든 것이다.보라, 것이 운다.\r\n```\r\n\r\n- 결과\r\n\r\n![마크다운 커스터마이징](.\\마크다운-커스터마이징.png)\r\n\r\n추가적으로 마크다운을 위한 라이브러리를 찾아서 적용했다. `.md` 파일을 위한 `gatsby-transformer-remark` 관련 플러그인들이 `.mdx`와도 호환되므로 그대로 사용할 수 있다. 나는 `gatsby-remark-images`와 `gatsby-remark-prismjs`를 추가했다.\r\n\r\n```shell\r\n$ npm install gatsby-remark-images gatsby-plugin-sharp\r\n$ npm install gatsby-remark-prismjs prismjs\r\n```\r\n\r\n> - `gatsby-remark-images`: 마크다운에서 상대경로로 이미지를 사용하기 위한 플러그인.\r\n> - `gatsby-plugin-sharp`: 이미지 처리를 위한 low-level 플러그인. 주로 다른 이미지 관련 Gatsby 플러그인에서 요구됨.\r\n> - `gatsby-remark-prismjs`: Gatsby에서 마크다운 렌더링 시 코드블럭에 PrismJS의 코드 하이라이팅을 사용하기 위한 플러그인.\r\n> - `prismjs`: 코드 하이라이팅 라이브러리.\r\n\r\n- `gatsby-config.js`\r\n\r\n```javascript\r\nmodule.exports = {\r\n  ...\r\n  plugins: [\r\n    ...\r\n    'gatsby-plugin-sharp',\r\n    {\r\n      resolve: `gatsby-plugin-mdx`,\r\n      options: {\r\n        extensions: [`.mdx`, `.md`],\r\n        gatsbyRemarkPlugins: [\r\n          {\r\n            resolve: `gatsby-remark-images`,\r\n            options: {\r\n              maxWidth: 720,\r\n            },\r\n          },\r\n          {\r\n            resolve: `gatsby-remark-prismjs`,\r\n            options: {\r\n              classPrefix: 'language-',\r\n              showLineNumbers: true,\r\n              noInlineHighlight: true,\r\n            },\r\n          },\r\n        ],\r\n      },\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n> `gatsby-remark-prismjs`의 옵션 중 줄 번호를 표시하도록 바꾸었고, 인라인 하이라이트는 위에서 적용한 게 있으므로 사용하지 않도록 했다.\r\n\r\n`gatsby-remark-images`는 설치 및 `gatsby-config.js` 설정 후 바로 적용된다. `gatsby-remark-prismjs`는 추가적으로 스타일을 불러와야 하는데 [gatsby-remark-prismjs](https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/?=prism)에서는 `gatsby-browser.js`에 PrismJS 테마 중 하나를 `require`로 가져오게끔 적혀 있다.\r\n\r\n나는 Emotion을 쓰고 있으므로 기존의 global styles에 테마 CSS 내용을 추가하는 방식을 택했다. 가져온 CSS는 `prismjs/themes/prism-solarizedlight.css`와 `prismjs/plugins/line-numbers/prism-line-numbers.css`이다.\r\n\r\n- `src/styles/prismTheme.ts`\r\n\r\n```typescript\r\nimport {css} from '@emotion/react';\r\n\r\n...\r\n\r\nexport const prismTheme = css`\r\n... (두 CSS 파일의 내용을 카피한 후 입맛에 맞게 수정했다)\r\n`;\r\n```\r\n\r\n- `src/styles/global.ts`\r\n\r\n```typescript\r\nimport {css} from '@emotion/react';\r\nimport {cssReset} from './cssReset';\r\nimport {variables} from './variables';\r\nimport {prismTheme} from './prismTheme';\r\n\r\nexport const globalStyles = css`\r\n  ...\r\n  ${cssReset};\r\n  ${variables};\r\n  ${prismTheme};\r\n  ...\r\n`;\r\n```\r\n\r\n- 마크다운 원문\r\n\r\n````markdown\r\n### 작은 제목 2\r\n\r\n```typescript\r\nconst main = () => {\r\n  console.log('hello world!');\r\n}\r\n\r\nmain();\r\n```\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"ko\">\r\n  <head></head>\r\n  <body>\r\n    <h1>Hello world</h1>\r\n  </body>\r\n</html>\r\n```\r\n````\r\n\r\n- 결과\r\n\r\n![코드블록 하이라이팅](.\\코드블록-하이라이팅.png)\r\n\r\n이로써 포스트 페이지의 마크다운 스타일링도 마쳤다.\r\n\r\n### 검색 모달 구현\r\n\r\n검색 기능은 모달로 구현하기로 했다. 우선 모달의 열림/닫힘 상태 관리를 위해 ContextAPI를 사용했다.\r\n\r\n- `src/contexts/modalContext.tsx`\r\n\r\n```tsx\r\nimport React, {useContext, useState} from 'react';\r\n\r\ninterface ContextState {\r\n  isOpenModal: (modal: string) => boolean;\r\n  onOpenModal: (modal: string) => () => void;\r\n  onCloseModal: (modal: string) => () => void;\r\n}\r\n\r\ninterface ProviderProps {\r\n  children?: React.ReactNode;\r\n}\r\n\r\nconst ModalContext = React.createContext<ContextState | null>(null);\r\n\r\nexport const ModalContextProvider = ({children}: ProviderProps) => {\r\n  const [modalOpenMap, setOpen] = useState<Record<string, boolean>>({});\r\n\r\n  const isOpenModal = (modal: string) => modalOpenMap[modal];\r\n\r\n  const onOpenModal = (modal: string) => () => {\r\n    setOpen((modalOpenMap) => ({...modalOpenMap, [modal]: true}));\r\n  };\r\n\r\n  const onCloseModal = (modal: string) => () => {\r\n    setOpen((modalOpenMap) => ({...modalOpenMap, [modal]: false}));\r\n  };\r\n\r\n  return (\r\n    <ModalContext.Provider value={{isOpenModal, onOpenModal, onCloseModal}}>\r\n      {children}\r\n    </ModalContext.Provider>\r\n  );\r\n};\r\n\r\nexport const useModal = (modal: string) => {\r\n  const state = useContext(ModalContext);\r\n  if (state === null) throw new Error('Cannot find modal context provider.');\r\n\r\n  const {isOpenModal, onOpenModal, onCloseModal} = state;\r\n\r\n  return {\r\n    isOpen: isOpenModal(modal),\r\n    onOpen: onOpenModal(modal),\r\n    onClose: onCloseModal(modal),\r\n  };\r\n};\r\n```\r\n\r\n> `ModalContext`는 파일 내에 숨기고 `ModalContextProvider`와 `useModal`만을 `export`로 노출시켰다.\r\n>\r\n> `ModalContextProvider`는 `ModalContext.Provider`를 래핑하는 컴포넌트로 모달의 여닫힘 상태를 갖는다. 그리고 문자열을 받는 고차 함수를 `ModalContext.Provider`의 `value`로 보낸다.\r\n>\r\n> `useModal`은 `useContext`를 한번 래핑하여 사용하기 편하게 만든 훅이다. `useModal(모달이름)` 꼴로 호출하면 해당 모달의 여닫힘 상태를 확인하거나 조작할 수 있다.\r\n\r\n현재로서는 모달이 검색 모달 하나 뿐이지만 추후 다른 모달을 추가할 것을 대비해 상태를 단순 `boolean`이 아닌 `Record<string, boolean>`으로 두고, 키값을 통해 각 모달의 상태를 구분하여 관리할 수 있도록 만들었다.\r\n\r\n이후 요전에 만든 검색 기능을 이용해 검색 모달을 구현했다.\r\n\r\n- `src/views/searchModal/index.tsx`\r\n\r\n```tsx\r\nimport React, {useCallback, useEffect, useRef, useState} from 'react';\r\nimport {graphql, useStaticQuery} from 'gatsby';\r\nimport {useSearch} from 'src/hooks/useSearch';\r\nimport {MdxNode} from 'src/types';\r\nimport {Overlay} from 'src/components/overlay';\r\nimport {useModal} from 'src/contexts/modalContext';\r\nimport {\r\n  SearchModalInput,\r\n  SearchModalInputWrapper,\r\n  SearchModalBox,\r\n  SearchResultContainer,\r\n} from './styled';\r\nimport {CrossIcon, IconButton, SearchIcon} from 'src/components/icon';\r\nimport {SearchResultItem} from './searchResultItem';\r\n\r\nconst query = graphql`\r\n  {\r\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\r\n      nodes {\r\n        slug\r\n        frontmatter {\r\n          title\r\n          tags\r\n        }\r\n        rawBody\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nexport const SearchModal = () => {\r\n  const {isOpen, onClose} = useModal('search');\r\n  const {results, handleSearchInputChange} = usePostSearch(isOpen);\r\n  const {inputRef, onInputResetClick} = useInputReset();\r\n  useAutoFocus(isOpen, inputRef);\r\n\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <Overlay onClick={onClose}>\r\n      <SearchModalBox onClick={(e) => e.stopPropagation()}>\r\n        <SearchModalInputWrapper>\r\n          <SearchIcon />\r\n          <SearchModalInput ref={inputRef} onChange={handleSearchInputChange} />\r\n          <IconButton iconElement={<CrossIcon />} onClick={onInputResetClick} />\r\n        </SearchModalInputWrapper>\r\n        {results.length > 0 && (\r\n          <SearchResultContainer>\r\n            {results.map((result) => (\r\n              <SearchResultItem searchResult={result} key={result.slug} />\r\n            ))}\r\n          </SearchResultContainer>\r\n        )}\r\n      </SearchModalBox>\r\n    </Overlay>\r\n  );\r\n};\r\n\r\nconst usePostSearch = (isOpen: boolean) => {\r\n  const {allMdx} = useStaticQuery<{allMdx: {nodes: MdxNode[]}}>(query);\r\n  const {results, resetResults, handleSearchInputChange} = useSearch(\r\n    allMdx.nodes,\r\n    'rawBody',\r\n    'slug',\r\n    {\r\n      cacheKey: 'search-modal',\r\n    }\r\n  );\r\n\r\n  useEffect(() => {\r\n    if (!isOpen) resetResults();\r\n  }, [isOpen, resetResults]);\r\n\r\n  return {results, handleSearchInputChange};\r\n};\r\n\r\nconst useInputReset = () => {\r\n  const inputRef = useRef<HTMLInputElement>(null);\r\n  const onInputResetClick = () => {\r\n    if (inputRef.current) inputRef.current.value = '';\r\n  };\r\n\r\n  return {inputRef, onInputResetClick};\r\n};\r\n\r\nconst useAutoFocus = (\r\n  isOpen: boolean,\r\n  inputRef: React.RefObject<HTMLInputElement>\r\n) => {\r\n  useEffect(() => {\r\n    if (isOpen && inputRef.current) {\r\n      inputRef.current.focus();\r\n    }\r\n  }, [isOpen, inputRef.current]);\r\n};\r\n```\r\n\r\n구현 중에 깨달은 문제는 이미 검색 input에서 검색을 위한 debounce 핸들러를 `onChange` 이벤트에 사용 중이라 입력값을 직접 제어하지 못한다는 점이었다. ([참고 - 제어 컴포넌트](https://ko.reactjs.org/docs/forms.html#controlled-components)) 그래서 일단은 `useRef`를 이용해 `current.value` 값을 변경하는 다소 지저분한 방법을 사용했는데, 이 부분은 추후에 다시 손봐야 할 것 같다.\r\n\r\n<br />\r\n\r\n## 후기\r\n\r\n디자인까지 적용하니 꽤 그럴 듯하게 보인다.\r\n\r\n앞으로는 공부한 내용을 정리하면서 더 필요한 기능을 차차 추가해나갈 예정이다. 당초 추가할 예정이었던 요소들은 다음과 같다.\r\n\r\n- 댓글 기능\r\n- Google Analytics\r\n\r\n그리고 새로이 추가해야겠다고 생각한 요소는 다음과 같다.\r\n\r\n- 포스트 이전글, 다음글 링크\r\n- 간단한 포트폴리오를 겸한 소개 페이지\r\n\r\n","excerpt":"디자인 제작 디자인 툴은  Figma 를 사용했다. Figma에는 오토 레이아웃(Auto Layout)이라는 강력한 기능이 있어 CSS의 flex box 개념에 익숙하다면 비슷한 느낌으로 작업할 수 있다! 디자인 과정 전체적으로 slit gray 계열의 grayscale을 사용했고, 포인트 색상으로 파란색을 선택했다. 컨셉은 Notion과 brunch…"}},{"node":{"id":"31555a52-8aa1-52fa-8bc1-69fcc2f83bcf","slug":"2022/02-16-gatsby-blog/","frontmatter":{"title":"Gatsby 블로그 제작 - 페이지 생성","date":"2022-02-16","tags":["React","Gatsby","GraphQL"]},"rawBody":"---\r\ntitle: \"Gatsby 블로그 제작 - 페이지 생성\"\r\ndate: \"2022-02-16\"\r\ntags: [\"React\", \"Gatsby\", \"GraphQL\"]\r\n---\r\n\r\n## 개요\r\n\r\n#### 어떤 블로그를 만들까?\r\n\r\n내가 블로그를 하려는 이유는 기본적으로 공부한 내용을 정리하고 찾아보기 위함이다. 이에 필요한 기능들을 생각해봤다.\r\n\r\n- 기본적으로 Jekyll처럼 마크다운 파일을 이용해 정적 페이지를 생성\r\n- 전체 포스트 목록을 볼 수 있는 페이지\r\n- 태그별 포스트 목록을 볼 수 있는 페이지\r\n  - 각 포스트 목록은 페이지네이션함\r\n\r\n- 블로그 내 포스트 검색 기능\r\n\r\n우선은 이 정도가 필요할 듯하다. 기본적인 컨셉은 위키처럼 원하는 내용을 쉽게 찾아볼 수 있도록 검색과 하이퍼링크를 적극적으로 활용하고 싶다.\r\n\r\n#### 왜 Gatsby인가?\r\n\r\n예전에 정적 사이트 생성기 Jekyll로 블로그를 만들어보면서 고생한 적이 있다. Jekyll은 일단 Ruby 언어로 만들어져 환경 세팅부터 빌드까지의 과정이 복잡했고, 마음에 드는 테마를 찾아도 내 입맛에 맞게 커스터마이징하기가 너무 번거로웠다.\r\n\r\n그래서 이번에는 React 기반의 정적 사이트 생성기인 Gatsby를 사용하기로 했다. 처음에는 단순히 내게 익숙한 React 기반이라는 점 때문에 택했지만, 실제로 사용해보면서 매우 매력적인 프레임워크임을 알게 되었다. \r\n\r\n#### Gatsby란?\r\n\r\nGraphQL로 데이터를 다루고, React로 컴포넌트를 만들고, 빌드 결과물로서 정적인 파일들을 생성하는 프론트엔드 프레임워크이다.\r\n\r\n일반적인 React App은 빌드시 텅 빈 HTML과 JavaScript 파일을 생성한다. 이를 실행하면 JavaScript 코드를 통해 HTML 내용물을 렌더링하게 된다. 반면 Gatsby는 빌드 시 렌더링을 마친 정적 페이지들을 생성하고, 필요하다면 JavaScript 코드를 통해 추가적인 동작을 하게 된다.\r\n\r\nGatsby는 다음과 같은 장점이 있다.\r\n\r\n- 코드 분할, 이미지 최적화, 중요한 스타일(critical style)의 인라인화, 레이지 로딩, 리소스 프리페치 등을 통해 뛰어난 성능을 보여준다.\r\n- 노드(node)라는 데이터 단위를 통한 유연한 데이터 구조와 다양한 플러그인을 통해 다양한 파일, 데이터베이스, CMS의 데이터를 다룰 수 있고, 쉽게 원하는 기능을 추가할 수 있다.\r\n- 빌드된 정적 파일들은 서버와 완전히 분리되어 있으므로 데이터베이스는 악의적인 요청이나 DDOS 공격 등에 대해 안전하다.\r\n\r\n덧붙여서 공식 문서의 튜토리얼([#](https://www.gatsbyjs.com/docs/tutorial/))이 아주 알차다. React나 GraphQL을 전혀 모르더라도 충분히 따라갈 수 있도록 step-by-step으로 친절하게 설명이 되어 있다. 만약 GraphQL, 혹은 React을 처음 배운다면 Gatsby로 시작해보는 것도 좋은 선택일 것이다.\r\n\r\n#### 주요 개념\r\n\r\n![Gatsby](.\\Gatsby.jpg)\r\n\r\n- Gatsby 사이트에서 사용되는 모든 데이터는 **GraphQL 데이터 계층(data layer)**에 위치한다.\r\n- 로컬 파일, 데이터베이스, CMS 등 다양한 데이터 **소스(source)**들은 **source plugin**을 통해 데이터 계층에 추가될 수 있다.\r\n- 데이터 계층의 정보들은 **노드(node)**라는 데이터 단위로 존재한다.\r\n- **transformer plugin**을 통해 기존 노드들로부터 새로운 노드들을 생성할 수 있다.\r\n\r\n>  예를 들어 컴퓨터의 파일시스템에 접근하게 해주는 `gatsby-source-filesystem` 플러그인을 이용해 특정 경로의 로컬 파일을 File 노드로서 데이터 계층에 추가할 수 있다.\r\n>\r\n> 그리고 `gatsby-plugin-mdx` 플러그인을 사용하면 확장자가 `.mdx`인 File 노드들로부터 MDX 노드를 만들 수 있다. MDX 노드는 `.mdx`파일의 특성에 맞게 처리되어 파일 최상단의 YAML 정보, mdx 포맷으로 변환된 파일 내용 등의 정보를 포함한다.\r\n\r\n- 데이터 계층의 노드들은 **GraphQL 쿼리**를 사용해 리액트 컴포넌트에서 사용할 수 있다.\r\n- 언급했듯 다양한 플러그인을 설치하여 손쉽게 기능을 확장할 수 있다. Gatsby 플러그인을 사용하는 순서는 크게 다음과 같다.\r\n  1. `npm`으로 플러그인을 설치한다.\r\n  2. `gatsby-config.js`의 `plugins` 필드에 설치한 플러그인을 추가한다. \r\n  3. 플러그인을 사용한다.\r\n\r\n\r\n\r\n## 진행과정\r\n\r\n#### 0. Gatsby 프로젝트 생성\r\n\r\n`npm`으로 `gatsby-cli`를 전역으로 설치하면 `gatsby` 명령어를 사용할 수 있게 된다.\r\n\r\n```shell\r\n$ npm install -g gatsby-cli\r\n$ gatsby -v\r\n> Gatsby CLI version: 4.8.0\r\n```\r\n\r\n이제 Gatsby 프로젝트를 시작하기 위한 두 가지 방법이 있는데,\r\n\r\n- `gatsby new`로 시작해서 처음부터 구현하는 방법\r\n- 일종의 boilerplate인 gatsby-starter를 사용하는 방법\r\n\r\n처음에는 스타터를 이용해 빠르게 시작할까도 생각해봤지만, 새로운 React 프레임워크를 만지는 건 오랫만이라 손이 근질근질하고 직접 구현해보고픈 욕구가 생겼다. 그래서 처음부터 만들어보는 것을 택했다.\r\n\r\n`gatsby new` 명령어를 입력하면 초기설정과 함께 Gatsby 프로젝트를 생성할 수 있다. 나는 TypeScript, Emotion 정도만 선택하고 나머지는 필요할 때마다 추가하기로 했다.\r\n\r\n```shell\r\n$ gatsby new\r\n...\r\n> √ Will you be using JavaScript or TypeScript?\r\n> · TypeScript\r\n> √ Will you be using a CMS?\r\n> · No (or I'll add it later)\r\n> √ Would you like to install a styling system?\r\n> · Emotion\r\n```\r\n\r\n#### 1. 포스트 목록을 표시하기\r\n\r\n우선은 `src/posts`에 더미 `.mdx` 파일들을 20개 정도 만들었다. 대강 이런 식이다.\r\n\r\n- `posts/post1/index.mdx`\r\n\r\n\r\n```markdown\r\n---\r\ntitle: 1번째 포스트입니다\r\ndate: 2022-01-01\r\n---\r\n1번째 포스트의 내용입니다.\r\n```\r\n\r\n다음으로 몇 가지 필요한 플러그인을 추가했다.\r\n\r\n```shell\r\n$ npm install gatsby-plugin-root-import\r\n$ npm install gatsby-source-filesystem\r\n$ npm install gatsby-plugin-mdx @mdx-js/mdx@v1 @mdx-js/react@v1\r\n```\r\n\r\n- `gatsby-config.js`\r\n\r\n\r\n```javascript\r\nmodule.exports = {\r\n  siteMetadata: {\r\n    title: '개발하고 기록하기',\r\n  },\r\n  plugins: [\r\n    //...\r\n    'gatsby-plugin-root-import',\r\n    {\r\n      resolve: `gatsby-source-filesystem`,\r\n      options: {\r\n        name: `posts`,\r\n        path: `${__dirname}/posts/`,\r\n      },\r\n    },\r\n    {\r\n      resolve: `gatsby-plugin-mdx`,\r\n      options: {\r\n        extensions: [`.mdx`, `.md`],\r\n        gatsbyRemarkPlugins: [],\r\n      },\r\n    },\r\n  ],\r\n};\r\n```\r\n\r\n\r\n> - `siteMetadata` 필드: 말 그대로 사이트의 메타데이터를 입력할 수 있다. 이 메타데이터는 별도의 플러그인 없이 GraphQL 쿼리로 접근 가능한 데이터 중 하나다.\r\n> - `gatsby-plugin-root-import`: 절대경로 import를 사용하기 위한 플러그인.\r\n> - `gatsby-source-filesystem`: 컴퓨터의 파일시스템을 사용하기 위한 source 플러그인.\r\n> - `gatsby-plugin-mdx`: File node를 MDX node로 변환하는 transformer 플러그인.\r\n> - `@mdx-js/mdx`: MDX를 구현한 라이브러리.\r\n> - `@mdx-js/react`: MDX 구현을 React 컴포넌트에 매핑하기 위한 라이브러리.\r\n\r\n이제 `src/posts` 안에 있는 파일들은 File node로서 데이터 계층에 추가되고, 그 중 확장자가 `.mdx`인 노드들로부터 MDX node들이 생성될 것이다. `gatsby develop` 명령어로 개발자 모드로 실행하고 GraphiQL(`localhost:8000/___graphql`)로 들어가서 확인해볼 수 있다.\r\n\r\n![GraphiQL](.\\GraphiQL.png)\r\n\r\n> - id: 각 노드의 고유 id\r\n> - frontmatter: mdx 파일 최상단의 YAML 정보\r\n> - body: mdx 포맷으로 변환된 파일 내용\r\n\r\n이 GraphiQL 도구는 데이터 계층에 추가된 노드들을 탐색하고 필요한 쿼리를 작성하는 데 유용하다.\r\n\r\n이제 데이터도 추가했고 쿼리도 작성했으니 실제로 사이트에 띄워봤다.\r\n\r\n- `src/types.ts`\r\n\r\n\r\n```typescript\r\nimport {Node} from 'gatsby';\r\n\r\nexport interface SiteNode extends Node {\r\n  siteMetadata: {\r\n    title: string;\r\n  };\r\n}\r\n\r\nexport interface MdxNode extends Node {\r\n  frontmatter: {\r\n    title: string;\r\n    date: string;\r\n  };\r\n  body: string;\r\n}\r\n```\r\n\r\n- `src/components/layout.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, useStaticQuery} from 'gatsby';\r\nimport {SiteNode} from 'src/types';\r\n\r\ninterface Props {\r\n  title?: string;\r\n  children?: React.ReactNode;\r\n}\r\n\r\nconst query = graphql`\r\n  query {\r\n    site {\r\n      siteMetadata {\r\n        title\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst Layout = ({title, children}: Props) => {\r\n  const data = useStaticQuery<{site: SiteNode}>(query);\r\n  return (\r\n    <main>\r\n      <title>{title || data.site.siteMetadata.title}</title>\r\n      {children}\r\n    </main>\r\n  );\r\n};\r\n\r\nexport default Layout;\r\n```\r\n\r\n> - `Layout` 컴포넌트: 블로그의 모든 페이지에 공통적으로 들어갈 요소들을 래핑한 컴포넌트. 지금은 `title` 태그 뿐이지만 추후 header, footer 등 정적인 요소를 추가할 것이다.\r\n\r\n- `src/pages/blog/index.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\nimport {MdxNode} from 'src/types';\r\n\r\ninterface DataType {\r\n  allMdx: {\r\n    nodes: MdxNode[];\r\n  };\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  {\r\n    allMdx(sort: {order: DESC, fields: frontmatter___date}) {\r\n      nodes {\r\n        id\r\n        frontmatter {\r\n          title\r\n          date(formatString: \"YYYY-MM-DD\")\r\n        }\r\n        body\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\r\n  return (\r\n    <Layout>\r\n      <h1>Posts</h1>\r\n      <ul>\r\n        {allMdx.nodes.map((node) => (\r\n          <li key={node.id}>\r\n            <h2>{node.frontmatter.title}</h2>\r\n            <div>{node.frontmatter.date}</div>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default BlogPage;\r\n```\r\n\r\n> - 일반 컴포넌트와 페이지 컴포넌트에서 GraphQL 쿼리를 사용하는 방식이 다르다.\r\n>   - 일반 컴포넌트는 `useStaticQuery` 훅에 쿼리를 넣어 데이터를 가져올 수 있다.\r\n>   - 페이지 컴포넌트는 페이지 쿼리를 `export`하여 컴포넌트의 props로 데이터를 가져올 수 있다.\r\n\r\n- 결과 (`localhost:8000/blog`)\r\n\r\n![post 목록](.\\post-목록.png)\r\n\r\n날짜에 대해 내림차순으로 데이터를 가져왔으므로 최신순으로 포스트 목록이 잘 보인다!\r\n\r\n#### 2. MDX 파일로부터 정적 페이지 생성하기\r\n\r\nGatsby는 기본적으로 **File System Route API**라는 기능을 제공한다. `src/pages` 안에  `{nodeType.fieldName}.tsx`와 같은 식으로 페이지 템플릿 컴포넌트를 작성하면 데이터 계층의 노드를 바탕으로 동적 페이지를 생성하고 라우팅한다.\r\n\r\n- `nodeType`은 어떤 노드로부터 페이지를 만들지를 결정한다.\r\n- `fieldName`은 노드의 어떤 필드를 URL에 사용할지를 결정한다.\r\n\r\nMDX 노드는 기본적으로 `slug` 필드를 갖는데, `.mdx` 파일의 경로 + 파일이름이 `path/file-name` 꼴로 인코딩되어 있어 URL에 사용하기 적합하다. \r\n\r\n마크다운 문법이 잘 표시되는지 확인하기 위해 포스트 내용을 조금 수정했다. 그리고 포스트 템플릿 페이지를 만들고 포스트 목록 페이지에도 포스트 페이지에 접근할 수 있도록 링크를 추가했다.\r\n\r\n- `posts/post1/index.mdx`\r\n\r\n\r\n```markdown\r\n---\r\ntitle: 1번째 포스트입니다\r\ndate: 2022-01-01\r\n---\r\n1번째 포스트의 내용입니다.\r\n\r\n# heading1\r\n## heading2\r\n### heading3\r\n\r\n- first\r\n- second\r\n- third\r\n```\r\n\r\n- `src/pages/blog/post/{mdx.slug}.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, Link, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\nimport {MdxNode} from 'src/types';\r\nimport {MDXRenderer} from 'gatsby-plugin-mdx';\r\n\r\ninterface DataType {\r\n  mdx: MdxNode;\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  query ($id: String) {\r\n    mdx(id: {eq: $id}) {\r\n      frontmatter {\r\n        title\r\n        date(formatString: \"YYYY-MM-DD\")\r\n      }\r\n      body\r\n    }\r\n  }\r\n`;\r\n\r\nconst PostPage = ({data: {mdx}}: PageProps<DataType>) => {\r\n  return (\r\n    <Layout title={mdx.frontmatter.title}>\r\n      <Link to='/blog'>목록으로 가기</Link>\r\n      <h1>{mdx.frontmatter.title}</h1>\r\n      <div>작성일: {mdx.frontmatter.date}</div>\r\n      <MDXRenderer>{mdx.body}</MDXRenderer>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default PostPage;\r\n```\r\n\r\n> - 템플릿 페이지의 페이지 쿼리는 다른 페이지 쿼리와 조금 다르다. 쿼리 변수를 설정하고 원하는 노드를 찾기 위한 조건을 설정해줘야 한다. 위와 같은 경우 $id 쿼리 변수를 받아 id 필드가 $id 변수와 동일한 노드를 찾는 쿼리이다.\r\n>\r\n>   쿼리 변수로 사용될 값은 페이지 컴포넌트의 `props` 중 `pageContext`의 필드 중에서 정할 수 있는데, 일반적으로 노드 id가 사용된다.\r\n>\r\n> - `MDXRenderer` 컴포넌트를 사용해 MDX 노드의 `body`를 HTML로 바꾸어 표시할 수 있다.\r\n\r\n- `src/pages/blog/index.tsx`\r\n\r\n\r\n```tsx\r\n...\r\nexport const pageQuery = graphql`\r\n  {\r\n    allMdx(sort: {order: DESC, fields: frontmatter___date}) {\r\n      nodes {\r\n\t\t...\r\n        slug\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\r\n  return (\r\n    <Layout>\r\n      ...\r\n      <ul>\r\n        {allMdx.nodes.map((node) => (\r\n          <li key={node.id}>\r\n            <Link to={node.slug ? `/blog/post/${node.slug}` : '#'}>\r\n              <h2>{node.frontmatter.title}</h2>\r\n            </Link>\r\n            ...\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </Layout>\r\n  );\r\n};\r\n\r\n...\r\n```\r\n\r\n- 결과 (`localhost:8000/blog/post/post1/`)\r\n\r\n\r\n![포스트페이지](.\\포스트페이지.png)\r\n\r\n`.mdx` 파일로부터 페이지가 잘 생성되고, 또 Markdown 문법이 HTML 문법으로 잘 변환된 것을 확인할 수 있다.\r\n\r\n여기까지가 튜토리얼 6번까지 진행하며 구현할 수 있는 내용이다.\r\n\r\n#### 3. 태그별 목록 구현하기\r\n\r\n[Creating Tags Pages for Blog Posts](https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/)\r\n\r\n웬만한 내용은 공식홈페이지에 엄청 친절하게 쓰여 있다!\r\n\r\n우선 이런 식으로 `.mdx` 더미파일에 태그들을 적당히 추가했다.\r\n\r\n- `posts/post1/index.mdx`\r\n\r\n\r\n```markdown\r\n---\r\ntitle: 1번째 포스트입니다\r\ndate: 2022-01-01\r\ntags: [\"tag1\", \"tag2\"]\r\n---\r\n\r\n...\r\n```\r\n\r\n이제 쿼리를 통해 MDX 노드의 frontmatter 필드에서 tags 필드가 추가된 것을 확인할 수 있다.\r\n\r\n![태그 확인](.\\태그-확인.png)\r\n\r\n다음으로 태그를 통해 포스트 목록을 보여주는 페이지를 만들어야 한다. File System Route API은 별다른 설정 없이 자동으로 페이지를 생성할 수 있지만, 직접 페이지를 생성해야 할 때에는 **Gatsby Node API**을 사용해야 한다. 지금처럼 노드가 아닌 데이터를 통해 페이지를 생성하는 경우가 그렇다.\r\n\r\nGatsby Node API를 사용하여 페이지를 생성하는 과정은 다음과 같다.\r\n\r\n1. 템플릿 컴포넌트를 작성한다.\r\n2. 작성한 템플릿 컴포넌트를 `gatsby-node.js`의 `createPages`에서 사용하여 페이지를 생성한다.\r\n\r\n- `src/templates/tag.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, Link, PageProps} from 'gatsby';\r\nimport {MdxNode} from 'src/types';\r\nimport Layout from 'src/components/layout';\r\n\r\ninterface PageContextType {\r\n  tag: string;\r\n}\r\n\r\ninterface DataType {\r\n  allMdx: {\r\n    edges: {node: MdxNode}[];\r\n    totalCount: number;\r\n  };\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  query ($tag: String) {\r\n    allMdx(\r\n      limit: 2000\r\n      sort: {fields: [frontmatter___date], order: DESC}\r\n      filter: {frontmatter: {tags: {in: [$tag]}}}\r\n    ) {\r\n      totalCount\r\n      edges {\r\n        node {\r\n          slug\r\n          frontmatter {\r\n            title\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst TagPage = ({pageContext, data}: PageProps<DataType, PageContextType>) => {\r\n  const {tag} = pageContext;\r\n  const {edges, totalCount} = data.allMdx;\r\n  const tagHeader = `${totalCount} post${\r\n    totalCount === 1 ? '' : 's'\r\n  } tagged with \"${tag}\"`;\r\n\r\n  return (\r\n    <Layout>\r\n      <h1>{tagHeader}</h1>\r\n      <ul>\r\n        {edges.map(({node}) => {\r\n          const {slug} = node;\r\n          const {title} = node.frontmatter;\r\n          return (\r\n            <li key={slug}>\r\n              <Link to={node.slug ? `/blog/post/${node.slug}` : '#'}>\r\n                {title}\r\n              </Link>\r\n            </li>\r\n          );\r\n        })}\r\n      </ul>\r\n      <Link to='/blog/tags'>All tags</Link>\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default TagPage;\r\n```\r\n\r\n- `gatsby-node.js`\r\n\r\n\r\n```tsx\r\nconst path = require('path');\r\nconst _ = require('lodash');\r\n\r\nexports.onPostBuild = ({reporter}) => reporter.info('Page build is done!');\r\nexports.createPages = async ({graphql, actions}) => {\r\n  const {createPage} = actions;\r\n  const result = await graphql(`\r\n    query {\r\n      tagsGroup: allMdx(limit: 2000) {\r\n        tags: group(field: frontmatter___tags) {\r\n          value: fieldValue\r\n          totalCount\r\n        }\r\n      }\r\n    }\r\n  `);\r\n\r\n  if (result.errors) {\r\n    reporter.panicOnBuild(`Error while running GraphQL query.`);\r\n    return;\r\n  }\r\n\r\n  const tags = result.data.tagsGroup.tags;\r\n  tags.forEach((tag) => {\r\n    createPage({\r\n      path: `/blog/tags/${_.kebabCase(tag.value)}/`,\r\n      component: path.resolve('src/templates/tag.tsx'),\r\n      context: {\r\n        tag: tag.value,\r\n      },\r\n    });\r\n  });\r\n};\r\n```\r\n\r\n- `src/pages/blog/tags.tsx`\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport kebabCase from 'lodash/kebabCase';\r\nimport {Link, graphql, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\n\r\ninterface DataType {\r\n  tagsGroup: {\r\n    tags: {\r\n      value: string;\r\n      totalCount: number;\r\n    }[];\r\n  };\r\n}\r\n\r\nexport const pageQuery = graphql`\r\n  query {\r\n    tagsGroup: allMdx(limit: 2000) {\r\n      tags: group(field: frontmatter___tags) {\r\n        value: fieldValue\r\n        totalCount\r\n      }\r\n    }\r\n  }\r\n`;\r\n\r\nconst TagsPage = ({\r\n  data: {\r\n    tagsGroup: {tags},\r\n  },\r\n}: PageProps<DataType>) => (\r\n  <Layout>\r\n    <div>\r\n      <h1>Tags</h1>\r\n      <ul>\r\n        {tags.map((tag) => (\r\n          <li key={tag.value}>\r\n            <Link to={`/blog/tags/${kebabCase(tag.value)}/`}>\r\n              {tag.value} ({tag.totalCount})\r\n            </Link>\r\n          </li>\r\n        ))}\r\n      </ul>\r\n    </div>\r\n  </Layout>\r\n);\r\n\r\nexport default TagsPage;\r\n```\r\n\r\n> - 템플릿 컴포넌트는 앞서 작성한 템플릿 페이지 컴포넌트와 거의 유사하다. `pageContext`의 `tag` 값을 쿼리 변수로 사용하고 이 쿼리 변수를 `frontmatter`의 `tags`가 포함하는 MDX 노드들을 가져온다.\r\n>\r\n> - `gatsby-node.js`에서는 Graphql 쿼리를 날려 결과값을 받아오고, 이 결과값과 템플릿 컴포넌트를 이용해 페이지를 생성한다.\r\n>\r\n> - 추가적으로 태그 목록을 확인할 수 있는 페이지를 만들었다.\r\n>\r\n> - 페이지가 잘 생성되었는지 궁금할 때엔 GraphiQL에서 다음과 같은 쿼리를 날려보면 쉽게 확인할 수 있다.\r\n>\r\n>   ```\r\n>   // GraphQL query\r\n>   {\r\n>     allSitePage {\r\n>       nodes {\r\n>         path\r\n>       }\r\n>     }\r\n>   }\r\n>                                               \r\n>   // 결과 예\r\n>   {\r\n>     \"data\": {\r\n>       \"allSitePage\": {\r\n>         \"nodes\": [\r\n>           {\r\n>             \"path\": \"/blog/tags/tag-0/\"\r\n>           },\r\n>           {\r\n>             \"path\": \"/blog/tags/tag-1/\"\r\n>           },\r\n>           ...\r\n>         ]\r\n>       }\r\n>     },\r\n>     \"extensions\": {}\r\n>   }\r\n>   ```\r\n\r\n- 결과1 (`localhost:8000/blog/tags`)\r\n\r\n\r\n![tags](.\\tags.png)\r\n\r\n- 결과2 (`localhost:8000/blog/tags/tag-1`)\r\n\r\n\r\n![tag1](.\\tag1.png)\r\n\r\n태그 목록으로부터 페이지가 잘 생성된 것을 확인할 수 있다.\r\n\r\n#### 중간 정리\r\n\r\n어느 정도 기능이 자리잡은 만큼 코드를 한번 정리했다.\r\n\r\n- URL을 간소화하기 위해 `/blog` 아래에 위치한 페이지들을 전부 루트 위치로 이동시켰다.\r\n\r\n- 여러 페이지에서 사용되는 UI요소를 컴포넌트로 분리했다. (`/blog`, `/tag/{tag}`에서 사용되는 포스트 목록 등)\r\n\r\n- 여러 곳에서 쓰이는 로직은 `src/utils.ts`로 분리했다.\r\n\r\n- `src/components/postList/index.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {MdxNode} from 'src/types';\r\nimport PostItem from './PostItem';\r\n\r\nconst PostList = ({nodes}: {nodes: MdxNode[]}) => {\r\n  return (\r\n    <ul>\r\n      {nodes.map((node) => (\r\n        <PostItem key={node.id} node={node} />\r\n      ))}\r\n    </ul>\r\n  );\r\n};\r\n\r\nexport default PostList;\r\n```\r\n\r\n- `src/components/postList/postItem.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {Link} from 'gatsby';\r\nimport {MdxNode} from 'src/types';\r\nimport {getPostUrl} from 'src/utils';\r\nimport TagButton from 'src/components/tagButton';\r\n\r\nconst PostItem = ({node}: {node: MdxNode}) => {\r\n  return (\r\n    <div>\r\n      <Link to={getPostUrl(node.slug)}>\r\n        <h2>{node.frontmatter.title}</h2>\r\n        <div>{node.frontmatter.date}</div>\r\n      </Link>\r\n      {node.frontmatter.tags.map((tag) => (\r\n        <TagButton key={tag} tag={tag} />\r\n      ))}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PostItem;\r\n```\r\n\r\n- `src/utils.ts`\r\n\r\n```typescript\r\nimport _ from 'lodash';\r\n\r\nconst noUrl = '#';\r\n\r\nexport const getPostUrl = (slug?: string) => {\r\n  return slug ? `/post/${slug}` : noUrl;\r\n};\r\n\r\nexport const getTagUrl = (tag?: string) => {\r\n  return tag ? `/tag/${_.kebabCase(tag)}` : noUrl;\r\n}\r\n```\r\n\r\n그래서 여기까지 프로젝트 구조는 다음과 같다.\r\n\r\n```\r\nroot\r\n├src\r\n│├components\r\n││├layout\r\n││├postList\r\n││└tagButton\r\n│├images\r\n│├pages\r\n││├post\r\n│││└{mdx.slug}.tsx\r\n││├404.tsx\r\n││├blog.tsx\r\n││├index.tsx\r\n││└tag.tsx\r\n│├templates\r\n││└{tag}.tsx\r\n│├types.ts\r\n│└utils.ts\r\n├gatsby-config.js\r\n├gatsby-node.js\r\n├...\r\n```\r\n\r\n#### 4. 포스트 목록 페이지네이션\r\n\r\n**페이지네이션(pagination)**, 또는 페이징(paging)이란 많은 양의 데이터를 여러 페이지로 나누어 보여주는 과정을 말한다. 보여줄 데이터 양이 방대할 경우 데이터를 가져오거나 렌더링하는 과정이 오래 걸릴 수 있고, 보기에도 힘들어지므로 적절하게 페이지네이션 처리를 할 필요가 있다.\r\n\r\nGatsby 공식 문서에서 소개하는 방법([#](https://www.gatsbyjs.com/docs/adding-pagination/))은 앞서 태그 페이지를 생성한 것처럼 Gatsby Node API를 이용해 각 페이지별 정적 페이지를 생성하는 것이다. 그러나 이 방법은 페이지네이션이 필요한 페이지를 생성할 때마다 새로 `createPages()`에서 페이지 작성 코드를 추가해줘야 한다는 문제가 있다.\r\n\r\n그래서 나는 이 방법 대신 리액트 컴포넌트와 훅을 이용해 client-side 페이지네이션을 구현하기로 했다. 처음에 모든 데이터를 가져온 후 렌더링에만 페이지네이션을 적용하는 것이다. 이러면 적은 양의 데이터만 가져올 수 있다는 이점은 없어지지만, 블로그라는 사이트 특성상 데이터가 많아봐야 수백 건일 것이므로 크게 신경 쓸 부분은 아니라고 생각했다. 그리고 여전히 렌더링의 이점은 챙길 수 있다.\r\n\r\n페이지네이션에 필요한 요소로는 크게 두 가지를 생각했는데,\r\n\r\n- 원본 데이터에서 특정 페이지에 표시할 데이터를 뽑아내는 기능\r\n- 사용자가 페이지 이동을 할 수 있도록 UI를 제공하는 페이지 내비게이션\r\n\r\n전자는 훅으로, 후자는 훅과 컴포넌트로 구현했다. 특별히 신경 쓴 점이라면 재사용성을 고려해서 어떤 종류의 데이터라도 페이지네이션이 가능하도록 만들었다.\r\n\r\n- `src/hooks/usePagination.ts`\r\n\r\n\r\n```typescript\r\nimport {useCallback, useEffect, useMemo, useState} from 'react';\r\n\r\ninterface Options {\r\n  itemsPerPage?: number;\r\n  initialPage?: number;\r\n}\r\n\r\nconst usePagination = <T>(\r\n  data: T[],\r\n  {itemsPerPage = 10, initialPage}: Options = {}\r\n) => {\r\n  const [paginatedData, setPaginatedData] = useState<T[]>([]);\r\n  const [currPage, setCurrPage] = useState(initialPage || 1);\r\n\r\n  useEffect(() => {\r\n    const startIndex = (currPage - 1) * itemsPerPage;\r\n    const endIndex = currPage * itemsPerPage;\r\n    setPaginatedData(data.slice(startIndex, endIndex));\r\n  }, [data, currPage, itemsPerPage]);\r\n\r\n  const lastPage = useMemo(\r\n    () => Math.ceil(data.length / itemsPerPage),\r\n    [data.length, itemsPerPage]\r\n  );\r\n\r\n  const setPage = useCallback((page: number) => {\r\n    if (page > lastPage) page = lastPage;\r\n    if (page < 1) page = 1;\r\n    setCurrPage(page);\r\n  }, []);\r\n\r\n  return {paginatedData, currPage, setPage, lastPage};\r\n};\r\n\r\nexport default usePagination;\r\n```\r\n\r\n> - 재사용이 용이하도록 데이터의 타입은 generic type을 사용했고 페이지당 항목 수, 처음에 표시할 페이지와 같은 값들을 옵션으로 변경할 수 있게 만들었다.\r\n\r\n- `src/components/pageNav/index.tsx`\r\n\r\n\r\n```tsx\r\nimport React, {useEffect, useState} from 'react';\r\nimport {range} from 'src/utils/common';\r\nimport PageButton from './pageButton';\r\n\r\ninterface Props {\r\n  currPage: number;\r\n  lastPage: number;\r\n  setPage: (page: number) => void;\r\n  maxPageNavLength?: number;\r\n}\r\n\r\nconst PageNav = ({\r\n  currPage,\r\n  lastPage,\r\n  setPage,\r\n  maxPageNavLength = 10,\r\n}: Props) => {\r\n  const {pageList} = usePageNav(currPage, lastPage, maxPageNavLength);\r\n\r\n  return (\r\n    <div>\r\n      <PageButton\r\n        label='<'\r\n        page={pageList[0] - 1}\r\n        setPage={setPage}\r\n        disabled={pageList[0] === 1}\r\n      />\r\n      {pageList.map((page) => (\r\n        <PageButton\r\n          page={page}\r\n          setPage={setPage}\r\n          selected={currPage === page}\r\n          key={page}\r\n        />\r\n      ))}\r\n      <PageButton\r\n        label='>'\r\n        page={pageList[pageList.length - 1] + 1}\r\n        setPage={setPage}\r\n        disabled={pageList[pageList.length - 1] === lastPage}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n\r\nconst usePageNav = (\r\n  currPage: number,\r\n  lastPage: number,\r\n  maxPageNavLength: number\r\n) => {\r\n  const [pageList, setPageNavList] = useState<number[]>([]);\r\n\r\n  useEffect(() => {\r\n    const firstPageInNav = currPage - ((currPage - 1) % maxPageNavLength);\r\n    const lastPageInNav = Math.min(\r\n      firstPageInNav + maxPageNavLength,\r\n      lastPage + 1\r\n    );\r\n    setPageNavList(range(firstPageInNav, lastPageInNav));\r\n  }, [currPage, lastPage]);\r\n\r\n  return {pageList};\r\n};\r\n\r\nexport default PageNav;\r\n```\r\n\r\n> - 마찬가지로 재사용성을 위해 페이지 내비게이션의 최대길이를 받을 수 있도록 만들었다. `pageList`는 현재 페이지와 마지막 페이지를 받아 표시할 페이지의 리스트를 계산한 것이다.\r\n>\r\n>   예를 들어 최대 페이지가 15일 때, 현재 페이지가 3이면 [1, 2, ..., 10]을, 현재 페이지가 12면 [11, 12, ..., 15]를 `return`하는 식이다.\r\n>\r\n> - `usePageNav` 훅은 이 컴포넌트에서만 쓰이는 지엽적인 로직이므로 별도의 파일로 분리하지는 않았다.\r\n>\r\n> - 페이지 내비게이션의 버튼 역할을 하는 `PageButton` 컴포넌트는 페이지가 바뀔 때마다(즉 `PageNav`의 `props`가 바뀔 때마다) 내비게이션 전체가 리렌더링되는 것을 막기 위해 `React.memo()`를 적용해서 최적화했다.\r\n\r\n- `src/pages/blog.tsx`\r\n\r\n\r\n```tsx\r\nimport React from 'react';\r\nimport {graphql, Link, navigate, PageProps} from 'gatsby';\r\nimport Layout from 'src/components/layout';\r\nimport {MdxNode} from 'src/types';\r\nimport PostList from 'src/components/postList';\r\nimport usePagination from 'src/hooks/usePagination';\r\nimport PageNav from 'src/components/pageNav';\r\n\r\n...\r\n\r\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\r\n  const {paginatedData, currPage, lastPage, setPage} = usePagination(\r\n    allMdx.nodes,\r\n    {itemsPerPage: 3}\r\n  );\r\n\r\n  return (\r\n    <Layout>\r\n      <Link to='tags'>tags</Link>\r\n      <h1>Posts</h1>\r\n      <PostList nodes={paginatedData} />\r\n      <PageNav\r\n        currPage={currPage}\r\n        lastPage={lastPage}\r\n        setPage={setPage}\r\n        maxPageNavLength={5}\r\n      />\r\n    </Layout>\r\n  );\r\n};\r\n\r\nexport default BlogPage;\r\n```\r\n\r\n> - 임시로 페이지네이션이 잘 구현되었는지 확인하기 위해 페이지당 항목 수는 3으로, 페이지 내비게이션 길이는 5로 뒀고, 현재 선택중인 페이지는 글자색을 빨간색으로 표시하게 했다.\r\n\r\n- 결과 (`localhost:8000/blog`)\r\n\r\n![pagination](https://lh3.googleusercontent.com/pw/AM-JKLWxvGAgoVHDXLt-V6zsss-FzUmTFk52laXJcdVNAXzXGUpy7jBrg7UqkHYihbMVDqHsCsD-sH4hkG4jCOGy_yidLLR_Lhd_xP6fDn113JlcQjN4YsMi-o9aM20lQzGxZjZG3UhmNjiZ9Bszw0Dsf-hM=w480-h508-no?authuser=0)\r\n\r\nclient-side 페이지네이션이 잘 구현되었다.\r\n\r\n## 후기\r\n\r\n일단 블로그로서 정말 기본적인 틀은 갖췄다. 검색 기능까지 한번에 진행하고 싶었는데 생각보다 플러그인 적용에 애를 먹어서 나중에 다시 살펴봐야 될 것 같다.\r\n\r\n현재까지 포스트 목록 표시, 포스트 페이지 생성, 태그 페이지 생성, 포스트 목록 페이지네이션 기능을 만들었고, 앞으로 추가할 예정인 기능은 우선도 순으로 다음과 같다.\r\n\r\n- 블로그 내 포스트 검색 기능 추가\r\n- 디자인 추가\r\n  - 다크모드, 반응형 디자인 적용\r\n- 댓글 기능 추가\r\n- Google Analytics 추가\r\n\r\n<br />\r\n\r\n## Issue\r\n\r\n#### 페이지 쿼리를 변경해도 반영이 되지 않는 문제\r\n\r\n- 증상: MDX 노드들을 가져오는 부분에서 중간에 페이지 쿼리에 slug 필드를 추가했을 때 변경점이 실제 데이터 fetch에 반영되지 않았다.\r\n\r\n- 원인: 쿼리를 이리저리 수정하거나 아예 지워도 이전 쿼리 상태로 동작하는 것을 보면 개발 모드에서 쿼리를 캐싱한 것이 문제가 된 것 같다.\r\n\r\n- 해결: `gatsby clean` 명령어로 캐시를 전부 날려서 해결했다.\r\n\r\n\r\n#### Gatsby Node API 사용 중 오류 발생\r\n\r\n- 증상: 공식 홈페이지의 예제를 가져와 문법만 TypeScript 문법으로 수정하고 실행했을 때 `Cannot query field \"fields\" on type \"Mdx\".`와 같은 오류들이 발생했다.\r\n- 원인: 예제는 MarkdownRemark 노드를 사용하는 것이었는데 이게 MDX 노드와 구조가 달라 발생한 문제였다. (MarkdownRemark 노드는 fields 필드 안에 body 등의 필드가 들어 있었다)\r\n- 해당 쿼리를 MDX 노드에 맞게 수정해서 해결했다.\r\n\r\n","excerpt":"개요 어떤 블로그를 만들까? 내가 블로그를 하려는 이유는 기본적으로 공부한 내용을 정리하고 찾아보기 위함이다. 이에 필요한 기능들을 생각해봤다. 기본적으로 Jekyll…"}}]}},"pageContext":{"tag":"React"}},
    "staticQueryHashes": ["2278949984","3702207254"]}