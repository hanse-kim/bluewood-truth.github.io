{
    "componentChunkName": "component---src-templates-{tag}-tsx",
    "path": "/tag/java-script/",
    "result": {"data":{"allMdx":{"totalCount":10,"edges":[{"node":{"id":"3a2c2031-6adf-5495-b549-a08e8a822a95","slug":"2022/03-14-closure/","frontmatter":{"title":"클로저(Closure)","date":"2022-03-14","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"클로저(Closure)\"\r\ndate: \"2022-03-14\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n## 요약\r\n\r\n**클로저**란 자신이 정의된 렉시컬 환경을 기억하는 함수다.\r\n\r\n클로저는 상태(state)를 유지하고 이것이 외부 요인에 의해 의도치 않게 변경되지 않도록 안전하게 은닉(information hiding)하기 위해 사용한다.\r\n\r\n<br />\r\n\r\n## 클로저\r\n\r\n **클로저(Closure)**란 자신이 정의된 렉시컬 환경을 기억하는 함수다.\r\n\r\n```javascript\r\nconst text = 'global';\r\n\r\nfunction outer() {\r\n    const text = 'local';\r\n    const inner = function () {\r\n        console.log(text);\r\n    }\r\n    return inner;\r\n}\r\n\r\nconst inner = outer(); // outer를 호출하면 중첩 함수 inner를 반환\r\ninner(); // 출력: local\r\n```\r\n\r\n위 예제를 보면 `inner`가 호출되는 시점에서 `outer` 함수는 생명주기가 끝나 실행 컨텍스트 스택에서 제거된 상태임에도 불구하고, `outer` 함수의 렉시컬 환경의 `text` 변수를 참조하는 것을 확인할 수 있다. 즉 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 생명주기가 끝난 외부 함수의 변수를 참조할 수 있고, 이러한 중첩 함수를 클로저라고 부른다.\r\n\r\n### 렉시컬 스코프\r\n\r\n함수 객체는 생성되는 시점에서 현재 실행중인 실행 컨텍스트의 렉시컬 환경에 대한 참조를 `[[Environment]]` 슬롯에 저장한다. 그리고 함수를 호출할 때 생성되는 함수 실행 컨텍스트의 OuterLexicalEnvironmentReference에는 이 함수 객체의 `[[Environment]]` 슬롯에 저장된 렉시컬 환경의 참조가 할당된다. 따라서 함수는 호출된 위치와 상관 없이 자신이 정의된 위치에 따라 스코프를 결정하게 되고, 이를 **렉시컬 스코프(lexical scope)**라 한다.\r\n\r\n<br />\r\n\r\n## 클로저의 활용\r\n\r\n클로저는 상태(state)를 유지하고 이것이 외부 요인에 의해 의도치 않게 변경되지 않도록 안전하게 은닉(information hiding)하기 위해 사용한다.\r\n\r\n예를 들어 다음과 같은 카운트 기능을 만들었다고 하자.\r\n\r\n```javascript\r\nlet count = 0;\r\n\r\nconst increase = function () {\r\n    count += 1;\r\n    return count;\r\n}\r\n\r\nconsole.log(increase()); // 1\r\nconsole.log(increase()); // 2\r\nconsole.log(increase()); // 3\r\n```\r\n\r\n위 코드는 잘 작동하지만 `count` 변수가 전역 스코프에 노출되어 있다. 따라서 다른 코드에 의해 언제든지 변경이 가능하여 오류가 발생할 위험을 내포하고 있다.\r\n\r\n클로저를 통해 이를 보완하여 다음과 같이 작성할 수 있다.\r\n\r\n```javascript\r\nconst increase = (function () {\r\n\tlet count = 0;\r\n    \r\n    return function () {\r\n        count += 1;\r\n        return count;\r\n    }\r\n})();\r\n\r\nconsole.log(increase()); // 1\r\nconsole.log(increase()); // 2\r\nconsole.log(increase()); // 3\r\n```\r\n\r\n이 코드를 실행하면 런타임에 즉시 실행 함수가 실행되고 `increase`에 그 결과가 할당된다. 이때 `increase`에 할당되는 것은 즉시 실행 함수의 렉시컬 환경(`count` 변수를 포함한)을 저장한 함수 객체이다. 즉시 실행 함수의 생명주기는 이미 종료되었으므로 `count` 변수에는 오직 즉시 실행 함수가 리턴한 익명 함수만 접근할 수 있게 된다.\r\n\r\n이를 이용하여 타 언어의 private 접근 제한자를 흉내낼 수도 있다.\r\n\r\n```javascript\r\nconst createPoint = (x, y) => {\r\n  let posX = x;\r\n  let posY = y;\r\n\r\n  const get = () => {\r\n    return [posX, posY];\r\n  }\r\n\r\n  const moveX = (value) => {\r\n    posX += value;\r\n  };\r\n\r\n  const moveY = (value) => {\r\n    posY += value;\r\n  };\r\n\r\n  return {\r\n    get,\r\n    moveX,\r\n    moveY,\r\n  };\r\n};\r\n\r\nconst point = createPoint(0, 0);\r\n\r\nconsole.log(point.get()); // [ 0, 0 ]\r\npoint.moveX(5);\r\npoint.moveY(8);\r\nconsole.log(point.get()); // [ 5, 8 ]\r\n```\r\n\r\n위 예시에서는 `posX`, `posY` 변수는 `createPoint` 함수 내에 은닉시키고 `get`, `moveX`, `moveY` 클로저만 외부로 노출시켰다. 이를 통해 `createPoint` 메서드로 생성된 객체는 `posX`, `posY`의 상태를 유지하면서도 직접적인 접근은 방지하여 안전하게 사용할 수 있다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- 이웅모, 『모던 자바스크립트 Deep Dive』\r\n\r\n","excerpt":"요약 클로저 란 자신이 정의된 렉시컬 환경을 기억하는 함수다. 클로저는 상태(state)를 유지하고 이것이 외부 요인에 의해 의도치 않게 변경되지 않도록 안전하게 은닉(information hiding)하기 위해 사용한다. 클로저   클로저(Closure) 란 자신이 정의된 렉시컬 환경을 기억하는 함수다. 위 예제를 보면  inner…"}},{"node":{"id":"3c93ec35-1836-562a-b9a5-c7e79614bc6e","slug":"2022/03-10-execution-context/","frontmatter":{"title":"실행 컨텍스트(Execution Context)","date":"2022-03-10","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"실행 컨텍스트(Execution Context)\"\r\ndate: \"2022-03-10\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n\r\n\r\n## 요약\r\n\r\n**실행 컨텍스트**란 소스코드를 실행하는 데  필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역이다.\r\n\r\n코드의 실행 순서는 **실행 컨텍스트 스택**에 의해, 스코프와 식별자는 실행 컨텍스트의 **렉시컬 환경**에 의해 관리된다.\r\n\r\n<br />\r\n\r\n## 소스코드의 평가와 실행\r\n\r\n자바스크립트 엔진은 소스코드를 2개의 과정으로 나누어 처리한다.\r\n\r\n- **소스코드의 평가**\r\n  - 함수와 변수의 선언문을 실행\r\n  - 생성된 함수와 변수 식별자를 실행 컨텍스트가 관리하는 스코프에 등록\r\n  - 평가 과정이 끝나야 소스코드가 실행됨\r\n- **소스코드의 실행**\r\n  - 선언문을 제외한 소스코드를 실행\r\n  - 소스코드의 실행에 필요한 정보를 실행 컨텍스트가 관리하는 스코프에서 취득\r\n  - 실행한 결과를 다시 스코프에 반영\r\n\r\n코드가 실행되려면 스코프와 식별자의 관리와 코드 실행 순서의 관리가 필요한데, 스코프와 식별자는 **렉시컬 환경**으로, 코드의 실행 순서는 **실행 컨택스트 스택**으로 관리하게 된다.\r\n\r\n<br />\r\n\r\n## 실행 컨텍스트 스택\r\n\r\n코드를 통해 생성된 실행 컨텍스트는 스택으로 관리된다.\r\n\r\n```javascript\r\nconst a = 5;\r\n\r\nfunction foo() {\r\n    const b = 10;\r\n    function bar() {\r\n        console.log(a + b);\r\n    }\r\n    \r\n    bar();\r\n}\r\n\r\nfoo(); // 15\r\n```\r\n\r\n![execution-context-stack](.\\execution-context-stack.png)\r\n\r\n1. 프로그램이 실행되고 전역 코드가 평가되면 전역 실행 컨텍스트가 생성되어 실행 컨텍스트 스택에 추가된다. 이때 `a`, `foo`의 선언문이 실행되어 전역 실행 컨텍스트에 등록된다. 이후 전역 코드가 실행되고 `foo` 함수를 호출한다.\r\n2. `foo` 함수가 호출되면 전역 코드의 실행은 일시 중단되고 제어권이 `foo` 함수로 넘어간다. 그리고 `foo` 함수를 평가하여 실행 컨텍스트를 생성하고 스택에 추가한다. `foo` 내의 변수 `b`와 함수 `bar`는 `foo` 함수의 실행 컨텍스트에 등록된다. 이후 `foo` 함수를 실행하고 `bar` 함수를 호출한다.\r\n3. `bar` 함수가 호출되면 마찬가지로 제어권이 `bar` 함수로 넘어간다. `bar` 함수의 실행 컨텍스트가 생성되어 스택에 추가되고, 이후 함수를 실행한다. `console.log`가 호출되면 우선 스코프 체이닝을 통해 `console` 식별자를 찾고, 이후 `console` 객체에서 프로토타입 체이닝을 통해 `log` 식별자를 찾아 호출한다. 그리고 함수의 인수로 전달된 `a`와 `b` 역시 스코프 체이닝을 통해 검색한다.\r\n4. `bar`의 실행이 끝나면 다시 제어권이 `foo` 함수로 넘어오고, 실행이 끝난 `bar` 함수는 실행 컨텍스트 스택에서 제거된다.\r\n5. 이후 `foo`의 실행이 끝나 실행 컨텍스트 스택에서 제거되고, 제어권은 전역 코드로 넘어온다. 곧이어 전역 코드의 실행이 마저 끝나면 전역 실행 컨텍스트도 스택에서 제거된다.\r\n\r\n<br />\r\n\r\n## 렉시컬 환경\r\n\r\n**렉시컬 환경(Lexical Environment)**은 코드의 실행에 있어 식별자와 스코프를 관리하는 역할을 한다. 렉시컬 환경은 두 개의 컴포넌트로 구성된다.\r\n\r\n- **Environment Record**: 스코프에 포함된 식별자를 등록하고 해당 식별자에 바인딩된 값을 관리하는 저장소. 전역 코드냐 함수 코드냐에 따라 구성에 차이가 있다.\r\n  - 전역 환경\r\n    - **Object Environment Record**: BindingObject라는 전역 객체와 연결된다. 전역 코드 평가 중 `var`로 선언한 변수와 함수 선언문으로 정의된 함수는 이 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다. 이때 프로퍼티는 암묵적으로 `undefined`를 할당하고, 메서드는 생성된 함수 객체를 즉시 할당한다. 이 때문에 호이스팅이 발생한다.\r\n    - **Declarative Environment Record**: `let`, `const`로 선언한 전역 변수를 등록하고 관리한다. 따라서 이들은 전역 객체의 프로퍼티가 되지 않는다. 또한 `var` 변수와 달리 값을 초기화하지 않으므로 런타임에 실행 흐름이 변수 선언에 도달하기 전까지 일시적 사각지대(TDZ)에 빠지게 된다.\r\n    - **this Binding**: 전역 객체를 바인딩한다.\r\n  - 함수 환경\r\n    - **Function Environment Record**: 매개변수 및  함수 내부에서 선언된 변수와 함수를 등록하고 관리한다.\r\n    - **this Binding**: 함수 호출 방식에 따라 this 바인딩이 결정된다.\r\n- **Outer Lexical Environment Reference**: 상위 스코프(해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경)을 가리킨다. 이를 통해 스코프 체인을 구현한다.\r\n  - 전역 환경: 전역 코드를  포함하는 소스코드는 없으므로 null이 할당된다.\r\n  - 함수 환경: 현재 이 함수를 평가하는 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.\r\n\r\n### 블록 레벨 스코프\r\n\r\n`let`과 `const`로 선언한 변수는 블록 레벨 스코프를 따른다. 때문에 블럭 내에서 `let`이나 `const`로 변수가 선언될 경우 새로운 렉시컬 환경을 생성하여 교체한다. 블록 렉시컬 환경의 Outer Lexical Environment Reference는 블록에 진입하기 전의 렉시컬 환경을 가리키며, 블록의 실행이 끝나면 다시 기존의 렉시컬 환경으로 되돌린다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- 이웅모, 『모던 자바스크립트 Deep Dive』\r\n\r\n","excerpt":"요약 실행 컨텍스트 란 소스코드를 실행하는 데  필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역이다. 코드의 실행 순서는  실행 컨텍스트 스택 에 의해, 스코프와 식별자는 실행 컨텍스트의  렉시컬 환경 에 의해 관리된다. 소스코드의 평가와 실행 자바스크립트 엔진은 소스코드를…"}},{"node":{"id":"55ce2cf9-39a2-5e02-9feb-e102d434ad11","slug":"2022/03-09-function/","frontmatter":{"title":"함수(Function)","date":"2022-03-09","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"함수(Function)\"\r\ndate: \"2022-03-09\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n\r\n\r\n## 요약\r\n\r\n프로그래밍에서 **함수**란 **코드의 재사용**을 위해 특정한 동작을 수행하는 코드를 묶어 하나의 실행 단위로 만든 것을 말한다.\r\n\r\n함수를 정의하는 방법으로는 크게 **함수 선언문**과 **함수 표현식**이 있다.\r\n\r\n- **함수 선언문**: `function` 키워드로 시작하여 함수를 정의한다. 런타임 이전에 함수 객체를 생성한다.\r\n- **함수 표현식**: 변수에 함수 리터럴을 할당하는 형태로 함수를 정의한다. 런타임 시점에 함수 객체를 생성한다.\r\n\r\n<br />\r\n\r\n## 함수\r\n\r\n프로그래밍에서 **함수(function)**란 특정한 동작을 수행하는 코드를 묶어 하나의 실행 단위로 만든 것을 말한다. 일반적으로 함수의 구성은 다음과 같다.\r\n\r\n![function](.\\function.png)\r\n\r\n- 함수명: 함수를 호출하기 위해 사용되는 식별자(identifier)\r\n- 매개변수(parameter): 함수에 정의된, 외부로부터 전달받을 변수\r\n- 인수(argument): 함수의 입력값\r\n- 반환값(return value): 함수의 출력값\r\n\r\n함수는 동일한 작업을 반복적으로 해야할 때, 코드의 중복을 줄이고 재사용성을 높이기 위해 사용한다. 이는 코드의 유지보수성와 신뢰성을 높이는 효과가 있다.\r\n\r\n### 함수 리터럴\r\n\r\nJavaScript에서 함수는 함수 객체 타입의 값이기 때문에 리터럴로 생성할 수도 있다. 함수 리터럴은 function 키워드, 함수명, 매개변수 목록, 함수 몸체로 구성된다. 함수 리터럴의 이름은 생략할 수 있는데, 이름이 있는 함수를 **기명 함수(named function)**, 이름이 없는 함수를 **익명 함수(anonymous function)**라고 한다.\r\n\r\n```javascript\r\n// 변수에 익명 함수 리터럴을 할당\r\nconst sayHello = function () {\r\n    console.log('hello world!');\r\n}\r\n```\r\n\r\n함수 리터럴은 평가된 결과로 함수 객체를 생성하기 때문에 변수에 할당할 수도 있다.\r\n\r\n또한 기본적으로 함수의 이름은 함수 자신의 내부에서만 참조할 수 있는 식별자다. 따라서 다음과 같은 경우에는 오류가 발생한다.\r\n\r\n```javascript\r\nconst foo = function bar() {};\r\nbar(); // bar is not defined\r\n```\r\n\r\n<br />\r\n\r\n## 함수 선언문과 함수 표현식\r\n\r\n함수를 정의하는 방법으로는 크게 **함수 선언문**과 **함수 표현식**이 있다. `Function` 생성자 함수를 이용하는 방법도 있지만 권장되지 않는다.\r\n\r\n### 함수 선언문\r\n\r\n**함수 선언문(function declaration)**은 `function` 키워드로 시작하여 함수를 정의한다.\r\n\r\n```javascript\r\nfunction add(a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n함수 선언문은 함수명을 생략하지 않은 기명 함수 리터럴과 형태가 동일한데, 코드 맥락에 따라서 자바스크립트 엔진이 함수 선언문 혹은 리터럴로 해석한다. \r\n\r\n- 기명 함수 리터럴이 단독으로 사용되는 경우(즉 피연산자로 사용되지 않는 경우) 함수 선언문으로 해석한다.\r\n- 피연산자로 사용되거나 변수에 할당할 경우에는 함수 리터럴로 해석한다.\r\n\r\n또한 본래 함수명은 해당 함수의 내에서만 참조 가능한 식별자다. 하지만 함수 선언문으로 정의된 함수는 함수 외부에서도 호출할 수 있어야 한다. 따라서 자바스크립트 엔진은 함수 선언문에 의해 함수 객체가 생성될 때, 암묵적으로 함수명과 동일한 식별자를 생성하고 여기에 함수 객체를 할당한다.\r\n\r\n### 함수 표현식\r\n\r\n**함수 표현식(function expresssion)**이란 변수에 함수 리터럴을 할당하여 함수를 정의하는 것을 말한다. 기명 함수 리터럴을 써도 되지만 함수 표현식에서 함수명은 의미가 없으므로 일반적으로 익명 함수를 사용한다.\r\n\r\n```javascript\r\nconst add = function (a, b) {\r\n    return a + b;\r\n}\r\n```\r\n\r\n함수 선언문과 함수 표현식의 가장 큰 차이점은 함수 객체의 생성 시점이다.\r\n\r\n- 함수 선언문은 코드가 해석되는 시점(즉 런타임 이전)에 함수 객체를 생성한다.\r\n- 함수 표현식은 변수의 값이므로 런타임에 실행 흐름이 함수의 정의에 도달했을 때 생성된다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- 이웅모, 『모던 자바스크립트 Deep Dive』\r\n\r\n- [함수 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Functions)\r\n","excerpt":"요약 프로그래밍에서  함수 란  코드의 재사용 을 위해 특정한 동작을 수행하는 코드를 묶어 하나의 실행 단위로 만든 것을 말한다. 함수를 정의하는 방법으로는 크게  함수 선언문 과  함수 표현식 이 있다. 함수 선언문 :  function…"}},{"node":{"id":"d8bc7233-f16a-5a80-baa3-e3aa443c9698","slug":"2022/03-08-data-type/","frontmatter":{"title":"데이터 타입(Data Type)","date":"2022-03-08","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"데이터 타입(Data Type)\"\r\ndate: \"2022-03-08\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n## 요약\r\n\r\n데이터 타입이란 프로그래밍에서 여러 종류의 데이터를 식별하기 위한 분류이다.\r\n\r\nJavaScript는 동적 타입 언어로, 변수가 타입과 연결되지 않으며 모든 타입의 값으로 할당 및 재할당이 가능하다.\r\n\r\nJavaScript의 데이터 타입은 크게 원시 타입과 객체 타입으로 나뉜다.\r\n\r\n- 원시 타입은 변경할 수 없는 값을 갖는 타입이며, 숫자, 문자열, 불리언 등이 포함된다.\r\n- 원시 타입이 아닌 모든 값은 객체 타입이며, 변수에 할당할 때 원시 타입은 값 자체를 저장하는 반면, 객체 타입은 실제 객체 데이터를 저장하는 메모리의 주소(참조 값)를 저장한다.\r\n\r\n<br />\r\n\r\n## 데이터 타입\r\n\r\n프로그래밍에 있어 **데이터 타입(Data type)**, 또는 **타입(Type)**이란 정수, 실수, 문자 등 여러 종류의 데이터를 식별하기 위한 분류이다.\r\n\r\n타입을 통해 식별할 수 있는 정보는 다음과 같다.\r\n\r\n- 데이터의 의미\r\n\r\n- 해당 타입에 가능한 값\r\n- 해당 타입을 통해 수행할 수 있는 연산\r\n- 데이터가 메모리에 저장되는 방식\r\n- 데이터를 메모리에서 참조하는 방식\r\n\r\n<br />\r\n\r\n## JavaScript의 데이터 타입\r\n\r\nC, C++, Java와 같은 **정적 타입(static type) 언어**는 변수를 선언할 때 타입을 명시적으로 선언한다.\r\n\r\n```java\r\nint num = 5; // 정수 타입\r\nboolean bool = true; // 불리언 타입\r\n```\r\n\r\n정적 타입 언어는 변수의 타입을 변경할 수 없고, 선언한 타입의 값만 할당할 수 있다. 또한 컴파일 시점에서 타입 체크를 수행하는데, 만약 선언한 타입에 맞지 않는 값을 할당했다면 에러를 발생시킨다.\r\n\r\n반면 JavaScript는 **동적 타입(dynamic type) 언어**이다. JavaScript의 변수는 선언 시에 타입을 지정하지 않으며, 모든 타입의 값으로 할당 및 재할당이 가능하다. 즉 변수 선언 시에 타입을 결정하는 정적 타입 언어와 달리 동적 타입 언어는 값을 할당할 때 타입이 결정된다.\r\n\r\n```javascript\r\nlet num = 5;\r\nconsole.log(num); // 5\r\nnum = 'string';\r\nconsole.log(num); // string\r\n```\r\n\r\nJavaScript의 데이터 타입은 크게 **원시 타입(primative type)**과 **객체 타입(object type)**으로 나뉜다.\r\n\r\n### 원시 타입\r\n\r\n원시 타입이란 **변경할 수 없는 값(immutable value, 불변 값)**을 갖는 기본적인 타입을 말한다. JavaScript는 현재(ES11~) 7개의 원시 타입이 존재한다.\r\n\r\n- **number**: 숫자 타입. 정수와 실수를 구분하지 않으며 기본적으로 배정밀도 64비트 이진 형식의 값을 갖는다. 숫자 값 이외에도 `Infinity`와 `-Infinity`(양의 무한, 음의 무한), `NaN`(Not a Number)이라는 특별한 세 가지 값을 갖는다.\r\n- **string**: 문자열 타입. 텍스트 데이터를 나타내기 위해 사용한다. 문자열이란 문자의 집합이며 하나의 문자는 16비트 부호 없는(unsigned) 정수 값이다.\r\n- **boolean**: 논리적인 참/거짓을 나타내기 위한 타입. `true`, `false` 두 개의 값을 갖는다.\r\n- **undefined**: 값을 할당하지 않은 변수를 나타내기 위한 타입. undefined 타입은 `undefined` 값 하나만을 갖는다. JavaScript 엔진은 기본적으로 값을 할당하지 않은 변수를 `undefined`로 초기화한다.\r\n- **null**: undefined가 JavaScript 엔진에 의해 '값이 할당되지 않음'을 나타내기 위한 타입이라면, null은 개발자가 명시적으로 '값이 없음'을 나타내기 위한 타입이다. null 타입은 `null` 값 하나만을 갖는다.\r\n- **symbol**: ES6에서 추가. 고유하고 변경 불가능한 원시 값을 갖는 타입. 객체의 프로퍼티 키로 사용한다.\r\n- **bigint**: ES11에서 추가. 임의 정밀도(arbitrary-precision)의 정수 타입. number 타입에서는 오차가 발생하는 큰 수도 안전하게 저장하고 연산할 수 있다. 정수 끝에 n을 붙여 값을 표현한다. (예: `9007199254740992n`)\r\n\r\n> 숫자나 문자열을 변경할 수 없다는 데에 조금 의아할 수 있다. 하지만 일반적으로 변수의 값을 변경한다고 하는 것은, 실제로 값 자체를 변경하는 것이 아니라 변수에 새로운 값을 할당하는 것이다.\r\n>\r\n> ```javascript\r\n> let a = 5; // a에 숫자 타입의 값 5를 할당한다\r\n> a += 10; // a의 값과 10을 + 연산하여 생성한 값을 a에 할당한다\r\n> \r\n> let b = 'string'; // b에 문자열 타입의 값 string을 할당한다\r\n> b[3] = 'o'; // 직접 문자열을 변경하려 해도 불가능하다\r\n> b = b.slice(0, 3); // b 문자열의 0번째 ~ 3번째 이전까지의 문자로 새로운 문자열을 만들어 b에 할당한다\r\n> ```\r\n\r\n### 객체 타입\r\n\r\n원시 타입이 아닌 모든 값은 객체 타입이다. 객체 타입은 원시 타입과 근본적으로 다르다.\r\n\r\n- 원시 타입의 값은 변경할 수 없지만(immutable) 객체는 변경 가능(mutable)하다.\r\n- 원시 값을 변수에 할당하면 변수가 가리키는 메모리 공간에는 실제 값이 저장된다. 하지만 객체를 변수에 할당하면 변수가 가리키는 메모리 공간에는 실제 해당 객체를 저장하고 있는 메모리 주소, 즉 참조 값이 저장된다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- [Data type - Wikipedia](https://en.wikipedia.org/wiki/Data_type)\r\n- [JavaScript의 타입과 자료구조 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures)\r\n- 이웅모, 『모던 자바스크립트 Deep Dive』\r\n\r\n","excerpt":"요약 데이터 타입이란 프로그래밍에서 여러 종류의 데이터를 식별하기 위한 분류이다. JavaScript는 동적 타입 언어로, 변수가 타입과 연결되지 않으며 모든 타입의 값으로 할당 및 재할당이 가능하다. JavaScript…"}},{"node":{"id":"4e594b2a-aa07-5c31-bac0-3a5c15618290","slug":"2022/03-07-expression-and-statement/","frontmatter":{"title":"표현식(Expression)과 문(Statement)","date":"2022-03-07","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"표현식(Expression)과 문(Statement)\"\r\ndate: \"2022-03-07\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n## 요약\r\n\r\n문(statement)이란 토큰(token)으로 구성된 프로그램의 최소 실행 단위이다. 선언문, 할당문, 조건문, 반복문 등, 문을 통해 컴퓨터가 어떤 작업을 수행하도록 명령할 수 있다. 문의 집합이 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 작업을 프로그래밍이라 한다.\r\n\r\n표현식(expression)이란 값으로 평가될 수 있는 문을 말한다. 즉 변수에 할당할 수 있는 문을 말한다.\r\n\r\n<br />\r\n\r\n## 문\r\n\r\n**문(statement)**이란 **프로그램을 구성하는 최소 실행 단위**이다. 문의 집합이 프로그램이며, 문을 작성하고 나열하는 과정을 프로그래밍이라 할 수 있다.\r\n\r\n### 토큰\r\n\r\n문은 다시 **토큰(token)**이라는 요소로 구성된다. 토큰은 프로그램에서 가장 작은 구성요소로, **문법적으로 더 이상 나눌 수 없는 최소 단위**이다. 토큰에는 다음과 같은 것들이 있다.\r\n\r\n- 키워드: `let`, `const`, `await`, `if`...\r\n- 식별자: 변수, 함수, 클래스, 프로퍼티 등의 이름\r\n- 연산자: `+`, `-`, `&&`, `===`, `.`, `tyepof`...\r\n- 리터럴: `42`, `\"hello\"`, `[1, 2, 3]`, `true`...\r\n\r\n![token-and-statement](./token-and-statement.png)\r\n\r\n### 문의 종류\r\n\r\n문은 명령문(command statement)이라고도 한다. 즉 문을 통해 컴퓨터에게 특정한 작업을 수행하도록 명령을 내릴 수 있다.\r\n\r\n- 선언문(declaration)\r\n  - `let foo;`\r\n  - `function bar() {...}`\r\n\r\n- 할당문(assignment)\r\n  - `foo = 36;`\r\n\r\n- 조건문(conditional)\r\n  - `if (a > b) {...}`\r\n\r\n- 반복문(iteration)\r\n  - `for (let i = 0; i < 10; i++) {...}`\r\n  - `while (a > 10) {...}`\r\n- ...\r\n\r\n<br />\r\n\r\n## 표현식\r\n\r\n**표현식(expression)**이란 **값으로 평가될 수 있는 문**을 말한다. 즉 문의 실행 결과로 어떠한 값을 생성하거나 참조하고, 이를 변수에 할당할 수 있다면 표현식이라고 볼 수 있다.\r\n\r\n따라서 어떤 문이 표현식인지 아닌지 확인하는 가장 간단한 방법은 변수에 할당해 보는 것으로, 표현식이 아닌 문을 할당하려 하면 `SyntaxError`가 발생한다.\r\n\r\n> **평가(evaluate)**란 식을 해석해서 값을 생성하거나 참조하는 것을 말한다.\r\n>\r\n> - `3 + 5`: 평가의 결과로 값 `8`을 생성한다.\r\n> - `foo.bar`: 평가의 결과로 `foo` 객체의 `bar` 프로퍼티의 값을 참조한다.\r\n\r\n![statement-vs-expression](./statement-vs-expression.png)\r\n\r\n또한 표현식은 JavaScript CLI 환경에서 입력했을 때 평가된 값을 출력한다. 표현식이 아닌 문은 `undefined`를 출력한다.\r\n\r\n![개발자-도구](.\\개발자-도구.png)\r\n\r\n하지만 반환값이 없는 함수의 호출처럼 평가된 값이 `undefined`인 표현식도 있기 때문에, 이것만으로 표현식인지 아닌지를 판별하는 건 확실하지 않다. 값을 출력한다면 표현식이라고 참고만 하자.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- 이웅모, 『모던 자바스크립트 Deep Dive』\r\n\r\n- [JavaScript Keywords and Identifiers (programiz.com)](https://www.programiz.com/javascript/keywords-identifiers)\r\n- [문 및 선언 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements)\r\n\r\n","excerpt":"요약 문(statement)이란 토큰(token)으로 구성된 프로그램의 최소 실행 단위이다. 선언문, 할당문, 조건문, 반복문 등, 문을 통해 컴퓨터가 어떤 작업을 수행하도록 명령할 수 있다. 문의 집합이 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 작업을 프로그래밍이라 한다. 표현식(expression…"}},{"node":{"id":"97562451-4a31-5e97-820d-e75bb4ab49cf","slug":"2022/03-05-idomatic-expression-with-logical-operation/","frontmatter":{"title":"논리 연산자를 이용한 간단한 조건부 표현식","date":"2022-03-05","tags":["TIL","JavaScript"]},"rawBody":"---\r\ntitle: \"논리 연산자를 이용한 간단한 조건부 표현식\"\r\ndate: \"2022-03-05\"\r\ntags: [\"TIL\", \"JavaScript\"]\r\n---\r\n\r\n## 논리 연산자\r\n\r\n논리 연산자란 조건문에서 흔히 사용하는 `&&`(AND), `||`(OR), `!`(NOT) 등의 연산자를 말한다.\r\n\r\n- `A && B`: A가 참이면 B를, 거짓이면 A를 리턴한다.\r\n- `A || B`: A가 참이면 A를, 거짓이면 B를 리턴한다.\r\n\r\n- `!A`: A가 참이면 `false`를, 거짓이면 `true`를 리턴한다.\r\n\r\n여기서 말하는 참, 거짓은 `Boolean` 타입으로 형변환을 할 때 `true`로 변환될 수 있는가 아닌가를 말한다. JavaScript에선 다음의 경우는 모두 `false`로 변환되고, 그 이외의 값은 `true`로 변환된다.\r\n\r\n- `undefined`, `null`, `NaN`\r\n- `0`, `-0`, `0n`\r\n- 빈 문자열 (`\"\"`, `''`, ` `` ` 등)\r\n\r\n빈 배열(`[]`)이나 빈 객체(`{}`)는 거짓이 아님을 주의하자.\r\n\r\n<br />\r\n\r\n## 조건부 표현식\r\n\r\n함수를 정의할 때 이런 식으로 간단한 예외 처리를 할 수 있다.\r\n\r\n```javascript\r\nfunction (someObject, value) {\r\n    // value가 유효한 값이 아닐 때 someObject.value로 대체한다\r\n    if (!value) {\r\n        value = someObject.value;\r\n    }\r\n    ...\r\n}\r\n```\r\n\r\n이때 논리 연산자를 활용하면 보다 간결하게 작성할 수 있다.\r\n\r\n```javascript\r\nfunction (someObject, value) {\r\n    // value가 유효한 값이 아닐 때 someObject.value로 대체한다\r\n    value = value || someObject.value;\r\n    ...\r\n}\r\n```\r\n\r\n비슷하게 리액트의 JSX 표현식에서도 다음과 같이 활용할 수 있다.\r\n\r\n```jsx\r\nconst Profile = ({name, age}) => {\r\n  return (\r\n    <div class=\"profile\">\r\n      <div class=\"name\">{name}</div>\r\n      <!--age가 유효한 값일 때만 UI상에 표시한다-->\r\n      {age && <div class=\"age\">{age}</div>}\r\n    </div>\r\n  );\r\n};\r\n```\r\n\r\n또한 어떤 값을 강제로 `Boolean` 값으로 변환하고 싶을 때는 `!`를 두 번 사용하면 된다. 첫번째 `!`에서 해당 값에 반대되는 `Boolean` 값을 받고, 거기에 한 번 더 `!`를 사용해 원래의 `Boolean` 값을 받는 것이다. 값의 유효성 검사를 할 때 유용하게 사용할 수 있다.\r\n\r\n```javascript\r\nconst isValidProfile = (profile) => {\r\n  // profile, profile.name, profile.age 모두 유효한 값일 때 true, 아니면 false를 리턴한다\r\n  return !!(\r\n    profile &&\r\n    profile.name &&\r\n    typeof profile.name === 'string' &&\r\n    profile.age &&\r\n    typeof profile.age === 'number'\r\n  );\r\n};\r\n```\r\n\r\n위 예에서 만약 `!!`가 없다면 `Boolean`이 아닌 값(`undefined`, `null` 등)을 리턴할 가능성이 있다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- [Logical OR (||) - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR)\r\n- [Logical NOT (!) - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT)\r\n\r\n","excerpt":"논리 연산자 논리 연산자란 조건문에서 흔히 사용하는  && (AND),  || (OR),  ! (NOT) 등의 연산자를 말한다. A && B : A가 참이면 B를, 거짓이면 A를 리턴한다. A || B : A가 참이면 A를, 거짓이면 B를 리턴한다. !A : A가 참이면  false 를, 거짓이면  true…"}},{"node":{"id":"e84b1151-4dd5-5e3b-a705-ddd7d3ddd68e","slug":"2022/02-28-hoisting/","frontmatter":{"title":"호이스팅(Hoisting)","date":"2022-02-28","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"호이스팅(Hoisting)\"\r\ndate: \"2022-02-28\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n## 요약\r\n\r\n호이스팅이란 JavaScript의 특징으로, 함수나 변수의 선언을 코드의 최상단으로 끌어올린 것처럼 동작하는 방식을 말한다.\r\n\r\n호이스팅은 JavaScript가 함수 단위 스코프를 따르는 언어이기 때문에 발생한다. 한 함수 내에서 함수나 변수는 함수 전체에 걸쳐 정의되기 때문에, 필연적으로 함수 최상단에서 선언된 것과 같은 동작을 한다.\r\n\r\n<br />\r\n\r\n## JavaScript의 함수 단위 스코프와 호이스팅\r\n\r\n과거(ES6 이전) JavaScript의 특징 중 하나는 함수 단위 스코프를 갖는다는 것이었다. 블록 단위 스코프를 갖는 타 언어와 달리 JavaScript는 함수 내의 모든 변수는 함수 전체에 걸쳐 정의된다.\r\n\r\n```javascript\r\nfunction test(num) {\r\n    if (num > 5) {\r\n        var i = 10;\r\n    }\r\n    \r\n    console.log(i); // 이 i는 if문 안에서 선언된 i와 같다!\r\n}\r\n\r\ntest(3); // undefined (if문에 진입하지 않았으므로 i는 10으로 초기화되지 않음)\r\ntest(7); // 10 (i는 if문에 들어가 10으로 초기화됨)\r\n```\r\n\r\n위 예시에서 `Uncaught ReferenceError: i is not defined`라는 에러 메시지가 아닌 `undefined`가 출력되는 것을 확인할 수 있다. 즉 실제 선언부까지 가지 않더라도, 함수에 진입한 시점에서 이미 `i`는 선언된 상태와 같다. 마치 변수의 선언부와 초기화를 따로 떼어내고 선언부를 스코프 맨 위로 **끌어올린** 것처럼 동작한다고 해서 이를 **호이스팅(hoisting, 끌어올림)**이라고 한다.\r\n\r\n```javascript\r\n// 위 함수는 마치 아래처럼 동작한다.\r\n// 실제로 코드가 이런 식으로 변환되는 것은 아니고\r\n// 메모리 상에서 이처럼 동작한다는 뜻!\r\nfunction test(num) {\r\n    var i; // i의 선언부\r\n    if (num > 5) {\r\n        i = 10; // i 초기화\r\n    }\r\n    \r\n    console.log(i);\r\n}\r\n```\r\n\r\n[MDN](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)에서는 호이스팅을 아래와 같이 정의하고 있다.\r\n\r\n> *JavaScript에서 **호이스팅**(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다.*\r\n\r\n<br />\r\n\r\n## 호이스팅의 특징\r\n\r\n### `var`\r\n\r\n`var`로 선언한 변수는 호이스팅되어 `undefined`로 초기화된다. 따라서 초기화 전에 사용해도 오류는 발생하지 않는다.\r\n\r\n### `let`과 `const`\r\n\r\n`let`, `const`로 선언한 변수와 상수는 호이스팅이 되지 않는다고 알려져 있기도 하다. 엄밀히 말하자면 호이스팅은 일어나지만(즉 메모리 상에 공간은 할당되지만) 값이 초기화되지 않는다. 사용하려 하면 **초기화 전에는 접근할 수 없다**라는 에러 메시지를 볼 수 있다.\r\n\r\nES6부터 추가된 `let`과 `const`는 블록 단위 스코프를 위한 키워드이므로 일반적인 호이스팅을 따르지 않는다고 볼 수 있다.\r\n\r\n### 초기화는 호이스팅되지 않는다\r\n\r\n끌어올려지는 것은 선언(Declare) 뿐이고 초기화(Initialize)는 끌어올려지지 않는다. 따라서 `var`로 선언한 변수를 정의한 위치보다 앞에서 사용할 수 있다 해도, 단지 오류만 나지 않을 뿐이지 초기화 전까지는 원하는 동작을 할 수는 없을 것이다.\r\n\r\n### 함수 선언은 호이스팅된다\r\n\r\n함수 선언은 호이스팅되며 정의된 위치보다 앞에서 자유롭게 사용할 수 있다.\r\n\r\n```javascript\r\nprint_hello(); // hello world!\r\nfunction print_hello() {\r\n\tconsole.log('hello world!');\r\n}\r\n```\r\n\r\n### 함수 표현식은 호이스팅되지 않는다\r\n\r\n표현식으로 정의된 함수는 자신이 할당된 변수를 통해 참조된다. 그리고 변수의 초기화는 호이스팅되지 않으므로 함수 표현식 역시 자신이 정의된 위치 이전에는 사용할 수 없다.\r\n\r\n<br />\r\n\r\n## 호이스팅의 쓰임새\r\n\r\n함수 선언의 호이스팅은 함수를 정의한 순서에 상관 없이 사용할 수 있다는 점에서 유용하게 사용할 수 있다.\r\n\r\n단 변수의 호이스팅은 잠재적인 버그의 원인이 된다. 예상치 못한 동작을 예방하기 위해 과거에는 함수에서 사용하는 모든 변수를 함수 시작 부분에 선언하는 등의 컨벤션이 존재하기도 했다. 현재는 블록 단위 스코프를 따르는 `let`과 `const`가 있으므로 `var` 키워드 및 변수의 호이스팅은 더 이상 사용되지 않는다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- [호이스팅 - 용어 사전 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)\r\n\r\n- [JavaScript Hoisting (w3schools.com)](https://www.w3schools.com/js/js_hoisting.asp)\r\n- [javascript - Is there any benefit from hoisting? - Stack Overflow](https://stackoverflow.com/questions/62806172/is-there-any-benefit-from-hoisting)\r\n\r\n- 데이비드 플래너건, 『자바스크립트 완벽 가이드(6판)』","excerpt":"요약 호이스팅이란 JavaScript의 특징으로, 함수나 변수의 선언을 코드의 최상단으로 끌어올린 것처럼 동작하는 방식을 말한다. 호이스팅은 JavaScript…"}},{"node":{"id":"3af64858-872b-5874-8a56-f811204080af","slug":"2022/02-27-this/","frontmatter":{"title":"this","date":"2022-02-27","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"this\"\r\ndate: \"2022-02-27\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n## 요약\r\n\r\nJavaScript에서 `this`는 함수가 호출되는 방식에 따라 달라진다.\r\n\r\n- 전역 컨텍스트: 전역 객체를 가리킨다.\r\n- 함수 단순 호출: 엄격 모드라면 `undefined`를, 그렇지 않다면 전역 객체를 가리킨다.\r\n- 객체 메서드: 해당 객체를 가리킨다.\r\n- 함수 생성자: 생성될 객체를 가리킨다.\r\n- 이벤트 핸들러: 이벤트 핸들러가 등록된 엘리먼트를 가리킨다.\r\n\r\nES5부터 추가된 `bind`, `call` 등은 호출 위치에 상관 없이 특정 객체를 `this`로 사용할 수 있게 해주고, ES6부터 추가된 화살표 함수는 `this`를 갖지 않는다.\r\n\r\n<br />\r\n\r\n## this\r\n\r\n일반적으로 `this`는 객체지향 언어의 클래스에서 사용되며, 객체 내에서 자기자신을 참조하기 위해 사용된다. 하지만 JavaScript에서는 상황에 따라 가리키는 대상이 달라지며 이런 애매모호함(?)이 JavaScript의 초반 진입장벽 중 하나로 작용하곤 한다.\r\n\r\nJavaScript에서 `this`는 호출되는 방식에 따라 `this`가 가리키는 값이 달라진다. 즉 this 바인딩은 함수 호출 시점에 결정된다. `bind`, `call` 등의 메서드를 통해 호출되는 위치에 관계 없이 `this` 값을 고정할 수도 있고, 화살표 함수는 자신의 `this` 값을 갖지 않는다.\r\n\r\n### 전역 컨텍스트\r\n\r\n전역 컨텍스트에서 `this`는 전역 객체를 가리킨다. 다른 컨텍스트에서 전역 객체를 참조하고 싶을 땐 `globalThis`를 사용하면 된다.\r\n\r\n```javascript\r\nconsole.log(window === this); // true, 웹 브라우저에선 window가 전역 객체임\r\n```\r\n\r\n### 함수 단순 호출\r\n\r\n엄격 모드가 아닐 때 `this`는 전역 객체를 가리킨다. 엄격 모드라면 `undefined`를 가리킨다.\r\n\r\n```javascript\r\nfunction notStrict() {\r\n\treturn this;\r\n}\r\n\r\nfunction strict() {\r\n\t'use strict';\r\n\treturn this;\r\n}\r\n\r\nconsole.log(notStrict() === window); // true\r\nconsole.log(strict() === undefined); // true\r\n```\r\n\r\n### 객체의 메서드에서\r\n\r\n어떤 객체의 메서드로서 호출하면 `this`는 그 객체를 가리킨다.\r\n\r\n```javascript\r\nfunction introduce () {\r\n\tconsole.log(`my name is ${this.name}`);\r\n}\r\n\r\nconst obj = {\r\n    name: 'hansekim',\r\n    introduce: introduce,\r\n}\r\n\r\nobj.introduce(); // my name is hansekim\r\n```\r\n\r\n### 함수 생성자에서\r\n\r\nJavaScript에서는 함수를 통해 객체 타입을 정의하고 `new ` 키워드와 함께 사용하여 객체를 생성할 수 있다. 이때 함수를 생성자(constructor)라고 한다. 생성자 내에서 `this`는 생성자를 통해 생성될 객체를 가리킨다.\r\n\r\n```javascript\r\n// 생성자 네이밍은 파스칼 케이스를 따른다\r\nfunction Animal (name, sound) {\r\n    // 생성자에서 this는 생성될 객체를 가리킨다\r\n\tthis.name = name;\r\n    this.sound = sound;\r\n    this.printSound = function () {\r\n        console.log(`${this.name}: ${this.sound}!`);\r\n    }\r\n}\r\n\r\nconst dog = new Animal('dog', 'bark');\r\ndog.printSound(); // dog: bark!\r\n```\r\n\r\n### 이벤트 핸들러에서\r\n\r\n`addEventListener()`를 이용해 엘리먼트에 이벤트 핸들러를 등록하면 `this`는 이벤트 핸들러를 등록한 엘리먼트를 가리킨다. 이벤트 객체 `e`에 대해 `e.currentTarget`과 동일하다.\r\n\r\n`this`를 사용하면 화살표 함수의 사용이 제한되거나 다른 this 바인딩 문제가 발생할 수 있으므로 웬만하면 `e.currentTarget`을 사용하는 게 더 좋아 보인다.\r\n\r\n```javascript\r\n// 이벤트 핸들러로서 호출하면 핸들러가 등록된 요소의 텍스트 색상을 빨간색으로 변경함\r\nfunction toRedText (e) {\r\n    console.log(e.currentTarget === this); // 항상 true\r\n    this.style.color = 'red';\r\n}\r\n\r\n// 모든 엘리먼트에 클릭하면 텍스트가 빨간색이 되도록 핸들러를 붙임\r\ndocument.querySelectorAll('*').forEach((element) => {\r\n    element.addEventListener('click', toRedText);\r\n});\r\n```\r\n\r\n### bind, call, apply\r\n\r\n`bind`, `call`, `apply`는 ES5부터 추가된 `Function` 타입 객체(즉 함수)의 메서드다. 첫 번째 인자로 새로이 할당할 `this`값을, 나머지 인자로 해당 함수의 초기 인자를 전달한다.\r\n\r\n- `bind`: `this` 인자와 함수의 초기 인자들을 받아 원본 함수의 복제를 리턴한다.\r\n- `call`: `this` 인자와 함수의 초기 인자들을 받아 원본 함수를 호출한다.\r\n- `apply`: `this` 인자와 함수의 초기 인자 배열을 받아 원본 함수를 호출한다.\r\n\r\n이렇게 `bind`, `call`, `apply`로 생성하거나 호출한 함수는 호출 방법에 상관 없이 첫 번째 인자로 전달한 객체를 `this`로 사용한다.\r\n\r\n```javascript\r\nfunction introduce (age) {\r\n\tconsole.log(`my name is ${this.name}`);\r\n    if (age) console.log(`i'm ${age} years old`);\r\n}\r\n\r\nconst hanseKim = {name: 'hanseKim'};\r\nconst john = {name: 'john'};\r\nintroduce.call(hanseKim); // my name is hanseKim\r\nintroduce.call(john, 16); // my name is john / i'm 16 years old\r\n```\r\n\r\n### 화살표 함수\r\n\r\n화살표 함수는 자신의 `this`를 갖지 않는다. 따라서 위에서 언급한 사례들을 전부 무시하고 상위 스코프의 `this`를 가리킨다.\r\n\r\n```javascript\r\nfunction Counter() {\r\n    this.num = 0; // 이 this는 생성자의 인스턴스를 가리킨다\r\n    \r\n    setInterval(() => {\r\n        this.num += 1; // 화살표 함수는 this를 갖지 않으므로\r\n        console.log(this.num); // 상위 스코프의 this를 가리킨다\r\n    }, 1000);\r\n}\r\n\r\nnew Counter();\r\n// 1\r\n// 2\r\n// 3\r\n// ...\r\n```\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- [this - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this)\r\n\r\n","excerpt":"요약 JavaScript에서  this 는 함수가 호출되는 방식에 따라 달라진다. 전역 컨텍스트: 전역 객체를 가리킨다. 함수 단순 호출: 엄격 모드라면  undefined 를, 그렇지 않다면 전역 객체를 가리킨다. 객체 메서드: 해당 객체를 가리킨다. 함수 생성자: 생성될 객체를 가리킨다. 이벤트 핸들러: 이벤트 핸들러가 등록된 엘리먼트를 가리킨다. ES…"}},{"node":{"id":"139a0e7b-3005-5610-8c03-d4f46f28147e","slug":"2022/02-26-immediately-invoked-function-expression/","frontmatter":{"title":"즉시 실행 함수(IIFE)","date":"2022-02-26","tags":["JavaScript"]},"rawBody":"---\r\ntitle: \"즉시 실행 함수(IIFE)\"\r\ndate: \"2022-02-26\"\r\ntags: [\"JavaScript\"]\r\n---\r\n\r\n## 요약\r\n\r\nIIFE란 정의되자마자 즉시 실행되는 JavaScript 함수를 말한다. 함수 표현식을 감싸는 큰 괄호(그룹 연산자)와, 이 함수를 실행시키는 괄호(호출 연산자)로 구성되어 있다.\r\n(예: `(function() {...})();`)\r\n\r\nIIFE내의 변수는 밖에서 접근이 불가능하기 때문에, 글로벌 스코프를 오염시키지 않고 웹 페이지를 초기화할 수 있어 유용하다. 또 클로저와 함께 활용하면 private한 값을 만들 수도 있다.\r\n\r\n<br />\r\n\r\n## 즉시 실행 함수 표현식\r\n\r\n**즉시 실행 함수 표현식(IIFE, Immediately Invoked Function Expression)**이란 정의되자마자 즉시 실행되는 JavaScript 함수를 말한다. 다른 말로는 자가 실행 익명 함수(Self-Executing Anonymous Function)라고도 한다.\r\n\r\n```javascript\r\n(function() {\r\n    console.log('hello, world!');\r\n})();\r\n```\r\n\r\n<br />\r\n\r\n## IIFE를 사용하는 이유\r\n\r\n### 전역 스코프 오염을 방지\r\n\r\n대표적으로 페이지를 초기화하기 위한 코드는 여러 번 사용할 필요가 없을 뿐더러, 전역 스코프에 함수나 변수를 추가한다면 예기치 않은 버그를 초래할 가능성이 있다. 이러한 경우에 IIFE를 사용하면 전역 스코프를 오염시키지 않고 원하는 기능을 실행할 수 있다.\r\n\r\n```javascript\r\n// appElement, container 등이 전역 스코프에 추가되어 버그를 일으킬 수 있다\r\nconst appElement = () = React.createElement(App);\r\nconst container = document.getElementById('App');\r\nReactDOM.render(appElement, container);\r\n```\r\n\r\n```javascript\r\n// IIFE를 사용하면 전역 스코프에 변수가 남지 않는다\r\n(function() {\r\n    const appElement = () = React.createElement(App);\r\n    const container = document.getElementById('App');\r\n    ReactDOM.render(appElement, container);\r\n})();\r\n```\r\n\r\n### IIFE 내부로의 접근을 막음\r\n\r\n표현식 내부의 변수는 외부에서 접근할 수 없다.\r\n\r\n```javascript\r\n(function() {\r\n\tconst fruit = 'apple';\r\n})();\r\n\r\nconsole.log(fruit); // Error: fruit is not defined\r\n```\r\n\r\n이를 이용해 IIFE와 클로저를 활용해서 private한 값을 갖는 함수를 만들 수도 있다. 예를 들어 auto-increasement id를 구현할 때 다음과 같이 구현할 수 있는데,\r\n\r\n```javascript\r\nlet count = 0;\r\nconst autoIncreasementId = function() {\r\n    count += 1;\r\n\treturn `id_${count}`;\r\n};\r\n\r\nconsole.log(autoIncreasementId()); // id_1\r\nconsole.log(autoIncreasementId()); // id_2\r\nconsole.log(autoIncreasementId()); // id_3\r\n```\r\n\r\n이러면 `count` 변수가 전역 스코프에 노출되고 또 변경 가능하기 때문에 다른 함수에서 변경하거나 접근하면 버그의 원인이 될 수 있다. 이를 IIFE로 한번 래핑하여 다음과 같이 사용함으로써 `count`를 private한 값으로 만들 수 있고, 보다 안전하게 사용할 수 있다.\r\n\r\n```javascript\r\nconst autoIncreasementId = (function () {\r\n  let count = 0;\r\n  return function () {\r\n    count += 1;\r\n    return `id_${count}`;\r\n  }\r\n})();\r\n\r\nconsole.log(autoIncreasementId()); // id_1\r\nconsole.log(autoIncreasementId()); // id_2\r\nconsole.log(autoIncreasementId()); // id_3\r\n```\r\n\r\n### 전역스코프의 변수 사용을 래핑\r\n\r\n두 라이브러리에서 동일한 이름의 전역 변수를 사용하는 경우가 발생할 수 있다. 이럴 때 코드를 IIFE로 래핑해서 해당 전역변수를 넘겨주는 방식을 이용해 문제를 해결할 수 있다.\r\n\r\n예를 들어 jQuery에서는 전역 변수 `jQuery`의 축약으로 `$`를 사용한다. 기존에 이 `$`를 사용한 코드가 있을 때, 새로 추가한 다른 라이브러리에서 `$`라는 전역변수를 사용한다면 이런 식으로 충돌을 회피할 수 있다.\r\n\r\n```javascript\r\n// 다른 라이브러리\r\nwindow.$ = function someFunction() { ... }\r\n\r\n(function ($) {\r\n    // jQuery를 사용하는 코드\r\n    ...\r\n})(jQuery);\r\n```\r\n\r\n래핑한 함수의 매개변수로 `$`를 정의했고 즉시 실행할 때 `jQuery`를 인수로 넘겨줬다. 그러면 `$`는 함수 스코프의 변수가 되어 전역 스코프의 `$`와는 상관 없이 `jQuery`를 `$`로서 사용할 수 있게 된다.\r\n\r\n<br />\r\n\r\n## 참고 자료\r\n\r\n- [IIFE - 용어 사전 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Glossary/IIFE)\r\n\r\n- [12 Simple (Yet Powerful) JavaScript Tips – JavaScript Is Sexy](http://javascriptissexy.com/12-simple-yet-powerful-javascript-tips/)\r\n\r\n- [Use Cases for JavaScript's IIFEs — Marius Schulz](https://mariusschulz.com/blog/use-cases-for-javascripts-iifes)\r\n","excerpt":"요약 IIFE란 정의되자마자 즉시 실행되는 JavaScript 함수를 말한다. 함수 표현식을 감싸는 큰 괄호(그룹 연산자)와, 이 함수를 실행시키는 괄호(호출 연산자)로 구성되어 있다.\n(예:  (function() {...})(); ) IIFE…"}},{"node":{"id":"d48bd4e0-fa52-5d30-bef2-0ce1ba97d944","slug":"2022/02-24-arrow-function/","frontmatter":{"title":"화살표 함수(Arrow Function)","date":"2022-02-24","tags":["JavaScript","ES6"]},"rawBody":"---\r\ntitle: \"화살표 함수(Arrow Function)\"\r\ndate: \"2022-02-24\"\r\ntags: [\"JavaScript\", \"ES6\"]\r\n---\r\n\r\n## 요약\r\n\r\n화살표 함수란 ES6부터 추가된 새로운 형태의 함수 표현식이다. 기존의 `function` 키워드를 이용한 함수 표현식에 비해 간결하고 직관적인 함수 정의가 가능하다.\r\n\r\n화살표 함수의 특징은 `this`를 갖지 않는다는 점이다. 기존 함수는 자신이 호출된 위치에 따라 `this`가 가리키는 대상이 달라진다. 반면 화살표 함수는 어디에서 호출되든 항상 자신이 작성된 위치, 즉 렉시컬 컨텍스트의 `this`를 가리킨다.\r\n\r\n따라서 객체의 생성자, 메서드로 사용할 수 없고 `.bind()`나 `.call()` 등으로 `this`를 지정해도 무시한다.\r\n\r\n<br />\r\n\r\n## 화살표 함수\r\n\r\n```javascript\r\n// 전통적인 함수 표현식\r\nconst add = function(a, b) {\r\n    return a + b;\r\n};\r\n\r\n// 화살표 함수\r\nconst add = (a, b) => a + b;\r\n```\r\n\r\n**화살표 함수(arrow function)**란 ES6에서 추가된 새로운 함수 표현식(expression)이다. `function` 키워드를 통해 함수를 정의하는 것보다 짧고 직관적으로 함수를 정의할 수 있게 해준다.\r\n\r\n극단적인 경우로 인자가 하나이고 표현식이 한 줄인 함수의 경우 인자의 괄호를 생략하여 `인자 => 표현식`으로 함수를 나타낼 수도 있다. 중괄호를 생략한 표현식은 `{return 표현식}`과 동일하다.\r\n\r\n```javascript\r\nconst getLength = str => str.length;\r\n\r\n// 위와 동일한 함수\r\nfunction getLength(str) {\r\n  return str.length;\r\n}\r\n```\r\n\r\n단 JavaScript에서는 코드 블록을 구분할 때, 객체 리터럴을 사용할 때 모두 중괄호(`{}`)를 사용하므로, 화살표 함수에서 객체 리터럴을 리턴할 때 중괄호와 `return`을 생략하면 표현이 모호해진다.\r\n\r\n```javascript\r\nconst objList = someList.map(() => {}); // Error, {}가 객체인지 코드블럭인지 모호함\r\n```\r\n\r\n따라서 화살표 함수에서 객체 리터럴을 리턴할 때에는 반드시 그룹 연산자로 감싸줘야 한다.\r\n\r\n```javascript\r\nconst objList = someList.map(() => ({})); // OK\r\n```\r\n\r\n<br />\r\n\r\n## 화살표 함수의 특징\r\n\r\n### `this`를 바인딩하지 않음\r\n\r\n화살표 함수는 자신의 `this`를 갖지 않는다. 자신이 작성된 렉시컬 컨텍스트의 `this`를 가리킨다. 이를 통해 중첩된 함수에서의 `this` 스코프 문제를 단순화할 수 있다.\r\n\r\n```javascript\r\nfunction Counter() {\r\n    this.num = 0; // 이 this는 생성자의 인스턴스를 가리킨다\r\n    \r\n    setInterval(function() {\r\n        this.num += 1; // 무명함수 내에서 새로이 바인딩된 this\r\n        console.log(this.num); // 따라서 this는 전역객체를 가리킨다\r\n        // 그리고 this.num은 정의되지 않았으므로\r\n        // 매번 undefined + 1의 결과인 NaN을 출력한다\r\n    }, 1000);\r\n}\r\n\r\nnew Counter();\r\n// NaN\r\n// NaN\r\n// NaN\r\n// ...\r\n```\r\n\r\n```javascript\r\nfunction Counter() {\r\n    this.num = 0; // 이 this는 생성자의 인스턴스를 가리킨다\r\n    \r\n    setInterval(() => {\r\n        this.num += 1; // 화살표 함수는 this를 갖지 않으므로\r\n        console.log(this.num); // 바깥의 가장 가까운 this를 가리킨다\r\n    }, 1000);\r\n}\r\n\r\nnew Counter();\r\n// 1\r\n// 2\r\n// 3\r\n// ...\r\n```\r\n\r\n`bind()`, `call()`, `apply()` 등으로 `this`를 지정해주는 것 역시 무시하며, 객체의 메서드로 사용될 경우에도 `this`는 렉시컬 컨텍스트의 `this`를 가리킨다.\r\n\r\n```javascript\r\nconst obj = {\r\n\ta: 5,\r\n\tprintA: () => console.log(this.a), // this는 obj가 아닌 전역 스코프의 this, 즉 전역 객체를 가리킨다\r\n};\r\n\r\nobj.printA(); // undefined\r\na = 10;\r\nobj.printA(); // 10\r\n```\r\n\r\n또한 화살표 함수는 생성자로 사용할 수 없으며 `new` 키워드와 함께 사용하면 오류가 발생한다.\r\n\r\n```javascript\r\nconst Animal = () => {\r\n    this.name = 'dog';\r\n    this.sound = 'bark';\r\n};\r\n\r\nnew Animal(); // Uncaught TypeError: Animal is not a constructor\r\n```\r\n\r\n### 간결함\r\n\r\n작성해야 할 코드의 양이 대폭 줄어들기 때문에 보다 생산성이 높고, 형태(`(인수) => 반환값`)가 \"인수를 받아 값을 반환한다\"라는 함수의 본질에 가까워 직관적이다. 특히 함수를 리턴하는 고차 함수에서 더욱 그렇다.\r\n\r\n```javascript\r\nconst createAdd = (num) => (operand) => operand + num;\r\nconst add2 = createAdd(2);\r\nconsole.log(add2(6)); // 8\r\n```\r\n\r\n```javascript\r\n// 위 add 함수를 기존의 함수표현식으로 고치면 아래와 같다\r\nconst createAdd = function(num) {\r\n    return function(operand) {\r\n        return operand + num;\r\n    }\r\n}\r\n```\r\n\r\n화살표 함수는 고차 함수가 필수적으로 사용되며 this 바인딩이 필요 없는 함수형 프로그래밍에서 유용하게 쓰일 수 있다.\r\n\r\n<br />\r\n\r\n## 참고자료\r\n\r\n- [화살표 함수 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\r\n- [ES6 In Depth: Arrow functions - Mozilla Hacks - the Web developer blog](https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/)\r\n\r\n","excerpt":"요약 화살표 함수란 ES6부터 추가된 새로운 형태의 함수 표현식이다. 기존의  function  키워드를 이용한 함수 표현식에 비해 간결하고 직관적인 함수 정의가 가능하다. 화살표 함수의 특징은  this 를 갖지 않는다는 점이다. 기존 함수는 자신이 호출된 위치에 따라  this…"}}]}},"pageContext":{"tag":"JavaScript"}},
    "staticQueryHashes": ["2278949984","3702207254"]}