{"data":{"allMdx":{"nodes":[{"id":"6ec2fee4-ef08-5c88-b666-a41da3300ccd","body":"\n최근 회사에서 가볍고 빠른 성능의 사이트가 필요하다는 요구가 있어 Vite와 Svelte로 SPA를 개발하게 되었습니다. 동적 라우팅이 필요했고, 경로에 따라 백오피스에서 설정한 커스텀 페이지를 보여주는 사이트였습니다.\n\n문제는 동적 경로에 따라 OG 메타태그를 적용해야 한다는 사실이었습니다. 취업 준비를 하던 시절 \"CSR = SEO가 불가능\"이라고 거의 공식처럼 암기했기 때문에, 저는 당연히 불가능한 일이라고 생각했습니다.\n\n하지만 뜻밖에도 [이 문제를 해결한 포스팅](https://techblog.woowahan.com/15469/)을 알게 되었고, 이를 참고해 무사히 해결할 수 있었습니다. (감사합니다!) 비슷한 고민이 있는 분들은 해당 포스팅이 큰 도움이 되리라 생각합니다.\n\n전반적인 해결 방법은 위 포스팅을 통해서도 충분히 얻을 수 있었지만, 그럼에도 겪은 문제들과 이를 통해 알게 된 내용들을 정리했습니다.\n\n## CSR에서 동적 OG 메타태그를 적용하는 방법\n\n![cloudfront-events-that-trigger-lambda-functions.png](./cloudfront-events-that-trigger-lambda-functions.png)\n\n<span style={{textAlign: 'center', margin: '0 auto', fontStyle: 'italic', color: 'var(--color-text-footer)'}}>출처: [AWS 공식문서](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-cloudfront-trigger-events.html)</span>\n\nAWS CloudFront에서는 위와 같은 네 구간에 엣지 함수를 설정할 수 있습니다.\n\n방법을 요약하면 Viewer request 이벤트에 엣지 함수를 설정해서, 요청자가 봇인지 아닌지를 판별해 봇일 경우 **OG 메타태그만을 포함한 HTML**을 생성하여 응답으로 보내는 것입니다.\n\n즉 봇에 의한 요청일 경우 Viewer request 단계에서 바로 응답을 생성하여 OG 메타태그 HTML을 응답으로 보내고, 그 이외에 실사용자에 의한 요청일 경우 정상적으로 CloudFront 원본(제 경우에는 S3)을 거쳐 응답을 보냅니다.\n\n주의할 점은 만약 클라이언트 사이드 라우팅 방식이 hash property 기반일 경우에는 위 방식이 불가능하다는 것입니다. hash property는 서버로 전달되지 않기 때문에, 어떤 페이지를 요청하든 CloudFront 측에서는 동일한 페이지로 간주합니다. 이로 인해 페이지별로 적절한 OG 태그를 생성하는 것이 어렵습니다.\n\n저 역시 위와 같은 이슈로 인해 라우팅 라이브러리를 변경해야 했습니다.\n\n## **CloudFront Functions** vs **Lambda@Edge**\n\n둘의 차이는 위 포스팅에 잘 요약되어 있고, [공식 문서](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/edge-functions-choosing.html)에서 좀더 상세한 내용을 확인할 수 있습니다.\n\n제가 고려한 차이점은 다음과 같습니다.\n\n| | CloudFront Functions | Lambda@Edge |\n| :---: | --- | --- |\n| 특징 | 간단한 작업에 적합 | 복잡한 작업 가능 |\n| 적용 가능한 이벤트 | Viewer request/response | Viewer request/response,<br/>Origin request/response |\n| 네트워크 통신 | X | O |\n| 외부 라이브러리 사용 | X | O |\n| 비용 | 요청당 비용 청구 | 요청 및 함수 지속 시간당<br/>비용 청구 |\n\n제 경우에는 OG 태그 생성을 위해 API 콜이 필수적이었으므로 Lambda@Edge 외엔 선택지가 없었습니다.\n\n## ~~람다 계층 사용~~\n\n처음에는 Fetch API를 사용해 API 콜을 하려 했지만, `fetch` 함수가 존재하지 않는다는 에러를 만났습니다. 람다 함수는 노드 환경이고 Fetch API는 웹 브라우저가 제공하는 API이기 때문입니다.\n\n저는 그 대안으로서 Aixos를 사용하고자 했습니다. Axios의 기반이 되는 XHR 역시 브라우저 API지만, Axios는 서버 사이드에서도 동작하는 라이브러리인 만큼 노드 환경에 필요한 dependency가 갖춰져 있을 거라 생각했습니다.\n\n람다 함수에서 외부 라이브러리를 사용하는 방법은 크게 두 가지였습니다.\n\n- 외부 라이브러리를 포함하는 .zip 파일을 생성해 업로드한다.\n\n- **람다 계층(Lambda layer)** 을 추가한다.\n\n람다 계층이란 람다 함수와 별도로 외부 종속성을 관리하기 위한 기능입니다. 즉 저 두 가지 방식은 라이브러리 코드를 하나의 람다 함수 패키지에 전부 집어넣느냐, 아니면 따로 분리해서 관리하느냐 차이입니다.\n\n람다 계층을 사용하면 하나의 종속성을 여러 람다 함수에서 재사용 가능하기 때문에, 종속성을 추가할 때 일반적으로 권장하는 방법이었습니다. 따라서 저도 이 방법을 택했습니다.\n\n계층을 구성하는 방법은 간단한데, 우선 아래와 같은 형태로 구성되도록 .zip 파일을 만든 후 AWS 콘솔에서 람다 계층을 추가할 때 업로드하면 됩니다.\n\n```\naxios-layer.zip\n└ nodejs\n  └ axios\n    └ ...\n```\n\n람다 함수의 런타임 버전이 계층의 호환 런타임 버전에 포함되어야 한다는 점만 주의하면 계층 생성에서 크게 어려운 점은 없었습니다.\n\n저는 Axios 종속성을 위한 계층을 생성하고 이를 람다 함수에 추가했습니다. 그리고 **Lambda@Edge에는 계층 사용이 불가능하다**는 사실을 뒤늦게 알게 되었습니다. ([](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-at-edge-function-restrictions.html#lambda-at-edge-restrictions-features))\n\n## 네트워크 통신, 그리고 해결\n\n[노드의 HTTPS 모듈](https://nodejs.org/api/https.html)을 사용해 API 콜을 할 수 있었습니다. Lambda@Edge 문서의 함수 예제에는 없는 내용이라 구글링을 하던 중 한 AWS 포스팅에서 해당 내용을 찾게 되었습니다. ([](https://aws.amazon.com/ko/blogs/networking-and-content-delivery/leveraging-external-data-in-lambdaedge/))\n\nHTTPS 모듈은 사용 방법이 조금 복잡해서, 아래와 같이 한번 래핑해서 사용했습니다.\n\n```javascript\nconst fetchData = (url) => {\n  return new Promise((resolve, reject) => {\n    https\n      .get(url, function (res) {\n        res.setEncoding('utf8');\n\n        let rawData = '';\n\n        res.on('data', (chunk) => {\n          rawData += chunk.toString();\n        });\n\n        res.on('end', function () {\n          try {\n            const parsedData = JSON.parse(rawData);\n            resolve(parsedData);\n          } catch (e) {\n            resolve({ error: true });\n          }\n        });\n      })\n      .on('error', function (e) {\n        resolve({ error: true });\n      });\n  });\n};\n```\n\n또한 함수가 잘 동작하는지 확인하기 위해 주기적으로 테스트를 해가며 함수를 작성할 필요가 있었는데, 저는 다음과 같은 과정을 거쳐 테스트 데이터를 구했습니다.\n\n1. [Lambda@Edge 이벤트 구조](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html) 문서에서 일반적인 Viewer request 이벤트를 구해 테스트하고, 기본적인 함수를 구성합니다.\n\n2. [함수 예제](https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-examples.html#lambda-examples-generated-response-examples)를 참고하여 Viewer request에서 바로 응답을 생성하는 함수를 작성합니다. 이때, response body는 `handler` 함수의 `event` 파라미터를 `JSON.stringify()`로 처리한 값을 넣습니다.\n\n3. 웹사이트의 CloudFront에 람다 함수를 연결합니다. 웹사이트에 접속하면 실제 Viewer request 이벤트를 본문으로 얻을 수 있습니다.\n\n위와 같은 과정을 거쳐 테스트 데이터를 얻고, 무사히 원하는 기능을 구현할 수 있었습니다.\n\n## 마치며\n\n처음에는 당연히 불가능하다고 생각한 일이었고 실제로 프론트엔드 코드 상에서 해결하기는 힘든 이슈였습니다. 그러나 인프라를 통해 해결할 수 있었고, 이러한 경험을 얻은 것을 행운이라 생각합니다.\n\n문제를 해결하기 위한 시야가 한층 더 넓어진 한편, 좁은 상식을 근거로 불가능하다고 단정지었던 제 자신을 반성할 수 있는 기회였습니다.\n\n마지막으로 이 문제를 해결하는 데 도움을 준 모든 자료와 포스팅에 감사드리며, 이 글이 비슷한 고민을 하는 분들께 유용한 참고자료가 되기를 바랍니다.\n","frontmatter":{"title":"CSR에서 동적 OG 적용하기","tags":["AWS","Troubleshooting"]}},{"id":"bc60687d-0032-5900-95bc-54d1e296d073","body":"\n실무에서 정적 사이트 배포 환경을 구성하며 겪은 이슈입니다. \n\n## SPA란?\n\n**Single-page application**의 줄임말로, 말 그대로 단일 문서로 이루어진 웹사이트를 의미합니다. 페이지별로 HTML파일이 존재했던 고전적인 방식의 사이트와 달리 하나의 HTML로 구현되기 때문에, 사이트 내의 컨텐츠는 Javascript를 통해 동적으로 생성합니다.\n\nAngular를 필두로 React, Vue 등 쟁쟁한 SPA 프레임워크가 등장하며 프론트엔드 개발의 주류로 자리매김합니다.\n\n단일 문서를 사용하기에 **클라이언트 사이드 라우팅**을 통해 페이지 이동을 구현하며, 새로운 문서를 로드하지 않고 화면이 전환되므로 사용자는 쾌적한 사이트 이용 경험을 얻을 수 있습니다.\n\n## 클라이언트 사이드 라우팅이란?\n\nSPA에서 사용자가 링크를 클릭할 때마다 페이지를 새로고침하지 않고 다른 페이지로 이동하기 위한 개념입니다. 크게 다음 두 가지 기능을 포함합니다.\n\n- URL 변경을 감지해 그 경로에 매핑된 컴포넌트를 렌더링합니다.\n\n- 새로고침을 유발하지 않고 사용자의 URL을 임의로 조작합니다.\n\n사용자의 URL을 변경하는 방식은 또다시 두 가지로 구분할 수 있습니다.\n\n1. `window.history` API를 사용:\n\n    `window.history` API의 `pushState`, `replaceState` 등의 메서드를 사용하여 새로고침을 유발하지 않고 URL을 변경하는 방식입니다. Svelte의 svelte-routing 라이브러리가 이에 속합니다.\n    \n    URL의 실제 경로를 변경하므로 정적 사이트로 배포할 경우, 후술할 404 오류 이슈를 유발합니다. \n\n2. hash property를 사용:\n\n    `Location` 인터페이스의 [**hash property**](https://developer.mozilla.org/en-US/docs/Web/API/Location/hash)를 사용하는 방식으로 Svelte의 svelte-spa-router 라이브러리가 이에 속합니다.\n    \n    hash property란 URL의 뒤에 `#`과 함께 붙는 값으로, 본래는 현재 페이지 내에서 Hash property를 id로 갖는 엘리먼트 위치로 스크롤하는 역할을 합니다.\n    \n    `#` 뒤에 붙는 값은 기본적으로 브라우저 상에서만 인식되고, 서버 측에는 전달되지 않기 때문에 새로운 페이지 로드를 유발하지 않습니다. 이러한 특성으로 클라이언트 사이드 라우팅에 사용되기도 합니다. 한편 SEO에는 불리한 면이 있습니다.\n\n저는 원래 2번 방식 기반의 라이브러리를 사용했기 때문에 큰 문제가 없었지만, 모종의 이유로 1번 방식으로 교체하면서 이슈를 겪게 되었습니다.\n\n## SPA routing 404 오류 이슈\n\n본디 URL이란 사용자가 원하는 리소스를 요청하기 위한 경로를 의미합니다. 즉, `https://foo.bar/baz`라는 주소로 요청을 한다면, `https://foo.bar` 웹 서버는 기본적으로 `./baz.html` 파일을 찾아서 응답으로 전송합니다.\n\n그러나 SPA는 단일 문서(`./index.html`)만이 존재하기 때문에, 다른 경로로 이동한 상태에서 새로고침 등으로 새 문서 로드를 유발하면 404 오류가 발생합니다. 그 경로에 해당하는 HTML이 존재하지 않기 때문입니다.\n\n한편 해시 라우팅을 사용한다면 이 문제는 발생하지 않습니다. 예를 들어, `https://foo.bar/#/baz`라는 URL에서 `#/baz`는 Hash property이므로 서버는 이를 인식하지 못합니다. 따라서 `https://foo.bar` 웹 서버는 `./index.html`을 응답으로 보냅니다.\n\n어쨌든 이를 해결하기 위해서는 어떤 경로로 요청을 하든 `./index.html`을 응답으로 보내도록 처리해야 합니다.\n\n## AWS S3, CloudFront에서 오류 페이지 핸들링\n\n저는 AWS S3와 CloudFront로 배포 환경을 구성했기 때문에 여기서 핸들링을 할 필요가 있었습니다. S3와 CloudFront 둘 다 오류 처리 기능을 제공했기 때문에, 둘 중 하나를 택해야 했습니다.\n\n### S3에서 오류 처리\n\n![s3-static-site-hosting.png](./s3-static-site-hosting.png)\n\nS3의 **정적 웹 사이트 호스팅(Static website hosting)** 기능을 사용하면 오류 시 보여줄 문서를 설정할 수 있습니다.\n\n- 장점:\n    - 간편하게 설정할 수 있습니다.\n\n    - S3의 기본 기능을 활용하기 때문에 추가적인 비용이 발생하지 않습니다.\n\n- 단점:\n   - 세부적인 오류 처리 설정이 어렵습니다.\n\n   - 어디까지나 오류가 발생했을 때 응답으로 전송할 문서를 설정하는 것이기 때문에, 네트워크 상에서는 오류가 발생한 것으로 취급합니다.\n   \n   - 검색 엔진이 특정 페이지를 없는 페이지로 판단할 수 있기에 SEO에 불리할 수 있습니다.\n\n### CloudFront에서 오류 처리\n\n![cloudfront-custom-error-response.png](./cloudfront-custom-error-response.png)\n\nCloudFront의 **사용자 정의 오류 응답(Custom error response)** 을 사용하면 에러 코드별로 어떻게 처리할지 세세하게 설정할 수 있습니다.\n\n- 장점:\n    - 오류 코드별로 세세한 설정을 할 수 있어 유연성이 높습니다.\n\n    - 캐싱 기능을 통해 성능을 높일 수 있습니다.\n\n- 단점:\n    - CloudFront 사용에 따른 추가 비용이 발생할 수 있습니다.\n\n둘 중 어느 방법을 선택하든 SPA는 정상적으로 동작하게 됩니다. 단, CloudFront에서 처리하는 것이 깔끔하고 SEO 친화적이기 때문에, 저는 CloudFront에서 처리하는 방법을 선택했습니다.\n\n## 마치며\n\n저는 프론트엔드 개발을 Next.js로 시작했기 때문에, SPA나 CSR에 대해서는 공부할 때 잠깐 다뤄보기만 했지 실제로 배포까지 진행해본 적은 없었습니다. 그렇기에 이번에 맞딱뜨린 이 이슈는 저로서는 꽤나 생소한 것이었습니다.\n\n아직 SSR 프레임워크가 유행하기 이전에는 아마 꽤 일반적인 이슈였을 것입니다. 서버 사이드 로직까지 다룰 수 있는 Next.js를 사용하면서 인프라에 대한 중요성을 잊고 있었던 게 아닌가 합니다.\n\n이번 경험을 통해 프론트엔드 개발자라 할지라도 인프라와 배포 과정에 대한 충분한 이해가 필요함을 다시금 깨달았습니다. 기술이 발전하면서 개발 환경은 점점 더 편리해지고 있지만, 기본적인 원리와 문제 해결 능력은 여전히 중요한 요소일 것입니다.\n","frontmatter":{"title":"SPA 404 이슈 해결","tags":["AWS","Troubleshooting"]}},{"id":"64f4f5a2-8371-5bb1-be8d-0e54c4a670e8","body":"\n이 블로그에서는 gatsby-plugin-mdx 플러그인을 사용해 마크다운을 파싱 및 렌더링하고 있습니다. 이 플러그인에 remarkGfm을 적용하며 발생한 이슈입니다.\n\n## GFM이란?\n\n**GitHub Flavored Markdown**의 줄임말로, 기본적인 마크다운 문법의 확장입니다. Github에서 처음 지원하기 시작했으며 다음과 같은 추가 기능을 제공합니다.\n\n- 확장 문법: 다음과 같은 요소를 위한 문법이 추가되었습니다.\n    - 테이블\n    - 작업 목록 (Task list)\n    - 취소선\n- 자동 링크 삽입: URL이나 이메일 주소를 자동으로 `<a>` 태그로 감쌉니다.\n- HTML 필터링: 마크다운에는 기본적으로 인라인 HTML 태그를 사용할 수 있지만, GFM에서는 `<script>`나 `<iframe>` 등, 몇 가지의 HTML태그가 보안상의 이유로 무시됩니다.\n\n대부분이 Github나 다른 마크다운 에디터에서 당연하게 사용하고 있던 기능들이라, 이것들이 확장 문법이라는 사실을 이번에 처음 알았습니다. 저는 테이블 문법이 동작하지 않는 원인을 찾다가 알게 되었습니다.\n\n## remark-gfm 적용\n\n[gatsby-plugin-mdx 공식문서](https://www.gatsbyjs.com/plugins/gatsby-plugin-mdx/#mdxoptions)에 의하면, GFM을 적용하려면 gatsby-config에 remark-gfm을 추가해야 합니다. 저는 이 과정에서 두 가지 이슈를 겪었습니다.\n\n### 모듈 시스템 문제\n\n처음에 별 생각 없이 문서의 예시를 그대로 사용했는데 아래와 같은 에러가 발생했습니다. CommonJS에서 ESM의 구문(import문)을 사용했기 때문입니다.\n\n```\nSyntaxError: Cannot use import statement outside a module\n```\n\n반대로 import문을 require로 고쳐봤더니 또다시 에러가 발생했습니다. 알고 보니 `remark-gfm`은 ES 모듈이었고, 이를 `require()`로 불러오려고 해서 발생한 문제였습니다.\n\n이를 해결하기 위해 [공식 문서](https://www.gatsbyjs.com/docs/how-to/custom-configuration/es-modules/)를 참고해 gatsby 파일들을 CommonJS에서 ESM으로 마이그레이션하는 작업을 진행했습니다.\n\n### 패키지 버전 문제\n\n모듈 시스템 문제를 해결하고 다시 실행해보니 이번에는 아래와 같은 에러가 발생했습니다.\n\n```\nERROR #gatsby-plugin-mdx_10001 PLUGIN\n...\nTypeError: Cannot read properties of undefined (reading 'inTable')\n```\n\nremarkGfm이 작동하는 과정에서 라이브러리 내부적으로 뭔가 이슈가 발생한 것 같았습니다. 구글링을 했더니 이미 [동일한 이슈](https://github.com/gatsbyjs/gatsby/issues/38789)가 올라와 있었습니다.\n\n해당 이슈에서 제안한 대로 `remark-gfm`의 버전을 4.0.0에서 3.0.1(4.0.0 바로 아래 버전)로 낮춰서 해결했습니다.\n","frontmatter":{"title":"마크다운 플러그인에 GFM 적용하기","tags":["Gatsby","Troubleshooting"]}},{"id":"a318a39e-4242-5f58-9489-4d1e68d2ae43","body":"\n## 요약\n\n운영체제나 파일 시스템에 따라 Git 저장소는 파일명의 대소문자를 구분하지 않기도 합니다.\n\n이 경우, 다음과 같은 방법으로 파일명의 대소문자를 변경할 수 있습니다.\n\n```shell\ngit mv myfile.txt MyFile.txt\n```\n\n<br />\n\n## 상세\n\nGit의 `core.ignorecase` 설정값은 기본적으로 `false`입니다. 하지만 `git init`이나 `git clone`을 통해 저장소를 생성할 때, 운영체제나 파일 시스템에 따라 `true`로 설정되기도 합니다.\n\n대표적으로 macOS의 APFS나 Windows의 NTFS는 대소문자를 구분하지 않는 파일 시스템입니다. 따라서 `core.ignorecase` 설정은 `true`가 되어 Git에서도 대소문자를 구분하지 않습니다.\n\n그러나 이로 인해 특정 커밋에서 파일명을 변경할 때 대소문자만 변경하려고 한다면 의도대로 변경이 되지 않을 것입니다. 예를 들어 다음과 같은 작업을 수행했다고 합시다.\n\n```shell\nmkdir my-repo\ncd my-repo\ngit init\ntouch test.txt\ngit add .\ng commit -m \"add test.txt\"\n```\n\n이제 이 저장소의 인덱스에는 `test.txt` 파일이 추가되었다. 인덱스는 `git ls-files` 명령어를 통해 확인할 수 있습니다.\n\n```shell\ngit ls-files\n# > test.txt\n```\n\n여기서 `test.txt`를 `TEST.txt`로 변경하고 싶다면 다음과 같은 시도를 할 수 있을 것입니다.\n\n```shell\nmv test.txt TEST.txt\nls\n# > TEST.txt\n```\n\n파일명이 성공적으로 바뀐 것처럼 보입니다. 하지만 파일 시스템에서 대소문자를 구분하지 않기 때문에 실제로 파일을 참조하는 데에는 영향이 없습니다. `rm test.txt` 명령어를 실행해보면 `TEST.txt` 파일이 삭제되는 것을 확인할 수 있습니다.\n\n```shell\nrm test.txt\nls # TEST.txt가 삭제되어 어떤 파일도 확인할 수 없다\n\ngit reset --hard HEAD # 최신 커밋 상태로 되돌려 test.txt 파일을 복구한다\nmv test.txt TEST.txt\nls\n# > TEST.txt\n```\n\n마찬가지로 Git에서도 변경점을 인식하지 못하므로 `git commit`을 수행할 수 없습니다.\n\n```shell\ngit status\n# > On branch main\n# > nothing to commit, working tree clean\n```\n\n`core.ignorecase`가 `true`인 상태에서 파일명의 대소문자를 변경하려면 `git mv` 명령어를 사용할 수 있습니다. unstaged 상태에서는 이를 변경으로 취급하지 않기 때문에 자동으로 staging area에 올라가게 됩니다.\n\n```shell\ngit mv test.txt TEST.txt\ngit status\n# > On branch main\n# > Changes to be committed:\n# >   (use \"git restore --staged <file>...\" to unstage)\n# > \trenamed:    test.txt -> TEST.txt\ng commit -m \"change to TEST.txt\"\n```\n\n저장소의 인덱스에서도 올바르게 변경된 것을 확인할 수 있습니다.\n\n```shell\ngit ls-files\n# > TEST.txt\n```\n\n---\n\n다른 방법으로는 `core.ignorecase` 설정값을 아예 바꿔버릴 수도 있으나, 이는 예기치 못한 문제를 일으킬 수 있기 때문에 권장되지 않습니다.\n\n```shell\ngit config core.ignorecase false\n```\n\n<br />\n\n## 참고\n\n- [Git - git-config Documentation](https://git-scm.com/docs/git-config#Documentation/git-config.txt-coreignoreCase)\n- [stack overflow - Is it a good idea to set git config core.ignorecase to false?](https://stackoverflow.com/questions/58192285/is-it-a-good-idea-to-set-git-config-core-ignorecase-to-false)","frontmatter":{"title":"Git 대소문자 구분","tags":["TIL","Git"]}},{"id":"db1bdadf-8d33-58ba-82b2-46957ee538e2","body":"\n## 요약\n\n**클로저**란 자신이 정의된 렉시컬 환경을 기억하는 함수다.\n\n클로저는 상태(state)를 유지하고 이것이 외부 요인에 의해 의도치 않게 변경되지 않도록 안전하게 은닉(information hiding)하기 위해 사용한다.\n\n<br />\n\n## 클로저\n\n<b>클로저(Closure)</b>란 자신이 정의된 렉시컬 환경을 기억하는 함수다.\n\n```javascript\nconst text = 'global';\n\nfunction outer() {\n    const text = 'local';\n    const inner = function () {\n        console.log(text);\n    }\n    return inner;\n}\n\nconst inner = outer(); // outer를 호출하면 중첩 함수 inner를 반환\ninner(); // 출력: local\n```\n\n위 예제를 보면 `inner`가 호출되는 시점에서 `outer` 함수는 생명주기가 끝나 실행 컨텍스트 스택에서 제거된 상태임에도 불구하고, `outer` 함수의 렉시컬 환경의 `text` 변수를 참조하는 것을 확인할 수 있다. 즉 외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩 함수는 생명주기가 끝난 외부 함수의 변수를 참조할 수 있고, 이러한 중첩 함수를 클로저라고 부른다.\n\n### 렉시컬 스코프\n\n함수 객체는 생성되는 시점에서 현재 실행중인 실행 컨텍스트의 렉시컬 환경에 대한 참조를 `[[Environment]]` 슬롯에 저장한다. 그리고 함수를 호출할 때 생성되는 함수 실행 컨텍스트의 OuterLexicalEnvironmentReference에는 이 함수 객체의 `[[Environment]]` 슬롯에 저장된 렉시컬 환경의 참조가 할당된다. 따라서 함수는 호출된 위치와 상관 없이 자신이 정의된 위치에 따라 스코프를 결정하게 되고, 이를 <b>렉시컬 스코프(lexical scope)</b>라 한다.\n\n<br />\n\n## 클로저의 활용\n\n클로저는 상태(state)를 유지하고 이것이 외부 요인에 의해 의도치 않게 변경되지 않도록 안전하게 은닉(information hiding)하기 위해 사용한다.\n\n예를 들어 다음과 같은 카운트 기능을 만들었다고 하자.\n\n```javascript\nlet count = 0;\n\nconst increase = function () {\n    count += 1;\n    return count;\n}\n\nconsole.log(increase()); // 1\nconsole.log(increase()); // 2\nconsole.log(increase()); // 3\n```\n\n위 코드는 잘 작동하지만 `count` 변수가 전역 스코프에 노출되어 있다. 따라서 다른 코드에 의해 언제든지 변경이 가능하여 오류가 발생할 위험을 내포하고 있다.\n\n클로저를 통해 이를 보완하여 다음과 같이 작성할 수 있다.\n\n```javascript\nconst increase = (function () {\n\tlet count = 0;\n    \n    return function () {\n        count += 1;\n        return count;\n    }\n})();\n\nconsole.log(increase()); // 1\nconsole.log(increase()); // 2\nconsole.log(increase()); // 3\n```\n\n이 코드를 실행하면 런타임에 즉시 실행 함수가 실행되고 `increase`에 그 결과가 할당된다. 이때 `increase`에 할당되는 것은 즉시 실행 함수의 렉시컬 환경(`count` 변수를 포함한)을 저장한 함수 객체이다. 즉시 실행 함수의 생명주기는 이미 종료되었으므로 `count` 변수에는 오직 즉시 실행 함수가 리턴한 익명 함수만 접근할 수 있게 된다.\n\n이를 이용하여 타 언어의 private 접근 제한자를 흉내낼 수도 있다.\n\n```javascript\nconst createPoint = (x, y) => {\n  let posX = x;\n  let posY = y;\n\n  const get = () => {\n    return [posX, posY];\n  }\n\n  const moveX = (value) => {\n    posX += value;\n  };\n\n  const moveY = (value) => {\n    posY += value;\n  };\n\n  return {\n    get,\n    moveX,\n    moveY,\n  };\n};\n\nconst point = createPoint(0, 0);\n\nconsole.log(point.get()); // [ 0, 0 ]\npoint.moveX(5);\npoint.moveY(8);\nconsole.log(point.get()); // [ 5, 8 ]\n```\n\n위 예시에서는 `posX`, `posY` 변수는 `createPoint` 함수 내에 은닉시키고 `get`, `moveX`, `moveY` 클로저만 외부로 노출시켰다. 이를 통해 `createPoint` 메서드로 생성된 객체는 `posX`, `posY`의 상태를 유지하면서도 직접적인 접근은 방지하여 안전하게 사용할 수 있다.\n\n<br />\n\n## 참고 자료\n\n- 이웅모, 『모던 자바스크립트 Deep Dive』\n\n","frontmatter":{"title":"클로저(Closure)","tags":["JavaScript"]}},{"id":"cffe8beb-c670-5d4f-b96e-8d9609a0f1c2","body":"\n\n\n## 요약\n\n**실행 컨텍스트**란 소스코드를 실행하는 데  필요한 환경을 제공하고 코드의 실행 결과를 관리하는 영역이다.\n\n코드의 실행 순서는 **실행 컨텍스트 스택**에 의해, 스코프와 식별자는 실행 컨텍스트의 **렉시컬 환경**에 의해 관리된다.\n\n<br />\n\n## 소스코드의 평가와 실행\n\n자바스크립트 엔진은 소스코드를 2개의 과정으로 나누어 처리한다.\n\n- **소스코드의 평가**\n  - 함수와 변수의 선언문을 실행\n  - 생성된 함수와 변수 식별자를 실행 컨텍스트가 관리하는 스코프에 등록\n  - 평가 과정이 끝나야 소스코드가 실행됨\n- **소스코드의 실행**\n  - 선언문을 제외한 소스코드를 실행\n  - 소스코드의 실행에 필요한 정보를 실행 컨텍스트가 관리하는 스코프에서 취득\n  - 실행한 결과를 다시 스코프에 반영\n\n코드가 실행되려면 스코프와 식별자의 관리와 코드 실행 순서의 관리가 필요한데, 스코프와 식별자는 **렉시컬 환경**으로, 코드의 실행 순서는 **실행 컨택스트 스택**으로 관리하게 된다.\n\n<br />\n\n## 실행 컨텍스트 스택\n\n코드를 통해 생성된 실행 컨텍스트는 스택으로 관리된다.\n\n```javascript\nconst a = 5;\n\nfunction foo() {\n    const b = 10;\n    function bar() {\n        console.log(a + b);\n    }\n    \n    bar();\n}\n\nfoo(); // 15\n```\n\n![execution-context-stack](.\\execution-context-stack.png)\n\n1. 프로그램이 실행되고 전역 코드가 평가되면 전역 실행 컨텍스트가 생성되어 실행 컨텍스트 스택에 추가된다. 이때 `a`, `foo`의 선언문이 실행되어 전역 실행 컨텍스트에 등록된다. 이후 전역 코드가 실행되고 `foo` 함수를 호출한다.\n2. `foo` 함수가 호출되면 전역 코드의 실행은 일시 중단되고 제어권이 `foo` 함수로 넘어간다. 그리고 `foo` 함수를 평가하여 실행 컨텍스트를 생성하고 스택에 추가한다. `foo` 내의 변수 `b`와 함수 `bar`는 `foo` 함수의 실행 컨텍스트에 등록된다. 이후 `foo` 함수를 실행하고 `bar` 함수를 호출한다.\n3. `bar` 함수가 호출되면 마찬가지로 제어권이 `bar` 함수로 넘어간다. `bar` 함수의 실행 컨텍스트가 생성되어 스택에 추가되고, 이후 함수를 실행한다. `console.log`가 호출되면 우선 스코프 체이닝을 통해 `console` 식별자를 찾고, 이후 `console` 객체에서 프로토타입 체이닝을 통해 `log` 식별자를 찾아 호출한다. 그리고 함수의 인수로 전달된 `a`와 `b` 역시 스코프 체이닝을 통해 검색한다.\n4. `bar`의 실행이 끝나면 다시 제어권이 `foo` 함수로 넘어오고, 실행이 끝난 `bar` 함수는 실행 컨텍스트 스택에서 제거된다.\n5. 이후 `foo`의 실행이 끝나 실행 컨텍스트 스택에서 제거되고, 제어권은 전역 코드로 넘어온다. 곧이어 전역 코드의 실행이 마저 끝나면 전역 실행 컨텍스트도 스택에서 제거된다.\n\n<br />\n\n## 렉시컬 환경\n\n<b>렉시컬 환경(Lexical Environment)</b>은 코드의 실행에 있어 식별자와 스코프를 관리하는 역할을 한다. 렉시컬 환경은 두 개의 컴포넌트로 구성된다.\n\n- **Environment Record**: 스코프에 포함된 식별자를 등록하고 해당 식별자에 바인딩된 값을 관리하는 저장소. 전역 코드냐 함수 코드냐에 따라 구성에 차이가 있다.\n  - 전역 환경\n    - **Object Environment Record**: BindingObject라는 전역 객체와 연결된다. 전역 코드 평가 중 `var`로 선언한 변수와 함수 선언문으로 정의된 함수는 이 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다. 이때 프로퍼티는 암묵적으로 `undefined`를 할당하고, 메서드는 생성된 함수 객체를 즉시 할당한다. 이 때문에 호이스팅이 발생한다.\n    - **Declarative Environment Record**: `let`, `const`로 선언한 전역 변수를 등록하고 관리한다. 따라서 이들은 전역 객체의 프로퍼티가 되지 않는다. 또한 `var` 변수와 달리 값을 초기화하지 않으므로 런타임에 실행 흐름이 변수 선언에 도달하기 전까지 일시적 사각지대(TDZ)에 빠지게 된다.\n    - **this Binding**: 전역 객체를 바인딩한다.\n  - 함수 환경\n    - **Function Environment Record**: 매개변수 및  함수 내부에서 선언된 변수와 함수를 등록하고 관리한다.\n    - **this Binding**: 함수 호출 방식에 따라 this 바인딩이 결정된다.\n- **Outer Lexical Environment Reference**: 상위 스코프(해당 실행 컨텍스트를 생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경)을 가리킨다. 이를 통해 스코프 체인을 구현한다.\n  - 전역 환경: 전역 코드를  포함하는 소스코드는 없으므로 null이 할당된다.\n  - 함수 환경: 현재 이 함수를 평가하는 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.\n\n### 블록 레벨 스코프\n\n`let`과 `const`로 선언한 변수는 블록 레벨 스코프를 따른다. 때문에 블럭 내에서 `let`이나 `const`로 변수가 선언될 경우 새로운 렉시컬 환경을 생성하여 교체한다. 블록 렉시컬 환경의 Outer Lexical Environment Reference는 블록에 진입하기 전의 렉시컬 환경을 가리키며, 블록의 실행이 끝나면 다시 기존의 렉시컬 환경으로 되돌린다.\n\n<br />\n\n## 참고 자료\n\n- 이웅모, 『모던 자바스크립트 Deep Dive』\n\n","frontmatter":{"title":"실행 컨텍스트(Execution Context)","tags":["JavaScript"]}},{"id":"79ddb368-5dc0-5e7b-bd69-2526a726f2de","body":"\n\n\n## 요약\n\n프로그래밍에서 **함수**란 **코드의 재사용**을 위해 특정한 동작을 수행하는 코드를 묶어 하나의 실행 단위로 만든 것을 말한다.\n\n함수를 정의하는 방법으로는 크게 **함수 선언문**과 **함수 표현식**이 있다.\n\n- **함수 선언문**: `function` 키워드로 시작하여 함수를 정의한다. 런타임 이전에 함수 객체를 생성한다.\n- **함수 표현식**: 변수에 함수 리터럴을 할당하는 형태로 함수를 정의한다. 런타임 시점에 함수 객체를 생성한다.\n\n<br />\n\n## 함수\n\n프로그래밍에서 <b>함수(function)</b>란 특정한 동작을 수행하는 코드를 묶어 하나의 실행 단위로 만든 것을 말한다. 일반적으로 함수의 구성은 다음과 같다.\n\n![function](.\\function.png)\n\n- 함수명: 함수를 호출하기 위해 사용되는 식별자(identifier)\n- 매개변수(parameter): 함수에 정의된, 외부로부터 전달받을 변수\n- 인수(argument): 함수의 입력값\n- 반환값(return value): 함수의 출력값\n\n함수는 동일한 작업을 반복적으로 해야할 때, 코드의 중복을 줄이고 재사용성을 높이기 위해 사용한다. 이는 코드의 유지보수성와 신뢰성을 높이는 효과가 있다.\n\n### 함수 리터럴\n\nJavaScript에서 함수는 함수 객체 타입의 값이기 때문에 리터럴로 생성할 수도 있다. 함수 리터럴은 function 키워드, 함수명, 매개변수 목록, 함수 몸체로 구성된다. 함수 리터럴의 이름은 생략할 수 있는데, 이름이 있는 함수를 <b>기명 함수(named function)**, 이름이 없는 함수를 **익명 함수(anonymous function)</b>라고 한다.\n\n```javascript\n// 변수에 익명 함수 리터럴을 할당\nconst sayHello = function () {\n    console.log('hello world!');\n}\n```\n\n함수 리터럴은 평가된 결과로 함수 객체를 생성하기 때문에 변수에 할당할 수도 있다.\n\n또한 기본적으로 함수의 이름은 함수 자신의 내부에서만 참조할 수 있는 식별자다. 따라서 다음과 같은 경우에는 오류가 발생한다.\n\n```javascript\nconst foo = function bar() {};\nbar(); // bar is not defined\n```\n\n<br />\n\n## 함수 선언문과 함수 표현식\n\n함수를 정의하는 방법으로는 크게 **함수 선언문**과 **함수 표현식**이 있다. `Function` 생성자 함수를 이용하는 방법도 있지만 권장되지 않는다.\n\n### 함수 선언문\n\n<b>함수 선언문(function declaration)</b>은 `function` 키워드로 시작하여 함수를 정의한다.\n\n```javascript\nfunction add(a, b) {\n    return a + b;\n}\n```\n\n함수 선언문은 함수명을 생략하지 않은 기명 함수 리터럴과 형태가 동일한데, 코드 맥락에 따라서 자바스크립트 엔진이 함수 선언문 혹은 리터럴로 해석한다. \n\n- 기명 함수 리터럴이 단독으로 사용되는 경우(즉 피연산자로 사용되지 않는 경우) 함수 선언문으로 해석한다.\n- 피연산자로 사용되거나 변수에 할당할 경우에는 함수 리터럴로 해석한다.\n\n또한 본래 함수명은 해당 함수의 내에서만 참조 가능한 식별자다. 하지만 함수 선언문으로 정의된 함수는 함수 외부에서도 호출할 수 있어야 한다. 따라서 자바스크립트 엔진은 함수 선언문에 의해 함수 객체가 생성될 때, 암묵적으로 함수명과 동일한 식별자를 생성하고 여기에 함수 객체를 할당한다.\n\n### 함수 표현식\n\n<b>함수 표현식(function expresssion)</b>이란 변수에 함수 리터럴을 할당하여 함수를 정의하는 것을 말한다. 기명 함수 리터럴을 써도 되지만 함수 표현식에서 함수명은 의미가 없으므로 일반적으로 익명 함수를 사용한다.\n\n```javascript\nconst add = function (a, b) {\n    return a + b;\n}\n```\n\n함수 선언문과 함수 표현식의 가장 큰 차이점은 함수 객체의 생성 시점이다.\n\n- 함수 선언문은 코드가 해석되는 시점(즉 런타임 이전)에 함수 객체를 생성한다.\n- 함수 표현식은 변수의 값이므로 런타임에 실행 흐름이 함수의 정의에 도달했을 때 생성된다.\n\n<br />\n\n## 참고 자료\n\n- 이웅모, 『모던 자바스크립트 Deep Dive』\n\n- [함수 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Functions)\n","frontmatter":{"title":"함수(Function)","tags":["JavaScript"]}},{"id":"9c56be40-101f-5234-9c92-cc2d2dc391e9","body":"\n## 요약\n\n데이터 타입이란 프로그래밍에서 여러 종류의 데이터를 식별하기 위한 분류이다.\n\nJavaScript는 동적 타입 언어로, 변수가 타입과 연결되지 않으며 모든 타입의 값으로 할당 및 재할당이 가능하다.\n\nJavaScript의 데이터 타입은 크게 원시 타입과 객체 타입으로 나뉜다.\n\n- 원시 타입은 변경할 수 없는 값을 갖는 타입이며, 숫자, 문자열, 불리언 등이 포함된다.\n- 원시 타입이 아닌 모든 값은 객체 타입이며, 변수에 할당할 때 원시 타입은 값 자체를 저장하는 반면, 객체 타입은 실제 객체 데이터를 저장하는 메모리의 주소(참조 값)를 저장한다.\n\n<br />\n\n## 데이터 타입\n\n프로그래밍에 있어 <b>데이터 타입(Data type)**, 또는 **타입(Type)</b>이란 정수, 실수, 문자 등 여러 종류의 데이터를 식별하기 위한 분류이다.\n\n타입을 통해 식별할 수 있는 정보는 다음과 같다.\n\n- 데이터의 의미\n\n- 해당 타입에 가능한 값\n- 해당 타입을 통해 수행할 수 있는 연산\n- 데이터가 메모리에 저장되는 방식\n- 데이터를 메모리에서 참조하는 방식\n\n<br />\n\n## JavaScript의 데이터 타입\n\nC, C++, Java와 같은 **정적 타입(static type) 언어**는 변수를 선언할 때 타입을 명시적으로 선언한다.\n\n```java\nint num = 5; // 정수 타입\nboolean bool = true; // 불리언 타입\n```\n\n정적 타입 언어는 변수의 타입을 변경할 수 없고, 선언한 타입의 값만 할당할 수 있다. 또한 컴파일 시점에서 타입 체크를 수행하는데, 만약 선언한 타입에 맞지 않는 값을 할당했다면 에러를 발생시킨다.\n\n반면 JavaScript는 **동적 타입(dynamic type) 언어**이다. JavaScript의 변수는 선언 시에 타입을 지정하지 않으며, 모든 타입의 값으로 할당 및 재할당이 가능하다. 즉 변수 선언 시에 타입을 결정하는 정적 타입 언어와 달리 동적 타입 언어는 값을 할당할 때 타입이 결정된다.\n\n```javascript\nlet num = 5;\nconsole.log(num); // 5\nnum = 'string';\nconsole.log(num); // string\n```\n\nJavaScript의 데이터 타입은 크게 <b>원시 타입(primative type)**과 **객체 타입(object type)</b>으로 나뉜다.\n\n### 원시 타입\n\n원시 타입이란 <b>변경할 수 없는 값(immutable value, 불변 값)</b>을 갖는 기본적인 타입을 말한다. JavaScript는 현재(ES11~) 7개의 원시 타입이 존재한다.\n\n- **number**: 숫자 타입. 정수와 실수를 구분하지 않으며 기본적으로 배정밀도 64비트 이진 형식의 값을 갖는다. 숫자 값 이외에도 `Infinity`와 `-Infinity`(양의 무한, 음의 무한), `NaN`(Not a Number)이라는 특별한 세 가지 값을 갖는다.\n- **string**: 문자열 타입. 텍스트 데이터를 나타내기 위해 사용한다. 문자열이란 문자의 집합이며 하나의 문자는 16비트 부호 없는(unsigned) 정수 값이다.\n- **boolean**: 논리적인 참/거짓을 나타내기 위한 타입. `true`, `false` 두 개의 값을 갖는다.\n- **undefined**: 값을 할당하지 않은 변수를 나타내기 위한 타입. undefined 타입은 `undefined` 값 하나만을 갖는다. JavaScript 엔진은 기본적으로 값을 할당하지 않은 변수를 `undefined`로 초기화한다.\n- **null**: undefined가 JavaScript 엔진에 의해 '값이 할당되지 않음'을 나타내기 위한 타입이라면, null은 개발자가 명시적으로 '값이 없음'을 나타내기 위한 타입이다. null 타입은 `null` 값 하나만을 갖는다.\n- **symbol**: ES6에서 추가. 고유하고 변경 불가능한 원시 값을 갖는 타입. 객체의 프로퍼티 키로 사용한다.\n- **bigint**: ES11에서 추가. 임의 정밀도(arbitrary-precision)의 정수 타입. number 타입에서는 오차가 발생하는 큰 수도 안전하게 저장하고 연산할 수 있다. 정수 끝에 n을 붙여 값을 표현한다. (예: `9007199254740992n`)\n\n> 숫자나 문자열을 변경할 수 없다는 데에 조금 의아할 수 있다. 하지만 일반적으로 변수의 값을 변경한다고 하는 것은, 실제로 값 자체를 변경하는 것이 아니라 변수에 새로운 값을 할당하는 것이다.\n>\n> ```javascript\n> let a = 5; // a에 숫자 타입의 값 5를 할당한다\n> a += 10; // a의 값과 10을 + 연산하여 생성한 값을 a에 할당한다\n> \n> let b = 'string'; // b에 문자열 타입의 값 string을 할당한다\n> b[3] = 'o'; // 직접 문자열을 변경하려 해도 불가능하다\n> b = b.slice(0, 3); // b 문자열의 0번째 ~ 3번째 이전까지의 문자로 새로운 문자열을 만들어 b에 할당한다\n> ```\n\n### 객체 타입\n\n원시 타입이 아닌 모든 값은 객체 타입이다. 객체 타입은 원시 타입과 근본적으로 다르다.\n\n- 원시 타입의 값은 변경할 수 없지만(immutable) 객체는 변경 가능(mutable)하다.\n- 원시 값을 변수에 할당하면 변수가 가리키는 메모리 공간에는 실제 값이 저장된다. 하지만 객체를 변수에 할당하면 변수가 가리키는 메모리 공간에는 실제 해당 객체를 저장하고 있는 메모리 주소, 즉 참조 값이 저장된다.\n\n<br />\n\n## 참고 자료\n\n- [Data type - Wikipedia](https://en.wikipedia.org/wiki/Data_type)\n- [JavaScript의 타입과 자료구조 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Data_structures)\n- 이웅모, 『모던 자바스크립트 Deep Dive』\n\n","frontmatter":{"title":"데이터 타입(Data Type)","tags":["JavaScript"]}},{"id":"ae034309-d68d-5381-add3-dbe6c6731590","body":"\n## 요약\n\n문(statement)이란 토큰(token)으로 구성된 프로그램의 최소 실행 단위이다. 선언문, 할당문, 조건문, 반복문 등, 문을 통해 컴퓨터가 어떤 작업을 수행하도록 명령할 수 있다. 문의 집합이 프로그램이며, 문을 작성하고 순서에 맞게 나열하는 작업을 프로그래밍이라 한다.\n\n표현식(expression)이란 값으로 평가될 수 있는 문을 말한다. 즉 변수에 할당할 수 있는 문을 말한다.\n\n<br />\n\n## 문\n\n<b>문(statement)</b>이란 **프로그램을 구성하는 최소 실행 단위**이다. 문의 집합이 프로그램이며, 문을 작성하고 나열하는 과정을 프로그래밍이라 할 수 있다.\n\n### 토큰\n\n문은 다시 <b>토큰(token)</b>이라는 요소로 구성된다. 토큰은 프로그램에서 가장 작은 구성요소로, **문법적으로 더 이상 나눌 수 없는 최소 단위**이다. 토큰에는 다음과 같은 것들이 있다.\n\n- 키워드: `let`, `const`, `await`, `if`...\n- 식별자: 변수, 함수, 클래스, 프로퍼티 등의 이름\n- 연산자: `+`, `-`, `&&`, `===`, `.`, `tyepof`...\n- 리터럴: `42`, `\"hello\"`, `[1, 2, 3]`, `true`...\n\n![token-and-statement](./token-and-statement.png)\n\n### 문의 종류\n\n문은 명령문(command statement)이라고도 한다. 즉 문을 통해 컴퓨터에게 특정한 작업을 수행하도록 명령을 내릴 수 있다.\n\n- 선언문(declaration)\n  - `let foo;`\n  - `function bar() {...}`\n\n- 할당문(assignment)\n  - `foo = 36;`\n\n- 조건문(conditional)\n  - `if (a > b) {...}`\n\n- 반복문(iteration)\n  - `for (let i = 0; i < 10; i++) {...}`\n  - `while (a > 10) {...}`\n- ...\n\n<br />\n\n## 표현식\n\n<b>표현식(expression)</b>이란 **값으로 평가될 수 있는 문**을 말한다. 즉 문의 실행 결과로 어떠한 값을 생성하거나 참조하고, 이를 변수에 할당할 수 있다면 표현식이라고 볼 수 있다.\n\n따라서 어떤 문이 표현식인지 아닌지 확인하는 가장 간단한 방법은 변수에 할당해 보는 것으로, 표현식이 아닌 문을 할당하려 하면 `SyntaxError`가 발생한다.\n\n> <b>평가(evaluate)</b>란 식을 해석해서 값을 생성하거나 참조하는 것을 말한다.\n>\n> - `3 + 5`: 평가의 결과로 값 `8`을 생성한다.\n> - `foo.bar`: 평가의 결과로 `foo` 객체의 `bar` 프로퍼티의 값을 참조한다.\n\n![statement-vs-expression](./statement-vs-expression.png)\n\n또한 표현식은 JavaScript CLI 환경에서 입력했을 때 평가된 값을 출력한다. 표현식이 아닌 문은 `undefined`를 출력한다.\n\n![개발자-도구](.\\개발자-도구.png)\n\n하지만 반환값이 없는 함수의 호출처럼 평가된 값이 `undefined`인 표현식도 있기 때문에, 이것만으로 표현식인지 아닌지를 판별하는 건 확실하지 않다. 값을 출력한다면 표현식이라고 참고만 하자.\n\n<br />\n\n## 참고 자료\n\n- 이웅모, 『모던 자바스크립트 Deep Dive』\n\n- [JavaScript Keywords and Identifiers (programiz.com)](https://www.programiz.com/javascript/keywords-identifiers)\n- [문 및 선언 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements)\n\n","frontmatter":{"title":"표현식(Expression)과 문(Statement)","tags":["JavaScript"]}},{"id":"1351b181-a931-57b6-ac38-20e09f07d983","body":"\n## 논리 연산자\n\n논리 연산자란 조건문에서 흔히 사용하는 `&&`(AND), `||`(OR), `!`(NOT) 등의 연산자를 말한다.\n\n- `A && B`: A가 참이면 B를, 거짓이면 A를 리턴한다.\n- `A || B`: A가 참이면 A를, 거짓이면 B를 리턴한다.\n\n- `!A`: A가 참이면 `false`를, 거짓이면 `true`를 리턴한다.\n\n여기서 말하는 참, 거짓은 `Boolean` 타입으로 형변환을 할 때 `true`로 변환될 수 있는가 아닌가를 말한다. JavaScript에선 다음의 경우는 모두 `false`로 변환되고, 그 이외의 값은 `true`로 변환된다.\n\n- `undefined`, `null`, `NaN`\n- `0`, `-0`, `0n`\n- 빈 문자열 (`\"\"`, `''`, ` `` ` 등)\n\n빈 배열(`[]`)이나 빈 객체(`{}`)는 거짓이 아님을 주의하자.\n\n<br />\n\n## 조건부 표현식\n\n함수를 정의할 때 이런 식으로 간단한 예외 처리를 할 수 있다.\n\n```javascript\nfunction (someObject, value) {\n    // value가 유효한 값이 아닐 때 someObject.value로 대체한다\n    if (!value) {\n        value = someObject.value;\n    }\n    ...\n}\n```\n\n이때 논리 연산자를 활용하면 보다 간결하게 작성할 수 있다.\n\n```javascript\nfunction (someObject, value) {\n    // value가 유효한 값이 아닐 때 someObject.value로 대체한다\n    value = value || someObject.value;\n    ...\n}\n```\n\n비슷하게 리액트의 JSX 표현식에서도 다음과 같이 활용할 수 있다.\n\n```jsx\nconst Profile = ({name, age}) => {\n  return (\n    <div class=\"profile\">\n      <div class=\"name\">{name}</div>\n      <!--age가 유효한 값일 때만 UI상에 표시한다-->\n      {age && <div class=\"age\">{age}</div>}\n    </div>\n  );\n};\n```\n\n또한 어떤 값을 강제로 `Boolean` 값으로 변환하고 싶을 때는 `!`를 두 번 사용하면 된다. 첫번째 `!`에서 해당 값에 반대되는 `Boolean` 값을 받고, 거기에 한 번 더 `!`를 사용해 원래의 `Boolean` 값을 받는 것이다. 값의 유효성 검사를 할 때 유용하게 사용할 수 있다.\n\n```javascript\nconst isValidProfile = (profile) => {\n  // profile, profile.name, profile.age 모두 유효한 값일 때 true, 아니면 false를 리턴한다\n  return !!(\n    profile &&\n    profile.name &&\n    typeof profile.name === 'string' &&\n    profile.age &&\n    typeof profile.age === 'number'\n  );\n};\n```\n\n위 예에서 만약 `!!`가 없다면 `Boolean`이 아닌 값(`undefined`, `null` 등)을 리턴할 가능성이 있다.\n\n<br />\n\n## 참고 자료\n\n- [Logical OR (||) - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_OR)\n- [Logical NOT (!) - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_NOT)\n\n","frontmatter":{"title":"논리 연산자를 이용한 간단한 조건부 표현식","tags":["TIL","JavaScript"]}},{"id":"610d065d-69d8-503b-8c0d-c19d2b07947f","body":"\n## 요약\n\n호이스팅이란 JavaScript의 특징으로, 함수나 변수의 선언을 코드의 최상단으로 끌어올린 것처럼 동작하는 방식을 말한다.\n\n호이스팅은 JavaScript가 함수 단위 스코프를 따르는 언어이기 때문에 발생한다. 한 함수 내에서 함수나 변수는 함수 전체에 걸쳐 정의되기 때문에, 필연적으로 함수 최상단에서 선언된 것과 같은 동작을 한다.\n\n<br />\n\n## JavaScript의 함수 단위 스코프와 호이스팅\n\n과거(ES6 이전) JavaScript의 특징 중 하나는 함수 단위 스코프를 갖는다는 것이었다. 블록 단위 스코프를 갖는 타 언어와 달리 JavaScript는 함수 내의 모든 변수는 함수 전체에 걸쳐 정의된다.\n\n```javascript\nfunction test(num) {\n    if (num > 5) {\n        var i = 10;\n    }\n    \n    console.log(i); // 이 i는 if문 안에서 선언된 i와 같다!\n}\n\ntest(3); // undefined (if문에 진입하지 않았으므로 i는 10으로 초기화되지 않음)\ntest(7); // 10 (i는 if문에 들어가 10으로 초기화됨)\n```\n\n위 예시에서 `Uncaught ReferenceError: i is not defined`라는 에러 메시지가 아닌 `undefined`가 출력되는 것을 확인할 수 있다. 즉 실제 선언부까지 가지 않더라도, 함수에 진입한 시점에서 이미 `i`는 선언된 상태와 같다. 마치 변수의 선언부와 초기화를 따로 떼어내고 선언부를 스코프 맨 위로 <b>끌어올린** 것처럼 동작한다고 해서 이를 **호이스팅(hoisting, 끌어올림)</b>이라고 한다.\n\n```javascript\n// 위 함수는 마치 아래처럼 동작한다.\n// 실제로 코드가 이런 식으로 변환되는 것은 아니고\n// 메모리 상에서 이처럼 동작한다는 뜻!\nfunction test(num) {\n    var i; // i의 선언부\n    if (num > 5) {\n        i = 10; // i 초기화\n    }\n    \n    console.log(i);\n}\n```\n\n[MDN](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)에서는 호이스팅을 아래와 같이 정의하고 있다.\n\n> *JavaScript에서 **호이스팅**(hoisting)이란, 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당하는 것을 의미합니다.*\n\n<br />\n\n## 호이스팅의 특징\n\n### `var`\n\n`var`로 선언한 변수는 호이스팅되어 `undefined`로 초기화된다. 따라서 초기화 전에 사용해도 오류는 발생하지 않는다.\n\n### `let`과 `const`\n\n`let`, `const`로 선언한 변수와 상수는 호이스팅이 되지 않는다고 알려져 있기도 하다. 엄밀히 말하자면 호이스팅은 일어나지만(즉 메모리 상에 공간은 할당되지만) 값이 초기화되지 않는다. 사용하려 하면 **초기화 전에는 접근할 수 없다**라는 에러 메시지를 볼 수 있다.\n\nES6부터 추가된 `let`과 `const`는 블록 단위 스코프를 위한 키워드이므로 일반적인 호이스팅을 따르지 않는다고 볼 수 있다.\n\n### 초기화는 호이스팅되지 않는다\n\n끌어올려지는 것은 선언(Declare) 뿐이고 초기화(Initialize)는 끌어올려지지 않는다. 따라서 `var`로 선언한 변수를 정의한 위치보다 앞에서 사용할 수 있다 해도, 단지 오류만 나지 않을 뿐이지 초기화 전까지는 원하는 동작을 할 수는 없을 것이다.\n\n### 함수 선언은 호이스팅된다\n\n함수 선언은 호이스팅되며 정의된 위치보다 앞에서 자유롭게 사용할 수 있다.\n\n```javascript\nprint_hello(); // hello world!\nfunction print_hello() {\n\tconsole.log('hello world!');\n}\n```\n\n### 함수 표현식은 호이스팅되지 않는다\n\n표현식으로 정의된 함수는 자신이 할당된 변수를 통해 참조된다. 그리고 변수의 초기화는 호이스팅되지 않으므로 함수 표현식 역시 자신이 정의된 위치 이전에는 사용할 수 없다.\n\n<br />\n\n## 호이스팅의 쓰임새\n\n함수 선언의 호이스팅은 함수를 정의한 순서에 상관 없이 사용할 수 있다는 점에서 유용하게 사용할 수 있다.\n\n단 변수의 호이스팅은 잠재적인 버그의 원인이 된다. 예상치 못한 동작을 예방하기 위해 과거에는 함수에서 사용하는 모든 변수를 함수 시작 부분에 선언하는 등의 컨벤션이 존재하기도 했다. 현재는 블록 단위 스코프를 따르는 `let`과 `const`가 있으므로 `var` 키워드 및 변수의 호이스팅은 더 이상 사용되지 않는다.\n\n<br />\n\n## 참고 자료\n\n- [호이스팅 - 용어 사전 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Glossary/Hoisting)\n\n- [JavaScript Hoisting (w3schools.com)](https://www.w3schools.com/js/js_hoisting.asp)\n- [javascript - Is there any benefit from hoisting? - Stack Overflow](https://stackoverflow.com/questions/62806172/is-there-any-benefit-from-hoisting)\n\n- 데이비드 플래너건, 『자바스크립트 완벽 가이드(6판)』","frontmatter":{"title":"호이스팅(Hoisting)","tags":["JavaScript"]}},{"id":"713962e5-1392-5237-be93-595eb71878d9","body":"\n## 요약\n\nJavaScript에서 `this`는 함수가 호출되는 방식에 따라 달라진다.\n\n- 전역 컨텍스트: 전역 객체를 가리킨다.\n- 함수 단순 호출: 엄격 모드라면 `undefined`를, 그렇지 않다면 전역 객체를 가리킨다.\n- 객체 메서드: 해당 객체를 가리킨다.\n- 함수 생성자: 생성될 객체를 가리킨다.\n- 이벤트 핸들러: 이벤트 핸들러가 등록된 엘리먼트를 가리킨다.\n\nES5부터 추가된 `bind`, `call` 등은 호출 위치에 상관 없이 특정 객체를 `this`로 사용할 수 있게 해주고, ES6부터 추가된 화살표 함수는 `this`를 갖지 않는다.\n\n<br />\n\n## this\n\n일반적으로 `this`는 객체지향 언어의 클래스에서 사용되며, 객체 내에서 자기자신을 참조하기 위해 사용된다. 하지만 JavaScript에서는 상황에 따라 가리키는 대상이 달라지며 이런 애매모호함(?)이 JavaScript의 초반 진입장벽 중 하나로 작용하곤 한다.\n\nJavaScript에서 `this`는 호출되는 방식에 따라 `this`가 가리키는 값이 달라진다. 즉 this 바인딩은 함수 호출 시점에 결정된다. `bind`, `call` 등의 메서드를 통해 호출되는 위치에 관계 없이 `this` 값을 고정할 수도 있고, 화살표 함수는 자신의 `this` 값을 갖지 않는다.\n\n### 전역 컨텍스트\n\n전역 컨텍스트에서 `this`는 전역 객체를 가리킨다. 다른 컨텍스트에서 전역 객체를 참조하고 싶을 땐 `globalThis`를 사용하면 된다.\n\n```javascript\nconsole.log(window === this); // true, 웹 브라우저에선 window가 전역 객체임\n```\n\n### 함수 단순 호출\n\n엄격 모드가 아닐 때 `this`는 전역 객체를 가리킨다. 엄격 모드라면 `undefined`를 가리킨다.\n\n```javascript\nfunction notStrict() {\n\treturn this;\n}\n\nfunction strict() {\n\t'use strict';\n\treturn this;\n}\n\nconsole.log(notStrict() === window); // true\nconsole.log(strict() === undefined); // true\n```\n\n### 객체의 메서드에서\n\n어떤 객체의 메서드로서 호출하면 `this`는 그 객체를 가리킨다.\n\n```javascript\nfunction introduce () {\n\tconsole.log(`my name is ${this.name}`);\n}\n\nconst obj = {\n    name: 'hansekim',\n    introduce: introduce,\n}\n\nobj.introduce(); // my name is hansekim\n```\n\n### 함수 생성자에서\n\nJavaScript에서는 함수를 통해 객체 타입을 정의하고 `new ` 키워드와 함께 사용하여 객체를 생성할 수 있다. 이때 함수를 생성자(constructor)라고 한다. 생성자 내에서 `this`는 생성자를 통해 생성될 객체를 가리킨다.\n\n```javascript\n// 생성자 네이밍은 파스칼 케이스를 따른다\nfunction Animal (name, sound) {\n    // 생성자에서 this는 생성될 객체를 가리킨다\n\tthis.name = name;\n    this.sound = sound;\n    this.printSound = function () {\n        console.log(`${this.name}: ${this.sound}!`);\n    }\n}\n\nconst dog = new Animal('dog', 'bark');\ndog.printSound(); // dog: bark!\n```\n\n### 이벤트 핸들러에서\n\n`addEventListener()`를 이용해 엘리먼트에 이벤트 핸들러를 등록하면 `this`는 이벤트 핸들러를 등록한 엘리먼트를 가리킨다. 이벤트 객체 `e`에 대해 `e.currentTarget`과 동일하다.\n\n`this`를 사용하면 화살표 함수의 사용이 제한되거나 다른 this 바인딩 문제가 발생할 수 있으므로 웬만하면 `e.currentTarget`을 사용하는 게 더 좋아 보인다.\n\n```javascript\n// 이벤트 핸들러로서 호출하면 핸들러가 등록된 요소의 텍스트 색상을 빨간색으로 변경함\nfunction toRedText (e) {\n    console.log(e.currentTarget === this); // 항상 true\n    this.style.color = 'red';\n}\n\n// 모든 엘리먼트에 클릭하면 텍스트가 빨간색이 되도록 핸들러를 붙임\ndocument.querySelectorAll('*').forEach((element) => {\n    element.addEventListener('click', toRedText);\n});\n```\n\n### bind, call, apply\n\n`bind`, `call`, `apply`는 ES5부터 추가된 `Function` 타입 객체(즉 함수)의 메서드다. 첫 번째 인자로 새로이 할당할 `this`값을, 나머지 인자로 해당 함수의 초기 인자를 전달한다.\n\n- `bind`: `this` 인자와 함수의 초기 인자들을 받아 원본 함수의 복제를 리턴한다.\n- `call`: `this` 인자와 함수의 초기 인자들을 받아 원본 함수를 호출한다.\n- `apply`: `this` 인자와 함수의 초기 인자 배열을 받아 원본 함수를 호출한다.\n\n이렇게 `bind`, `call`, `apply`로 생성하거나 호출한 함수는 호출 방법에 상관 없이 첫 번째 인자로 전달한 객체를 `this`로 사용한다.\n\n```javascript\nfunction introduce (age) {\n\tconsole.log(`my name is ${this.name}`);\n    if (age) console.log(`i'm ${age} years old`);\n}\n\nconst hanseKim = {name: 'hanseKim'};\nconst john = {name: 'john'};\nintroduce.call(hanseKim); // my name is hanseKim\nintroduce.call(john, 16); // my name is john / i'm 16 years old\n```\n\n### 화살표 함수\n\n화살표 함수는 자신의 `this`를 갖지 않는다. 따라서 위에서 언급한 사례들을 전부 무시하고 상위 스코프의 `this`를 가리킨다.\n\n```javascript\nfunction Counter() {\n    this.num = 0; // 이 this는 생성자의 인스턴스를 가리킨다\n    \n    setInterval(() => {\n        this.num += 1; // 화살표 함수는 this를 갖지 않으므로\n        console.log(this.num); // 상위 스코프의 this를 가리킨다\n    }, 1000);\n}\n\nnew Counter();\n// 1\n// 2\n// 3\n// ...\n```\n\n<br />\n\n## 참고 자료\n\n- [this - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this)\n\n","frontmatter":{"title":"this","tags":["JavaScript"]}},{"id":"21a1531e-2cf5-5494-978b-1cf10f0c4e0e","body":"\n## 요약\n\nIIFE란 정의되자마자 즉시 실행되는 JavaScript 함수를 말한다. 함수 표현식을 감싸는 큰 괄호(그룹 연산자)와, 이 함수를 실행시키는 괄호(호출 연산자)로 구성되어 있다.\n(예: `(function() {...})();`)\n\nIIFE내의 변수는 밖에서 접근이 불가능하기 때문에, 글로벌 스코프를 오염시키지 않고 웹 페이지를 초기화할 수 있어 유용하다. 또 클로저와 함께 활용하면 private한 값을 만들 수도 있다.\n\n<br />\n\n## 즉시 실행 함수 표현식\n\n<b>즉시 실행 함수 표현식(IIFE, Immediately Invoked Function Expression)</b>이란 정의되자마자 즉시 실행되는 JavaScript 함수를 말한다. 다른 말로는 자가 실행 익명 함수(Self-Executing Anonymous Function)라고도 한다.\n\n```javascript\n(function() {\n    console.log('hello, world!');\n})();\n```\n\n<br />\n\n## IIFE를 사용하는 이유\n\n### 전역 스코프 오염을 방지\n\n대표적으로 페이지를 초기화하기 위한 코드는 여러 번 사용할 필요가 없을 뿐더러, 전역 스코프에 함수나 변수를 추가한다면 예기치 않은 버그를 초래할 가능성이 있다. 이러한 경우에 IIFE를 사용하면 전역 스코프를 오염시키지 않고 원하는 기능을 실행할 수 있다.\n\n```javascript\n// appElement, container 등이 전역 스코프에 추가되어 버그를 일으킬 수 있다\nconst appElement = () = React.createElement(App);\nconst container = document.getElementById('App');\nReactDOM.render(appElement, container);\n```\n\n```javascript\n// IIFE를 사용하면 전역 스코프에 변수가 남지 않는다\n(function() {\n    const appElement = () = React.createElement(App);\n    const container = document.getElementById('App');\n    ReactDOM.render(appElement, container);\n})();\n```\n\n### IIFE 내부로의 접근을 막음\n\n표현식 내부의 변수는 외부에서 접근할 수 없다.\n\n```javascript\n(function() {\n\tconst fruit = 'apple';\n})();\n\nconsole.log(fruit); // Error: fruit is not defined\n```\n\n이를 이용해 IIFE와 클로저를 활용해서 private한 값을 갖는 함수를 만들 수도 있다. 예를 들어 auto-increasement id를 구현할 때 다음과 같이 구현할 수 있는데,\n\n```javascript\nlet count = 0;\nconst autoIncreasementId = function() {\n    count += 1;\n\treturn `id_${count}`;\n};\n\nconsole.log(autoIncreasementId()); // id_1\nconsole.log(autoIncreasementId()); // id_2\nconsole.log(autoIncreasementId()); // id_3\n```\n\n이러면 `count` 변수가 전역 스코프에 노출되고 또 변경 가능하기 때문에 다른 함수에서 변경하거나 접근하면 버그의 원인이 될 수 있다. 이를 IIFE로 한번 래핑하여 다음과 같이 사용함으로써 `count`를 private한 값으로 만들 수 있고, 보다 안전하게 사용할 수 있다.\n\n```javascript\nconst autoIncreasementId = (function () {\n  let count = 0;\n  return function () {\n    count += 1;\n    return `id_${count}`;\n  }\n})();\n\nconsole.log(autoIncreasementId()); // id_1\nconsole.log(autoIncreasementId()); // id_2\nconsole.log(autoIncreasementId()); // id_3\n```\n\n### 전역스코프의 변수 사용을 래핑\n\n두 라이브러리에서 동일한 이름의 전역 변수를 사용하는 경우가 발생할 수 있다. 이럴 때 코드를 IIFE로 래핑해서 해당 전역변수를 넘겨주는 방식을 이용해 문제를 해결할 수 있다.\n\n예를 들어 jQuery에서는 전역 변수 `jQuery`의 축약으로 `$`를 사용한다. 기존에 이 `$`를 사용한 코드가 있을 때, 새로 추가한 다른 라이브러리에서 `$`라는 전역변수를 사용한다면 이런 식으로 충돌을 회피할 수 있다.\n\n```javascript\n// 다른 라이브러리\nwindow.$ = function someFunction() { ... }\n\n(function ($) {\n    // jQuery를 사용하는 코드\n    ...\n})(jQuery);\n```\n\n래핑한 함수의 매개변수로 `$`를 정의했고 즉시 실행할 때 `jQuery`를 인수로 넘겨줬다. 그러면 `$`는 함수 스코프의 변수가 되어 전역 스코프의 `$`와는 상관 없이 `jQuery`를 `$`로서 사용할 수 있게 된다.\n\n<br />\n\n## 참고 자료\n\n- [IIFE - 용어 사전 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Glossary/IIFE)\n\n- [12 Simple (Yet Powerful) JavaScript Tips – JavaScript Is Sexy](http://javascriptissexy.com/12-simple-yet-powerful-javascript-tips/)\n\n- [Use Cases for JavaScript's IIFEs — Marius Schulz](https://mariusschulz.com/blog/use-cases-for-javascripts-iifes)\n","frontmatter":{"title":"즉시 실행 함수(IIFE)","tags":["JavaScript"]}},{"id":"9cc79056-73b1-5d32-80e8-2391711ec949","body":"\n## 한 줄의 텍스트\n\n한 줄의 텍스트는 `text-overflow` 프로퍼티를 사용해 말줄임표 처리를 할 수 있다.\n\n```CSS\n.ellipsis-text {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    white-space: nowrap;\n\n    width: 360px;\n    border: 1px solid gray;\n}\n```\n\n```html\n<div class=\"ellipsis-text\">\n    같이, 노래하며 하였으며, 우리 황금시대의 가치를 몸이 있으랴? 그들은 청춘의 물방아 풀이 긴지라 인간이 생생하며, 힘차게 그리하였는가?\n</div>\n```\n\n- 결과\n\n![result1](.\\result1.png)\n\n`text-overflow`는 단지 텍스트가 오버플로(컨텐츠가 상자 밖으로 넘침) 상태일 때 어떻게 처리할지를 지정해주는 프로퍼티라서 혼자 있을 땐 아무런 의미가 없다. 따라서 `overflow`, `white-space` 프로퍼티를 통해 텍스트 오버플로를 발생시켜야 한다.\n\n- `overflow`: 상자 밖으로 나간 컨텐츠를 어떻게 처리할지를 결정한다. `hidden`으로 지정하면 밖으로 튀어나온 컨텐츠를 안 보이게 만든다.\n- `white-space`: 상자 내의 화이트 스페이스(white space)를 어떻게 처리할지를 결정한다. `nowrap`으로 지정하면 공백을 축소(collapse)하고 줄바꿈하지 않게 만든다.\n\n따라서 `overflow: hidden`, `white-space: nowrap`과 함께 `text-overflow: ellipsis`를 적용하면 텍스트는 한 줄이 되고 상자 밖으로 나가면 말줄임표 처리가 된다.\n\n<br />\n\n## 여러 줄의 텍스트\n\n`-webkit-line-clamp` 프로퍼티를 이용해 텍스트 줄 수를 강제할 수 있다. 이 프로퍼티는 `display: -webkit-box`, `-webkit-box-orient: vertical`과 함께 사용할 경우에만 동작한다.\n\n```css\n.ellipsis-text-2-line {\n    text-overflow: ellipsis;\n    overflow: hidden;\n    display: -webkit-box;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n    line-height:1.5em;\n    height: 3em;\n\n    width: 360px;\n    border: 1px solid gray;\n}\n```\n\n```html\n<div class=\"ellipsis-text-2-line\">\n    같이, 노래하며 하였으며, 우리 황금시대의 가치를 몸이 있으랴? 그들은 청춘의 물방아 풀이 긴지라 인간이 생생하며, 힘차게 그리하였는가?\n</div>\n```\n\n- 결과\n\n![result2](.\\result2.png)\n\n`-webkit-line-clamp`와 `-webkit-box-orient`는 비록 많은 브라우저에서 지원한다지만 표준이 아닌 만큼 크로스 브라우징에 주의할 필요가 있다. Stack Overflow의 [이 답변](https://stackoverflow.com/questions/5269713/css-ellipsis-on-second-line#answer-50566101)에서는 `@supports` 규칙을 이용해 호환성을 높이는 방법을 제시하고 있다.\n\n```css\n.text {\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n\n    @supports (-webkit-line-clamp: 2) {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: initial;\n        display: -webkit-box;\n        -webkit-line-clamp: 2;\n        -webkit-box-orient: vertical;\n    }\n}\n```\n\n`-webkit-line-clamp` 프로퍼티를 지원한다면 두 줄로, 그렇지 않다면 한 줄로 처리될 것이다.\n\n이외에 JavaScript를 통해 말줄임표 처리를 하는 방법도 있지만, CSS로 처리할 수 있는 일은 CSS를 쓰는 게 가장 좋다고 생각하기 때문에 위 방법이 제일 낫다고 생각한다.\n\n","frontmatter":{"title":"CSS 텍스트 말줄임표(ellipsis) 처리","tags":["CSS","TIL"]}},{"id":"cf832a7a-ea5f-5e7a-a9c4-06dc4a9517b7","body":"\n## 요약\n\n화살표 함수란 ES6부터 추가된 새로운 형태의 함수 표현식이다. 기존의 `function` 키워드를 이용한 함수 표현식에 비해 간결하고 직관적인 함수 정의가 가능하다.\n\n화살표 함수의 특징은 `this`를 갖지 않는다는 점이다. 기존 함수는 자신이 호출된 위치에 따라 `this`가 가리키는 대상이 달라진다. 반면 화살표 함수는 어디에서 호출되든 항상 자신이 작성된 위치, 즉 렉시컬 컨텍스트의 `this`를 가리킨다.\n\n따라서 객체의 생성자, 메서드로 사용할 수 없고 `.bind()`나 `.call()` 등으로 `this`를 지정해도 무시한다.\n\n<br />\n\n## 화살표 함수\n\n```javascript\n// 전통적인 함수 표현식\nconst add = function(a, b) {\n    return a + b;\n};\n\n// 화살표 함수\nconst add = (a, b) => a + b;\n```\n\n<b>화살표 함수(arrow function)</b>란 ES6에서 추가된 새로운 함수 표현식(expression)이다. `function` 키워드를 통해 함수를 정의하는 것보다 짧고 직관적으로 함수를 정의할 수 있게 해준다.\n\n극단적인 경우로 인자가 하나이고 표현식이 한 줄인 함수의 경우 인자의 괄호를 생략하여 `인자 => 표현식`으로 함수를 나타낼 수도 있다. 중괄호를 생략한 표현식은 `{return 표현식}`과 동일하다.\n\n```javascript\nconst getLength = str => str.length;\n\n// 위와 동일한 함수\nfunction getLength(str) {\n  return str.length;\n}\n```\n\n단 JavaScript에서는 코드 블록을 구분할 때, 객체 리터럴을 사용할 때 모두 중괄호(`{}`)를 사용하므로, 화살표 함수에서 객체 리터럴을 리턴할 때 중괄호와 `return`을 생략하면 표현이 모호해진다.\n\n```javascript\nconst objList = someList.map(() => {}); // Error, {}가 객체인지 코드블럭인지 모호함\n```\n\n따라서 화살표 함수에서 객체 리터럴을 리턴할 때에는 반드시 그룹 연산자로 감싸줘야 한다.\n\n```javascript\nconst objList = someList.map(() => ({})); // OK\n```\n\n<br />\n\n## 화살표 함수의 특징\n\n### `this`를 바인딩하지 않음\n\n화살표 함수는 자신의 `this`를 갖지 않는다. 자신이 작성된 렉시컬 컨텍스트의 `this`를 가리킨다. 이를 통해 중첩된 함수에서의 `this` 스코프 문제를 단순화할 수 있다.\n\n```javascript\nfunction Counter() {\n    this.num = 0; // 이 this는 생성자의 인스턴스를 가리킨다\n    \n    setInterval(function() {\n        this.num += 1; // 무명함수 내에서 새로이 바인딩된 this\n        console.log(this.num); // 따라서 this는 전역객체를 가리킨다\n        // 그리고 this.num은 정의되지 않았으므로\n        // 매번 undefined + 1의 결과인 NaN을 출력한다\n    }, 1000);\n}\n\nnew Counter();\n// NaN\n// NaN\n// NaN\n// ...\n```\n\n```javascript\nfunction Counter() {\n    this.num = 0; // 이 this는 생성자의 인스턴스를 가리킨다\n    \n    setInterval(() => {\n        this.num += 1; // 화살표 함수는 this를 갖지 않으므로\n        console.log(this.num); // 바깥의 가장 가까운 this를 가리킨다\n    }, 1000);\n}\n\nnew Counter();\n// 1\n// 2\n// 3\n// ...\n```\n\n`bind()`, `call()`, `apply()` 등으로 `this`를 지정해주는 것 역시 무시하며, 객체의 메서드로 사용될 경우에도 `this`는 렉시컬 컨텍스트의 `this`를 가리킨다.\n\n```javascript\nconst obj = {\n\ta: 5,\n\tprintA: () => console.log(this.a), // this는 obj가 아닌 전역 스코프의 this, 즉 전역 객체를 가리킨다\n};\n\nobj.printA(); // undefined\na = 10;\nobj.printA(); // 10\n```\n\n또한 화살표 함수는 생성자로 사용할 수 없으며 `new` 키워드와 함께 사용하면 오류가 발생한다.\n\n```javascript\nconst Animal = () => {\n    this.name = 'dog';\n    this.sound = 'bark';\n};\n\nnew Animal(); // Uncaught TypeError: Animal is not a constructor\n```\n\n### 간결함\n\n작성해야 할 코드의 양이 대폭 줄어들기 때문에 보다 생산성이 높고, 형태(`(인수) => 반환값`)가 \"인수를 받아 값을 반환한다\"라는 함수의 본질에 가까워 직관적이다. 특히 함수를 리턴하는 고차 함수에서 더욱 그렇다.\n\n```javascript\nconst createAdd = (num) => (operand) => operand + num;\nconst add2 = createAdd(2);\nconsole.log(add2(6)); // 8\n```\n\n```javascript\n// 위 add 함수를 기존의 함수표현식으로 고치면 아래와 같다\nconst createAdd = function(num) {\n    return function(operand) {\n        return operand + num;\n    }\n}\n```\n\n화살표 함수는 고차 함수가 필수적으로 사용되며 this 바인딩이 필요 없는 함수형 프로그래밍에서 유용하게 쓰일 수 있다.\n\n<br />\n\n## 참고자료\n\n- [화살표 함수 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n- [ES6 In Depth: Arrow functions - Mozilla Hacks - the Web developer blog](https://hacks.mozilla.org/2015/06/es6-in-depth-arrow-functions/)\n\n","frontmatter":{"title":"화살표 함수(Arrow Function)","tags":["JavaScript","ES6"]}},{"id":"42279880-d24d-51d3-924c-78cb1c738cca","body":"\n## 개요\n\n블로그를 단지 글을 쓰는 용도가 아니라, 이전에 정리해둔 정보를 다시 찾아보는 용도로 쓴다면 검색 기능은 필수적이다. 이 글이 올라갈 때는 블로그에 멀쩡히 검색 기능이 붙어 있겠지만 사실 이건 며칠간의 삽질의 결과물이다.\n\n#### 핵심 개념\n\n검색에는 세 가지 요소가 필요하다.\n\n- 속도와 성능을 위해 데이터를 검색에 알맞은 형태로 바꿔놓은 <b>인덱스(index)</b>\n- 인덱스와 검색어를 이용해 검색을 수행하고 매칭된 결과를 리턴하는 <b>검색 엔진(search engine)</b>\n- 사용자로 하여금 검색 기능을 사용할 수 있게 해주는 <b>검색 UI(search UI)</b>\n\n일반적으로 검색 엔진 라이브러리라고 하면 raw data로부터 인덱스를 생성하고, 인덱스와 검색어를 통해 검색을 수행하는 것까지를 전부 담당한다.\n\n[공식 문서](https://www.gatsbyjs.com/docs/how-to/adding-common-features/adding-search/)에 따르면, Gatsby 사이트에 검색 기능을 추가하는 방법으로는 `js-search` 라이브러리나 `gatsby-plugin-local-search`과 같은 플러그인을 이용해 client-side 검색을 추가하는 방법이 있고, 혹은 Algolia나 ElasticSearch와 같은 API 기반의 외부 검색 엔진을 사용하는 방법이 있다.\n\n전자의 경우 모든 검색 처리를 브라우저에서 수행하므로 사이트 규모가 커질수록 방문자가 다운로드해야 할 인덱스의 크기가 커지는 단점이 있다. 반면 검색 엔진 API의 경우 이러한 단점을 해소할 수 있지만 일반적으로 무료 플랜은 호스팅이나 월별 요청 수에 제한이 있고, 온전한 기능을 사용하려면 유료 플랜을 사용해야 한다.\n\n\n\n## 진행과정\n\n자료의 수가 적은 나로서는 검색 엔진 API의 이점이 적어 client-side 검색을 택했다. 그래서 `gatsby-plugin-local-search` 플러그인을 사용하고, `react-use-flexsearch` 라이브러리를 이용해 검색결과를 표시하려 했다.\n\n결론부터 말하자면 플러그인이나 라이브러리를 통한 검색 기능 구현은 잘 되지 않았다. 결국 다소 비효율적인 방법으로나마 직접 client-side 검색 기능을 구현하게 되었다. 아래는 그동안 겪은 이슈를 나열한 것이다.\n\n#### `gatsby-plugin-local-search` 플러그인 이슈\n\n> - `gatsby-plugin-local-search`란 그 이름대로 local search, 즉 client-side 검색 기능을 위한 플러그인이다.\n> - `gatsby-config.js`를 통해 검색에 사용할 쿼리, 필드, 검색 결과로 받을 값 등을 설정할 수 있고, 검색 엔진으로는 FlexSearch와 Lunr 중 하나를 선택해서 사용할 수 있다. 공식 문서에서는 성능이 뛰어난 FlexSearch를 추천하고 있다.\n\n- 이슈라고 하기엔 뭣하지만 FlexSearch의 최신버전은 0.7.21인데 반해 이 플러그인에선 0.6.32버전을 쓴다. 0.6 -> 0.7로 넘어가면서 바뀐 부분이 제법 많으므로 공식문서를 참고할 때 버전을 잘 확인해야 한다.\n\n#### `react-use-flexsearch` 라이브러리 이슈\n\n> - `react-use-flexsearch`란 FlexSearch로 생성한 인덱스와 스토어를 사용해 검색을 수행할 수 있는 hook을 제공하는 라이브러리다.\n> - FlexSearch는 구버전인 0.6.22를 사용한다. 오랫동안 업데이트되지 않은 라이브러리라 비슷한 기능이라면 직접 구현하는 편이 낫지 않을까 싶다.\n\n- 타입 정의가 되어 있지 않다. TypeScript에서 사용하려면 별도의 타입 정의 파일을 추가해줘야 한다.\n\n- 인덱스 생성 시 옵션값을 넘길 방법이 없다. FlexSearch는 인덱스 객체를 생성할 때 옵션을 통해 인코더나 토큰화 함수를 설정할 수 있고, 특히 인코더는 인덱스 추가 뿐만 아니라 검색어에도 적용된다. 하지만 옵션을 받지 않으므로 인덱스 객체는 Built-in 함수를 사용하게 되고, 결국 후술할 문제로 인해 이 라이브러리를 사용하면 원천적으로 한글 검색이 되지 않는다.\n\n  ![react-use-flexsearch-1](.\\react-use-flexsearch-1.png)\n\n- `Index.search(query, searchOptions)`라는, 존재하지 않는 사용법으로 메서드를  사용하고 있다. 공식문서에 명시된 사용법은 `Index.search(string, <limit>, <callback>)`와 `Index.search(<options>)` 뿐이다.\n\n  ![react-use-flexsearch-2](.\\react-use-flexsearch-2.png)\n\n#### FlexSearch 라이브러리 이슈\n\n> - FlexSearch란 텍스트 검색 라이브러리다.\n> - 처음에 인덱스를 생성하고, \\<키, 텍스트\\> 쌍으로 검색 대상이 될 데이터를 넣고, 인덱스에 추가한 데이터에 대해 검색을 수행할 수 있다. 인덱스 생성 시에 문자열 인코딩이나 토큰화 함수를 포함한 다양한 옵션을 줄 수 있다.\n\n- Index Option의 `encode`는 공식문서의 설명과 달리 `string` 타입의 인코더 명(`\"simple\"`, `\"balance\"` 등)을 받으면 오류가 난다.\n\n  ```javascript\n  // flexsearch/src/index.js를 보면 이런 식으로 this.encode를 초기화하고\n  this.encode = options[\"encode\"] || (charset && charset.encode) || default_encoder;\n  \n  // (문자열이면 built-in 함수로 교체하는 일 없이) 바로 이런 식으로 사용한다\n  content = this.encode(content);\n  ```\n\n  따라서 특정한 build-in 인코더를 사용하고 싶다면 옵션 중 `charset`을 `\"latin:(인코더명)\"`과 같은 형태로 지정해야 한다.\n\n- `encode` 옵션을 주지 않았을 경우 built-in 인코더를 사용하는데, 알파벳과 숫자를 제외한 모든 문자를 제거하는 과정이 인코딩 과정에 포함되어 있다. 이 때문에 별도의 함수를 `encode` 옵션에 넣어주지 않으면 한글은 인덱스에 추가되지도 않고 검색도 되지 않는다.\n\n- 공식문서에서 소개하는 중국어, 일본어, 한국어용 인코딩 설정은 다음과 같다.\n\n  ![flexsearch](.\\flexsearch.png)\n\n  하지만 이는 어디까지나 예시일 뿐이고 실제로 이 설정을 넣으면 검색이 제대로 되지 않는다.\n\n  - `.replace(/[\\x00-\\x7F]/g, '')`: ASCII 문자를 제거 -> 영어나 숫자 검색이 불가능해진다.\n  - `.split('')`: 한 글자씩 쪼갬 -> 검색 정확도가 크게 떨어진다. `encode` 함수는 검색어에도 적용이 되기 때문에 한 글자씩 쪼갠 인덱스를 한 글자씩 쪼갠 검색어로 검색을 하게 된다. 예를 들어 \"**포트**\"라고 검색을 하면 \"**포트**\", \"**포**스**트**\", \"**포**인**트**\" 등이 전부 검색된다.\n\n  따라서 적절한 한국어 검색을 위해선 별도의 인코더, 토큰화 함수를 마련해야 한다.\n\n결론적으로 FlexSearch를 사용하기 위해서는 한국어용 `encode`, `tokenize` 옵션이 필수적인데, 아무래도 직접 구현할 만한 게 아니라서 FlexSearch 사용은 포기해야 했다. 영어와 한국어라는 언어의 차이 때문에 발생한 문제인 만큼 대부분의 검색 라이브러리는 동일한 문제를 안고 있을 거라 생각했고, 실제로 `gatsby-plugin-local-search`에서 지원하는 다른 검색엔진 라이브러리인 Lunr도 마찬가지였다.\n\n\n\n#### 검색 기능 직접 구현하기\n\n결국 raw data로부터 직접 검색하는 기능을 구현하기로 했다. 구상한 검색 과정은 다음과 같다.\n\n1. 검색어와 포스트를 인코딩한다. (현재는 `toLowerCase`만)\n2. 모든 포스트에 대해 검색어로 `String.match()`를 수행하고, 매치된 수가 1 이상인 포스트만 결과 리스트(`newResults`)에 저장한다.\n3. 매치된 갯수를 정확도의 척도로 삼고, 결과 리스트를 정확도의 내림차순으로 정렬하여 사용한다.\n\n포스트의 갯수를 n, 포스트 당 평균 글자수를 m이라 하면 한 번 검색할 때마다 O(n * m)의 시간복잡도를 갖는 셈이다. 성능을 조금이라도 개선하기 위해 다음과 같은 최적화 방법을 생각했다.\n\n- 검색어는 기본적으로 길이가 2 이상인 것만 사용한다. 한 글자로는 의미가 잘 전달되지 않고 원하는 결과를 찾기도 힘들기 때문이다.\n- 검색어에 대한 결과값은 세션 스토리지에 캐싱하여 사용한다. 로컬 스토리지가 아니라 세션 스토리지인 이유는, 새로운 포스트가 올라오면 기존의 검색 결과는 의미가 없어지기 때문에 브라우저가 오랫동안 검색 결과를 갖고 있을 필요가 없다고 생각했기 때문이다.\n- 검색 기능을 change 이벤트 핸들러로 사용할 때, 입력 중 검색 기능이 작동하는 것을 방지하기 위해 debounce를 적용한다. throttle이 아닌 이유는 검색은 연속된 이벤트의 도중보다는 연속된 이벤트의 끝이 더 의미가 있기 때문이다.\n- 검색은 비동기적으로 수행하도록 한다.\n\n그래서 완성된 코드는 다음과 같다.\n\n- `src/hooks/useSearch.ts`\n\n  ```typescript\n  import {useEffect, useState} from 'react';\n  import _ from 'lodash';\n  import {\n    escapedRegExp,\n    getProperty,\n    getStorageItem,\n    setStorageItem,\n  } from 'src/utils/common';\n  \n  interface Options {\n    searchFrom: string;\n    refBy: string;\n    limit?: number;\n    cacheKey?: string;\n    debounceWait?: number;\n    minKeywordLength?: number;\n  }\n  \n  const useSearch = <T extends Record<string, any>>(\n    dataList: T[],\n    {\n      searchFrom,\n      refBy,\n      limit = 20,\n      cacheKey = 'search',\n      debounceWait = 300,\n      minKeywordLength = 2,\n    }: Options\n  ) => {\n    const [results, setResults] = useState<T[]>([]);\n    const [store, setStore] = useState<Record<string, T>>({});\n  \n    useEffect(() => {\n      const storageKey = `store_${cacheKey}`;\n      const cachedStore = getStorageItem(storageKey, sessionStorage);\n      if (cachedStore) {\n        setStore(cachedStore);\n        return;\n      }\n  \n      const store: Record<string, T> = {};\n      dataList.forEach((data) => {\n        const refKey = getProperty(refBy.split('.'), data);\n        store[refKey] = data;\n      });\n  \n      setStorageItem(storageKey, store, sessionStorage);\n      setStore(store);\n    }, [dataList, refBy, cacheKey]);\n  \n    const encode = (str: string) => {\n      return str.toLowerCase();\n    };\n  \n    const search = async (query: string) => {\n      query = encode(query);\n      const storageKey = `query_${cacheKey}_${query}`;\n      const cachedResults = getStorageItem<string[]>(storageKey, sessionStorage);\n      if (cachedResults) {\n        setResults(cachedResults.map((result) => store[result]));\n        return;\n      }\n  \n      const hitCount: Record<string, number> = {};\n      let newResults: string[] = [];\n  \n      dataList.forEach((data) => {\n        if (query.length < minKeywordLength) return;\n  \n        const searchString = encode(getProperty(searchFrom, data));\n        const refKey = getProperty(refBy, data);\n        const re = escapedRegExp(query, 'g');\n  \n        if (!hitCount[refKey]) hitCount[refKey] = 0;\n        const hit = searchString.match(re);\n        if (hit) hitCount[refKey] += hit.length;\n  \n        if (hitCount[refKey] > 0) newResults.push(refKey);\n      });\n  \n      newResults = newResults\n        .sort((a, b) => hitCount[b] - hitCount[a])\n        .slice(0, limit);\n      setStorageItem(storageKey, newResults, sessionStorage);\n      setResults(newResults.map((result) => store[result]));\n    };\n  \n    const handleSearchInputChange = _.debounce(\n      (e: React.ChangeEvent<HTMLInputElement>) => search(e.target.value),\n      debounceWait\n    );\n  \n    return {search, results, handleSearchInputChange};\n  };\n  \n  export default useSearch;\n  ```\n\n- `src/utils/common.ts`\n\n  ```typescript\n  ...\n  \n  export const getStorageItem = <T = any>(\n    key: string,\n    storage = localStorage\n  ): T => {\n    return JSON.parse(`${storage.getItem(key)}`);\n  };\n  \n  export const setStorageItem = (\n    key: string,\n    data: any,\n    storage = localStorage\n  ) => {\n    storage.setItem(key, JSON.stringify(data));\n  };\n  \n  export const getProperty = (\n    query: string | string[],\n    obj: any,\n    separator = '.'\n  ): any => {\n    if (typeof query === 'string') query = query.split(separator);\n    const nextKey = query.shift();\n    if (!nextKey || !obj) return obj;\n    return getProperty(query, obj[nextKey]);\n  };\n  \n  export const escapedRegExp = (str: string, flags?: string) => {\n    return new RegExp(_.escapeRegExp(str), flags);\n  };\n  ```\n\n  \n\n\n- `src/views/searchModal/index.tsx`\n\n  ```tsx\n  import React from 'react';\n  import {graphql, useStaticQuery} from 'gatsby';\n  import useSearch from 'src/hooks/useSearch';\n  import {MdxNode} from 'src/types';\n  import {getPostUrl} from 'src/utils/common';\n  \n  export const pageQuery = graphql`\n    {\n      allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n        nodes {\n          slug\n          frontmatter {\n            title\n            tags\n          }\n          rawBody\n        }\n      }\n    }\n  `;\n  \n  const SearchModal = () => {\n    const {\n      allMdx: {nodes},\n    } = useStaticQuery<{allMdx: {nodes: MdxNode[]}}>(pageQuery);\n    const {results, handleSearchInputChange} = useSearch(\n      nodes,\n      'rawBody',\n      'slug',\n      {\n        cacheKey: 'search-modal',\n      }\n    );\n  \n    return (\n      <div\n        style={{\n          width: '500px',\n          position: 'absolute',\n          top: '20%',\n          left: '50%',\n          backgroundColor: 'white',\n          border: '1px solid black',\n        }}\n      >\n        <input onChange={handleSearchInputChange} />\n        <ul>\n          {results.map((result) => (\n            <li key={result.slug}>\n              <a href={getPostUrl(result.slug)}>\n                <div>{result.frontmatter.tags}</div>\n                <h4>{result.frontmatter.title}</h4>\n              </a>\n            </li>\n          ))}\n        </ul>\n      </div>\n    );\n  };\n  \n  export default SearchModal;\n  ```\n\n- 결과\n\n![Search](https://lh3.googleusercontent.com/pw/AM-JKLWjFgS7lvr_INbby6lcBxZWssKwCWPkQoM5P6UK4dEwWgYENiYmA3qeW1vhyms8iceTTiV2phHo1bXezOSmfR4EmFAV877iftbymi_1uDOcPJxeGHt1CoUezTXqjv1iNl2o7f0j3ywrkaO36UVwP1Fw=w480-h356-no?authuser=0)\n\n- 세션 스토리지\n\n![session storage](.\\session-storage.png)\n\n이로써 검색 기능이 구현되었고 세션 스토리지에 검색 데이터도 잘 저장되는 것을 확인할 수 있다.\n\n\n\n## 후기\n\n처음에 플러그인과 라이브러리를 사용하며 '이게 왜 안 되지' 싶은 것들을 하나하나 찾다 보니 생각보다 시간이 많이 걸렸다. 그래도 라이브러리 코드를 뒤져가며 원인을 하나씩 살펴보는 건 나름대로 즐거운 경험이었다. FlexSearch에서 찾은 이슈는 추후에 PR을 넣을 예정인데 받아들여질지 어떨지는 잘 모르겠다.\n\n여하튼 이것으로 블로그로서 갖추어야 할 기본적인 기능들은 모두 갖춘 셈이다. 나머지 필요한 기능들은 디자인 적용 후에 하나씩 추가해나갈 예정이다.\n\n","frontmatter":{"title":"Gatsby 블로그 제작 - 검색 기능 구현","tags":["Gatsby","GraphQL"]}},{"id":"119c1b1b-51ec-5bf6-8175-4e03ff273a43","body":"\n\n## 디자인 제작\n\n디자인 툴은 **Figma**를 사용했다. Figma에는 오토 레이아웃(Auto Layout)이라는 강력한 기능이 있어 CSS의 flex box 개념에 익숙하다면 비슷한 느낌으로 작업할 수 있다!\n\n### 디자인 과정\n\n- 전체적으로 slit gray 계열의 grayscale을 사용했고, 포인트 색상으로 파란색을 선택했다.\n- 컨셉은 Notion과 brunch를 참고했다. 둘 다 무언가 작성하고 읽기 위한 서비스인 만큼 읽기 좋은, 쓰기 좋은 UI/UX를 갖추고 있다고 생각했기 때문이다.\n- '중요한 내용 = 볼드체'라는 고정관념이 있었는데 heading에 얇은 두께를 쓰는 것도 깔끔하고 괜찮아 보인다.\n- 기본 텍스트도 font weight를 Regular(400)이 아닌 Light(300)로 잡고, 가장 두꺼운 두께를 Regular로 사용했다.\n\n![figma1](.\\figma1.png)\n\n![figma2](.\\figma2.png)\n\n![figma3](.\\figma3.png)\n\n<br />\n\n\n\n## 디자인 적용\n\n스타일링에는 css-in-js 라이브러리인 Emotion을 사용했다.\n\n작업에 앞서 `vscode-styled-components`라는 VSCode 플러그인을 설치했다. 아래와 같이 CSS template literal에 하이라이트와 자동완성 기능을 추가하는 플러그인이다. 전에 이런 기능을 원해서 Emotion으로 검색했을 때는 못 찾았었는데, 알고 보니 stylesd-components 라이브러리 용으로 이미 있었다. 문법이 유사하기 때문에 Emotion에서도 문제 없이 사용할 수 있다.\n\n![js-styled-component](.\\js-styled-component.png)\n\n### 글로벌 스타일 작성\n\n우선 CSS Reset 스타일을 작성했다. CSS Reset은 주로 브라우저 간의 기본 스타일 차이를 없애기 위해, 그리고 일반적으로 필요 없다고 여겨지는 스타일들(`body`의 `margin` 등)을 미리 제거하고 시작해서 반복 작업을 줄이기 위해 사용한다. 나는 [Minimal CSS Reset](https://www.digitalocean.com/community/tutorials/css-minimal-css-reset)과 [Normalize.css](http://necolas.github.io/normalize.css/)에서 필요한 부분을 가져오고 수정해서 사용하고 있다.\n\n- src/styles/cssReset.ts\n\n```typescript\nimport {css} from '@emotion/react';\n\nexport const cssReset = css`\n  html {\n    box-sizing: border-box;\n    font-size: 16px;\n    font-weight: 400;\n    line-height: 1.15;\n    -webkit-text-size-adjust: 100%;\n  }\n\n  *,\n  :after,\n  :before {\n    box-sizing: inherit;\n  }\n\n  body,\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6,\n  ol,\n  p,\n  ul {\n    margin: 0;\n    padding: 0;\n    font-weight: inherit;\n  }\n\n  main {\n    display: block;\n  }\n\n  ol,\n  ul {\n    list-style: none;\n  }\n\n  img {\n    border-style: none;\n    max-width: 100%;\n    height: auto;\n    object-fit: cover;\n  }\n\n  hr {\n    box-sizing: content-box;\n    height: 0;\n    overflow: visible;\n  }\n\n  a {\n    background-color: transparent;\n    color: inherit;\n    outline: 0;\n  }\n\n  a,\n  a:active,\n  a:hover {\n    text-decoration: none;\n  }\n\n  button,\n  input,\n  optgroup,\n  select,\n  textarea {\n    font-family: inherit;\n    font-size: inherit;\n    line-height: inherit;\n    margin: 0;\n  }\n`;\n```\n\n다음으로 스타일 변수를 작성했는데 이 부분은 어떻게 해야 할지 조금 고민이 되었다. 다크 모드까지 만드는 걸 고려하면 방법은 두 가지가 있다.\n\n- Emotion theme를 사용하기\n- CSS 변수와 attribute selector를 사용하기\n\n개인적으로 이런 간단한 프로젝트에선 Emotion theme는 작성할 코드량은 늘어나는데 비해 이점은 딱히 없다고 생각해서 두 번째 방법을 택했다. 나중에 찾아보니 css-in-js에서 제공하는 theme 기능보다는 CSS 변수 사용을 권장하는 글이 꽤 보였다. 하긴 같은 동작을 할 때 CSS 네이티브 기능과 JavaScript 사용을 비교하면 일반적으로 전자의 성능이 좋으니 그럴 만도 하다.\n\n- `src/styles/variables.ts`\n\n```typescript\nimport {css} from '@emotion/react';\n\nconst variables = css`\n  :root {\n    --color-main: #0076da;\n    --color-text: #1a1e21;\n    --color-text-footer: #3f4950;\n    --color-bg: #ffffff;\n    --color-bg-footer: #f4f5f6;\n    --color-border: #e6e8ea;\n\n    --font-weight-light: 300;\n    --font-weight-demi-light: 350;\n    --font-weight-regular: 400;\n\n    --font-size-default: 16px;\n    --font-size-h4: 18px;\n    --font-size-h3: 20px;\n    --font-size-h2: 24px;\n    --font-size-h1: 28px;\n    --font-size-sub-title: 28px;\n    --font-size-title: 36px;\n  }\n\n  [data-theme='dark'] {\n    --color-main: #2c93ea;\n    --color-text: #eff3f6;\n    --color-text-footer: #c6d3dc;\n    --color-bg: #1a1e21;\n    --color-bg-footer: #202d3a;\n    --color-border: #2d3a47;\n  }\n\n  @media (max-device-width: 767px) {\n    html {\n      font-size: 14px;\n    }\n\n    :root {\n      --font-size-default: 14px;\n      --font-size-h4: 16px;\n      --font-size-h3: 17.5px;\n      --font-size-h2: 19px;\n      --font-size-h1: 20.5px;\n      --font-size-sub-title: 21px;\n      --font-size-title: 24.5px;\n    }\n  }\n`;\n\nexport default variables;\n```\n\n마지막으로 위 둘을 합쳐 global styles로 만들고 `Layout` 컴포넌트에 추가했다.\n\n- `src/styles/global.ts`\n\n```typescript\nimport {css} from '@emotion/react';\nimport {cssReset} from './cssReset';\nimport variables from './variables';\n\nconst globalStyles = css`\n    ${cssReset};\n    ${variables};\n  `;\n\nexport default globalStyles;\n```\n\n- `src/components/layout/index.tsx`\n\n```tsx\nimport React from 'react';\nimport {graphql, useStaticQuery} from 'gatsby';\nimport {SiteNode} from 'src/types';\nimport Header from './header';\nimport {Global} from '@emotion/react';\nimport globalStyles from 'src/styles/global';\n\n...\n\nconst Layout = ({title, children}: Props) => {\n  const data = useStaticQuery<{site: SiteNode}>(query);\n  return (\n    <div>\n      <title>{title || data.site.siteMetadata.title}</title>\n      <Global styles={globalStyles} />\n      <Header />\n      <main>{children}</main>\n    </div>\n  );\n};\n\nexport default Layout;\n```\n\n이제 스타일 적용을 위한 기본적인 준비가 끝났다.\n\n### 컴포넌트 제작\n\n컴포넌트는 크게 두 가지로 분류했다.\n\n- component: 여러 view에서 사용되는 재사용 가능한 요소들.\n- view: component의 조합으로 만들어지는 화면의 UI 요소. 단독으로 의미를 갖는 최소 요소. page는 이 view만을 사용하여 구성한다.\n\n![component vs view](.\\component-vs-view.png)\n\n<em class=\"caption\">나중에 변경이 있긴 했지만 일반적으로 이런 관점으로 개발을 진행했다</em>\n\n그리고 코드의 일관성을 위해 미리 규칙을 정했다.\n\n- 하나의 component는 `src/components/[컴포넌트명]` 꼴의 디렉터리 안에 작성한다.\n  - Emotion styled 컴포넌트만을 사용하여 하나의 파일로 작성 가능한 경우 `index.ts`만 작성한다.\n  - 마크업 구조가 필요한 경우 Emotion styled 컴포넌트를 담은 `styled.ts` 파일과 마크업 구조를 담은 `index.tsx` 파일을 작성한다. 외부에서는 이 `index.tsx` 파일에서 `export`한 컴포넌트만 `import {} from 'src/components/[컴포넌트명]'` 꼴로 `import`하여 사용한다.\n- 하나의 view는 `src/views/[컴포넌트명]` 꼴의 디렉터리 안에 작성한다.\n  - 기본적으로 component와 동일한 규칙을 따른다.\n  - 하나의 view에만 사용하는 component의 경우 해당 view 디렉터리 안에 작성한다.\n\n그리고 이건 개발 중간에 추가한 규칙이다.\n\n- `export default`를 사용하지 않는다. (단 page, template 컴포넌트는 제외)\n\n이는 [Google TypeScript Style Guide](https://google.github.io/styleguide/tsguide.html)에서 확인한 규칙인데, 본문에선 이렇게 설명하고 있다.\n\n> 기본 내보내기(default exports)를 사용하지 마십시오. 이는 모든 가져오기(imports)가 균일한 패턴을 갖는 것을 보장합니다.\n>\n> 기본 내보내기는 표준적인 이름을 제공하지 않습니다. 따라서 잠재적인 가독성 감소를 포함해서, 개발자에게 이점이 거의 없고 유지보수를 어렵게 합니다.\n>\n> ```\n> import Foo from './bar';  // 허용됨\n> import Bar from './bar';  // 마찬가지로 허용됨\n> ```\n\n한 마디로 `export default`로 내보낸 모듈은 어떤 이름으로든 `import`가 가능하고, 이것이 잠재적으로 혼란을 야기할 수 있다는 것이다. 타당한 의견이고 또 `export default`를 사용하지 않는다고 문제될 만한 일도 없다고 생각해서 이를 적극 수용했다.\n\n단 프레임워크 명세상 page 컴포넌트와 template 컴포넌트는 `export default`로 내보내야 하므로 이들은 제외했다.\n\n### 마크다운 스타일 적용\n\n`@mdx-js/react`의 `MDXProvider`를 통해 마크다운에 스타일을 적용할 수 있다. TypeScript라면 우선 타입 정의 패키지를 설치해야 한다. \n\n```shell\n$ npm install --save-dev @types/mdx-js__react\n```\n\n그러면 이제 `MDXProvider`로 마크다운 렌더링에 사용할 컴포넌트를 커스터마이징 할 수 있다. 커스터마이징 가능한 컴포넌트와 그 방법은 [gatsby-plugin-mdx](https://www.gatsbyjs.com/plugins/gatsby-plugin-mdx/?=remark#mdxprovider)에서 확인할 수 있다.\n\n- `src/views/postLayout/index.tsx`\n\n```tsx\nimport React from 'react';\nimport {MDXProvider} from '@mdx-js/react';\nimport {MDXRenderer} from 'gatsby-plugin-mdx';\nimport {MdxNode} from 'src/types';\nimport {PostHeader} from './postHeader';\nimport {PostContentWrapper, PostLayoutWrapper} from './styled';\nimport {\n  Heading1,\n  Heading2,\n  Heading3,\n  Heading4,\n  OrderedList,\n  UnorderedList,\n  Paragraph,\n  Strong,\n  Anchor,\n  Blockquote,\n  ListItem,\n  Code,\n} from 'src/components/markdown';\n\ninterface Props {\n  backUrl?: string;\n  post: MdxNode;\n}\n\nconst components = {\n  p: Paragraph,\n  h1: Heading1,\n  h2: Heading2,\n  h3: Heading3,\n  h4: Heading4,\n  ul: UnorderedList,\n  ol: OrderedList,\n  li: ListItem,\n  strong: Strong,\n  a: Anchor,\n  inlineCode: Code,\n  blockquote: Blockquote,\n};\n\nexport const PostLayout = ({post, backUrl}: Props) => {\n  return (\n    <PostLayoutWrapper>\n      <PostHeader backUrl={backUrl || '/blog'} {...post.frontmatter} />\n      <PostContentWrapper>\n        <MDXProvider components={components}>\n          <MDXRenderer>{post.body}</MDXRenderer>\n        </MDXProvider>\n      </PostContentWrapper>\n    </PostLayoutWrapper>\n  );\n};\n```\n\n- 마크다운 원문\n\n```markdown\n# 큰 제목 1\n\n### 작은 제목 1\n\n같이, 찬미를 못하다 싸인 우리 유소년에게서 희망의 끓는다. 장식하는 인도하겠다는 피고 철환하였는가? 인간이 그들의 사랑의 봄바람을 과실이 무엇이 약동하다.\n\n청춘이 따뜻한 스며들어 시들어 군영과 새가 사막이다. 그들의 돋고, 대중을 할지니, 앞이 구하기 이상의 아름다우냐? 투명하되 곳으로 같이, 위하여 그들의 인간의 공자는 그들은 이것이다.\n\n1. 천자만홍이 바로 석가는 풀이 크고 낙원을 하는 원대하고, 방황하여도, 것이다. \n\n2. 들어 우리의 타오르고 우리는 피가 것이다.\n\n3. 트고, 그들의 타오르고 평화스러운 힘차게 뿐이다. 우리는 설산에서 그들은 피어나기 것이 남는 있는 따뜻한 피다.\n\n### 작은 제목 2\n\n- 나의 그러나 무성할 당신은 나의 라이너 계십니다. 동경과 무덤 한 언덕 나는 않은 거외다.\n- 나의 이제 위에 불러 써 있습니다. 나는 마리아 된 아무 너무나 하나 시인의 사랑과 소녀들의 까닭입니다.\n\n  - 릴케 밤이 이름자 이웃 사랑과 않은 봅니다.\n  - 불러 때 걱정도 하나에 나의 하나 이국 있습니다.\n\n### 작은 제목 3\n\n> 할지라도 바로 그것을 같은 있는 할지니, 뿐이다. 든 우리의 피부가 들어 품에 얼음 있는 것이다. 이성은 것이 못할 장식하는 인도하겠다는 발휘하기 석가는 것이다.\n\n찬미를 길을 얼마나 생생하며, 곳이 그들은 만천하의 하였으며, 찾아 황금시대다. 피가 이상 보배를 봄바람이다. 광야에서 새 꽃이 청춘에서만 든 것이다.보라, 것이 운다.\n```\n\n- 결과\n\n![마크다운 커스터마이징](.\\마크다운-커스터마이징.png)\n\n추가적으로 마크다운을 위한 라이브러리를 찾아서 적용했다. `.md` 파일을 위한 `gatsby-transformer-remark` 관련 플러그인들이 `.mdx`와도 호환되므로 그대로 사용할 수 있다. 나는 `gatsby-remark-images`와 `gatsby-remark-prismjs`를 추가했다.\n\n```shell\n$ npm install gatsby-remark-images gatsby-plugin-sharp\n$ npm install gatsby-remark-prismjs prismjs\n```\n\n> - `gatsby-remark-images`: 마크다운에서 상대경로로 이미지를 사용하기 위한 플러그인.\n> - `gatsby-plugin-sharp`: 이미지 처리를 위한 low-level 플러그인. 주로 다른 이미지 관련 Gatsby 플러그인에서 요구됨.\n> - `gatsby-remark-prismjs`: Gatsby에서 마크다운 렌더링 시 코드블럭에 PrismJS의 코드 하이라이팅을 사용하기 위한 플러그인.\n> - `prismjs`: 코드 하이라이팅 라이브러리.\n\n- `gatsby-config.js`\n\n```javascript\nmodule.exports = {\n  ...\n  plugins: [\n    ...\n    'gatsby-plugin-sharp',\n    {\n      resolve: `gatsby-plugin-mdx`,\n      options: {\n        extensions: [`.mdx`, `.md`],\n        gatsbyRemarkPlugins: [\n          {\n            resolve: `gatsby-remark-images`,\n            options: {\n              maxWidth: 720,\n            },\n          },\n          {\n            resolve: `gatsby-remark-prismjs`,\n            options: {\n              classPrefix: 'language-',\n              showLineNumbers: true,\n              noInlineHighlight: true,\n            },\n          },\n        ],\n      },\n    },\n  ],\n};\n```\n\n> `gatsby-remark-prismjs`의 옵션 중 줄 번호를 표시하도록 바꾸었고, 인라인 하이라이트는 위에서 적용한 게 있으므로 사용하지 않도록 했다.\n\n`gatsby-remark-images`는 설치 및 `gatsby-config.js` 설정 후 바로 적용된다. `gatsby-remark-prismjs`는 추가적으로 스타일을 불러와야 하는데 [gatsby-remark-prismjs](https://www.gatsbyjs.com/plugins/gatsby-remark-prismjs/?=prism)에서는 `gatsby-browser.js`에 PrismJS 테마 중 하나를 `require`로 가져오게끔 적혀 있다.\n\n나는 Emotion을 쓰고 있으므로 기존의 global styles에 테마 CSS 내용을 추가하는 방식을 택했다. 가져온 CSS는 `prismjs/themes/prism-solarizedlight.css`와 `prismjs/plugins/line-numbers/prism-line-numbers.css`이다.\n\n- `src/styles/prismTheme.ts`\n\n```typescript\nimport {css} from '@emotion/react';\n\n...\n\nexport const prismTheme = css`\n... (두 CSS 파일의 내용을 카피한 후 입맛에 맞게 수정했다)\n`;\n```\n\n- `src/styles/global.ts`\n\n```typescript\nimport {css} from '@emotion/react';\nimport {cssReset} from './cssReset';\nimport {variables} from './variables';\nimport {prismTheme} from './prismTheme';\n\nexport const globalStyles = css`\n  ...\n  ${cssReset};\n  ${variables};\n  ${prismTheme};\n  ...\n`;\n```\n\n- 마크다운 원문\n\n````markdown\n### 작은 제목 2\n\n```typescript\nconst main = () => {\n  console.log('hello world!');\n}\n\nmain();\n```\n\n```html\n<!DOCTYPE html>\n<html lang=\"ko\">\n  <head></head>\n  <body>\n    <h1>Hello world</h1>\n  </body>\n</html>\n```\n````\n\n- 결과\n\n![코드블록 하이라이팅](.\\코드블록-하이라이팅.png)\n\n이로써 포스트 페이지의 마크다운 스타일링도 마쳤다.\n\n### 검색 모달 구현\n\n검색 기능은 모달로 구현하기로 했다. 우선 모달의 열림/닫힘 상태 관리를 위해 ContextAPI를 사용했다.\n\n- `src/contexts/modalContext.tsx`\n\n```tsx\nimport React, {useContext, useState} from 'react';\n\ninterface ContextState {\n  isOpenModal: (modal: string) => boolean;\n  onOpenModal: (modal: string) => () => void;\n  onCloseModal: (modal: string) => () => void;\n}\n\ninterface ProviderProps {\n  children?: React.ReactNode;\n}\n\nconst ModalContext = React.createContext<ContextState | null>(null);\n\nexport const ModalContextProvider = ({children}: ProviderProps) => {\n  const [modalOpenMap, setOpen] = useState<Record<string, boolean>>({});\n\n  const isOpenModal = (modal: string) => modalOpenMap[modal];\n\n  const onOpenModal = (modal: string) => () => {\n    setOpen((modalOpenMap) => ({...modalOpenMap, [modal]: true}));\n  };\n\n  const onCloseModal = (modal: string) => () => {\n    setOpen((modalOpenMap) => ({...modalOpenMap, [modal]: false}));\n  };\n\n  return (\n    <ModalContext.Provider value={{isOpenModal, onOpenModal, onCloseModal}}>\n      {children}\n    </ModalContext.Provider>\n  );\n};\n\nexport const useModal = (modal: string) => {\n  const state = useContext(ModalContext);\n  if (state === null) throw new Error('Cannot find modal context provider.');\n\n  const {isOpenModal, onOpenModal, onCloseModal} = state;\n\n  return {\n    isOpen: isOpenModal(modal),\n    onOpen: onOpenModal(modal),\n    onClose: onCloseModal(modal),\n  };\n};\n```\n\n> `ModalContext`는 파일 내에 숨기고 `ModalContextProvider`와 `useModal`만을 `export`로 노출시켰다.\n>\n> `ModalContextProvider`는 `ModalContext.Provider`를 래핑하는 컴포넌트로 모달의 여닫힘 상태를 갖는다. 그리고 문자열을 받는 고차 함수를 `ModalContext.Provider`의 `value`로 보낸다.\n>\n> `useModal`은 `useContext`를 한번 래핑하여 사용하기 편하게 만든 훅이다. `useModal(모달이름)` 꼴로 호출하면 해당 모달의 여닫힘 상태를 확인하거나 조작할 수 있다.\n\n현재로서는 모달이 검색 모달 하나 뿐이지만 추후 다른 모달을 추가할 것을 대비해 상태를 단순 `boolean`이 아닌 `Record<string, boolean>`으로 두고, 키값을 통해 각 모달의 상태를 구분하여 관리할 수 있도록 만들었다.\n\n이후 요전에 만든 검색 기능을 이용해 검색 모달을 구현했다.\n\n- `src/views/searchModal/index.tsx`\n\n```tsx\nimport React, {useCallback, useEffect, useRef, useState} from 'react';\nimport {graphql, useStaticQuery} from 'gatsby';\nimport {useSearch} from 'src/hooks/useSearch';\nimport {MdxNode} from 'src/types';\nimport {Overlay} from 'src/components/overlay';\nimport {useModal} from 'src/contexts/modalContext';\nimport {\n  SearchModalInput,\n  SearchModalInputWrapper,\n  SearchModalBox,\n  SearchResultContainer,\n} from './styled';\nimport {CrossIcon, IconButton, SearchIcon} from 'src/components/icon';\nimport {SearchResultItem} from './searchResultItem';\n\nconst query = graphql`\n  {\n    allMdx(sort: {fields: frontmatter___date, order: DESC}) {\n      nodes {\n        slug\n        frontmatter {\n          title\n          tags\n        }\n        rawBody\n      }\n    }\n  }\n`;\n\nexport const SearchModal = () => {\n  const {isOpen, onClose} = useModal('search');\n  const {results, handleSearchInputChange} = usePostSearch(isOpen);\n  const {inputRef, onInputResetClick} = useInputReset();\n  useAutoFocus(isOpen, inputRef);\n\n  if (!isOpen) return null;\n\n  return (\n    <Overlay onClick={onClose}>\n      <SearchModalBox onClick={(e) => e.stopPropagation()}>\n        <SearchModalInputWrapper>\n          <SearchIcon />\n          <SearchModalInput ref={inputRef} onChange={handleSearchInputChange} />\n          <IconButton iconElement={<CrossIcon />} onClick={onInputResetClick} />\n        </SearchModalInputWrapper>\n        {results.length > 0 && (\n          <SearchResultContainer>\n            {results.map((result) => (\n              <SearchResultItem searchResult={result} key={result.slug} />\n            ))}\n          </SearchResultContainer>\n        )}\n      </SearchModalBox>\n    </Overlay>\n  );\n};\n\nconst usePostSearch = (isOpen: boolean) => {\n  const {allMdx} = useStaticQuery<{allMdx: {nodes: MdxNode[]}}>(query);\n  const {results, resetResults, handleSearchInputChange} = useSearch(\n    allMdx.nodes,\n    'rawBody',\n    'slug',\n    {\n      cacheKey: 'search-modal',\n    }\n  );\n\n  useEffect(() => {\n    if (!isOpen) resetResults();\n  }, [isOpen, resetResults]);\n\n  return {results, handleSearchInputChange};\n};\n\nconst useInputReset = () => {\n  const inputRef = useRef<HTMLInputElement>(null);\n  const onInputResetClick = () => {\n    if (inputRef.current) inputRef.current.value = '';\n  };\n\n  return {inputRef, onInputResetClick};\n};\n\nconst useAutoFocus = (\n  isOpen: boolean,\n  inputRef: React.RefObject<HTMLInputElement>\n) => {\n  useEffect(() => {\n    if (isOpen && inputRef.current) {\n      inputRef.current.focus();\n    }\n  }, [isOpen, inputRef.current]);\n};\n```\n\n구현 중에 깨달은 문제는 이미 검색 input에서 검색을 위한 debounce 핸들러를 `onChange` 이벤트에 사용 중이라 입력값을 직접 제어하지 못한다는 점이었다. ([참고 - 제어 컴포넌트](https://ko.reactjs.org/docs/forms.html#controlled-components)) 그래서 일단은 `useRef`를 이용해 `current.value` 값을 변경하는 다소 지저분한 방법을 사용했는데, 이 부분은 추후에 다시 손봐야 할 것 같다.\n\n<br />\n\n## 후기\n\n디자인까지 적용하니 꽤 그럴 듯하게 보인다.\n\n앞으로는 공부한 내용을 정리하면서 더 필요한 기능을 차차 추가해나갈 예정이다. 당초 추가할 예정이었던 요소들은 다음과 같다.\n\n- 댓글 기능\n- Google Analytics\n\n그리고 새로이 추가해야겠다고 생각한 요소는 다음과 같다.\n\n- 포스트 이전글, 다음글 링크\n- 간단한 포트폴리오를 겸한 소개 페이지\n\n","frontmatter":{"title":"Gatsby 블로그 제작 - 디자인 및 컴포넌트 제작","tags":["Figma","React","Emotion"]}},{"id":"dc554c02-2a07-5111-b247-10fb262db2c0","body":"\n\n\n## 요약\n\n시맨틱 마크업이란 웹 페이지나 웹 어플리케이션의 정보를 효과적으로 전달하는 마크업을 의미한다.\n\n각각의 시맨틱 태그들을 올바른 위치에, 올바른 컨텐츠와 함께 사용함으로써 시맨틱 마크업을 작성할 수 있다.\n\n시맨틱 마크업을 작성해야 하는(시맨틱 태그를 사용해야 하는) 이유는 다음과 같다.\n\n- 사람이 이해하기 쉽다. 페이지 구조를 쉽게 파악할 수 있으므로 가독성과 유지보수성이 향상된다.\n- 기계가 이해하기 쉽다. 올바르게 제목, 구획, 목록 등을 구분하면 스크린 리더나 검색 엔진이 페이지 탐색 및 중요한 키워드를 쉽게 찾을 수 있다.\n\n<br />\n\n## 마크업\n\n마크업이란 태그를 사용하여 컨텐츠를 구분하고 구조화한 문서를 말한다. 이러한 태그나 구조는 <b>마크업 언어(Markup Language)</b>에 의해 결정된다.\n\n마크업 언어에는 현재 웹 페이지의 구조를 나타내는 표준인 **HTML**(**H**yper**T**ext **M**arkup **L**anguage), JSON 이전에 주로 데이터를 표현하기 위해 사용했던 **XML**(e**X**tensible **M**arkup **L**anguage) 등이 있다.\n\n<br />\n\n## 그런데 시맨틱을 곁들인\n\n> semantic\n>\n> (형용사) 의미의, 의미론적인\n\n그렇다면 시맨틱 마크업이란 뭘까?\n\n우선 여기서 말하는 마크업은 HTML만을 가리킨다. 그래서 시맨틱 마크업은 다른 말로 시맨틱 HTML이라 불리기도 한다.\n\n시맨틱, 즉 의미론적이라는 말은 **겉보기를 통해 그 의미를 파악할 수 있다**는 것이다. 바꿔 말하자면 자신이 내포한 의미를 잘 전달함을 뜻한다. 예를 들어 JavaScript에서, \"id를 받아 엘리먼트를 리턴하는 함수\"의 이름을 지을 때 `get(id)`보다 `getElementById(id)`가 더 시맨틱하다.\n\n따라서 시맨틱 마크업은 단순히 문서의 구조를 나타내는 것 뿐만 아니라, 웹 페이지나 웹 애플리케이션에 있는 정보의 의미를 효과적으로 전달하는 마크업이라고 말할 수 있다.\n\n시맨틱 마크업은 <b>시맨틱 태그(semantic tag)</b>를 올바르게 사용함으로써 작성할 수 있다. 필요한 위치에 적절한 태그를 사용하고, 태그 안에는 그 태그에 맞는 적절한 내용이 들어가야 한다.\n\n<br />\n\n## 시맨틱 태그\n\n그렇다면 시맨틱 태그란 자신의 정보를 잘 표현하는 태그를 말할 것이다. 어떤 태그가 시맨틱 태그일까?\n\n`<div>`나 `<span>`은 흔히 시맨틱하지 않은(non-semantic) 태그로 분류된다. 단지 컨텐츠를 블럭 단위로 구분하기 위해, 인라인 컨텐츠를 꾸미기 위해 일반적이고 광범위한 용도로 사용하는 태그이기 때문이다. 반면 `<h1>`은 \"이 페이지에서 가장 상위 수준의 제목\"을, `<table>`은 \"행과 열로 이루어진 표\"를 의미하므로 시맨틱 태그라 할 수 있다.\n\n과거에는 이러한 시맨틱 태그가 많이 부족했다. 그래서 개발자들은 디자인 레이아웃을 적용하기 위해 `<div class=\"header\">`와 같이 시맨틱하지 않은 태그에 `class`나 `id`를 통해 역할을 부여하거나, 심지어는 `<table>` 태그를 이용해 레이아웃을 배치하기도 했다. (현재에도 종종 이런 방식을 볼 수 있다)\n\n그러나 HTML5가 등장하면서부터 레이아웃 영역을 의미하거나 추가적인 기능을 제공하는 시맨틱 태그들이 대거 등장했다.\n\n- `<header>`, `<main>`, `<footer>`\n- `<nav>`, `<section>`, `<article>`, `<aside>`\n- `<details>`, `<summary>`\n- `<figure>`, `<figurecaption>`\n- ...\n\n<br />\n\n## 왜 시맨틱 태그를 사용해야 할까?\n\n```html\n<div class=\"header\"></div>\n<div class=\"main\">\n    <div class=\"article\">\n        <div class=\"heading\">\n            Title\n        </div>\n        <div class=\"section\">\n            <div class=\"subheading\">\n                Topic 1\n            </div>\n        </div>\n        <div class=\"section\">\n            <div class=\"subheading\">\n                Topic 2\n            </div>\n        </div>\n    </div>\n</div>\n<div class=\"footer\"></div>\n```\n\n```html\n<header></header>\n<main>\n    <article>\n        <h1>Title</h1>\n        <section>\n            <h2>Topic 1</h2>\n        </section>\n        <section>\n            <h2>Topic 2</h2>\n        </section>\n    </article>\n</main>\n<footer></footer>\n```\n\n### 사람이 이해하기 쉽다\n\n시맨틱 태그를 사용하면 태그를 통해 어떤 내용이 있을지 추측할 수 있고, 페이지 구조를 한눈에 파악하기 쉽다. 의미 없는 `<div>` 태그들을 끊임 없이 탐색하는 것보다는 의미 있는 코드 블록을 찾는게 훨씬 쉽기 때문이다. 이러한 가독성의 증가는 유지보수를 할 때에도 유리하다.\n\n또한 글 접기/열기가 가능한 `<details>` 태그, `<input>`에 자동완성 기능을 붙여주는 `<datalist>` 태그처럼 기존에 JavaScript로 구현해야 했던 기능을 제공하는 태그들도 있다. \n\n### 기계가 이해하기 쉽다\n\n시각 장애인을 위해 페이지를 음성으로 읽어주는 프로그램인 스크린 리더는 `<div>`로만 구성되거나 `<table>`을 이용하여 레이아웃을 짠 페이지에서는 제 기능을 발휘하지 못한다. 어떤 내용이 중요한 내용인지 판별하기가 어렵기 때문이다. 시맨틱 태그를 사용해 제목, 구획, 목록 등을 구분하면 이를 기준으로 원활한 페이지 탐색이 가능하다.\n\n비슷한 이치로 검색 엔진 최적화(SEO)에도 유리하다. 검색 엔진은 시맨틱 태그에 담긴 내용을 보다 중요하게 여기고, 이러한 요소는 검색 엔진의 크롤링 성능에 영향을 미친다.\n\n<br />\n\n## 여러 가지 시맨틱 태그들\n\n![MDN_Semantic](.\\MDN_Semantic.png)\n\n<em class=\"caption\">MDN 문서에 사용된 semantic tag</em>\n\n### `<header>`, `<footer>`\n\n- `<header>`는 페이지 혹은 특정 구획의 소개 및 탐색에 도움을 주는 컨텐츠를 담는다. 페이지의 헤더라면 로고, 내비게이션 메뉴, 검색 폼 등이 위치할 수 있고, 게시글의 헤더라면 제목, 작성일, 작성자 등의 정보가 포함될 수 있다.\n- `<footer>`는 페이지 혹은 특정 구획의 푸터를 의미한다. 작성자, 저작권, 연락처, 맨 위로 이동 버튼, 관련 페이지 등 포함될 수 있다.\n\n> `<header>`는 HTML5부터 명세에 포함되었지만 사실 최초부터 존재했던 태그 중 하나다. 처음에는 지금의 `<head>`처럼 사이트의 메타데이터를 저장하는 용도였다.\n\n### `<main>`\n\n- `<main>`은 페이지의 `<body>` 내의 주요 컨텐츠를 담는다. 일반적으로 한 페이지 당 `<main>`은 하나만 존재해야 한다.\n\n### `<nav>`\n\n- `<nav>`는 다른 페이지로 연결되는 링크, 또는 페이지 내 다른 부분으로 연결되는 링크를 모아두기 위한 태그다. 페이지의 내비게이션 메뉴나 글의 목차 등이 여기에 해당한다.\n- 여러 링크를 포함하기 때문에 일반적으로 내부에 `<ul>`, `<ol>`, `<dl>` 등을 포함하여 링크의 목록으로 나타낸다.\n\n### `<aside>`\n\n- `<aside>`는 본문의 주요 내용과 직접적으로 연관되지 않은 컨텐츠를 담는다. 주로 사이드바나 추가적인 설명을 위한 콜아웃 박스 등에 사용된다.\n\n### `<article>`\n\n- `<article>`은 그 자체로 완결되는 독립된 컨텐츠를 갖는다. 게시글이나 블로그 포스트, 뉴스 기사 등이 해당된다.\n- 원칙적으로 이거 하나만 떼어내서 따로 사용해도 문제가 없어야 한다.\n- 주로 제목(`<h1>`~`<h6>`) 태그를 이용해 각 `<article>`을 구분한다. (물론 둘이 꼭 함께 쓰여야 하는 건 아니다)\n\n### `<section>`\n\n- `<section>`은 문서 내에서 논리적으로 독립된 구획을 의미한다.\n- `<article>`과 마찬가지로 제목 태그를 자식으로 둠으로써 각 `<section>`을 구분한다.\n\n- 논리적으로 독립적이지 않은 구획에 `<section>`을 사용해선 안 된다. 단순 스타일링이 목적이라면 `<div>`를 사용해야 한다.\n  - 독립성의 여부는 보통 '이 구획에 별개의 소제목을 붙일 수 있는가?'로 판단한다.\n\n- `<article>`이 한 권의 책이라면 `<section>`은 각 장을 의미한다.\n\n### `<figure>`, `<figcaption>`\n\n- `<figure>`는 이미지, 그래프, 코드 조각, 인용문 등의 독립된 컨텐츠를 담는다. 본문과 관련이 있지만 부록으로 이동해도 문제 없는 내용을 맡는다.\n- `<figcaption>`는 `<figure>`의 컨텐츠에 대한 설명을 나타낸다. `<figure>` 태그 안에서 처음으로 등장하는 `<figcaption>`을 설명으로 사용한다. \n\n<br />\n\n## 참고 자료\n\n- [Semantic HTML - Wikipedia](https://en.wikipedia.org/wiki/Semantic_HTML)\n\n- [Semantics - 용어 사전 | MDN (mozilla.org)](https://developer.mozilla.org/ko/docs/Glossary/Semantics#html_시맨틱)\n- [Semantic HTML5 Elements Explained (freecodecamp.org)](https://www.freecodecamp.org/news/semantic-html5-elements/)\n- [HTML Standard (whatwg.org)](https://html.spec.whatwg.org/multipage/sections.html#the-section-element)\n- [What On Earth Is Semantic Markup? (And Why Should You Learn To Write It) » (html.com)](https://html.com/semantic-markup/)\n\n","frontmatter":{"title":"시맨틱 마크업(Semantic Markup)","tags":["웹 표준","HTML"]}},{"id":"636eac86-b6dd-5cd3-956d-65bce2acc99c","body":"\n## 개요\n\n#### 어떤 블로그를 만들까?\n\n내가 블로그를 하려는 이유는 기본적으로 공부한 내용을 정리하고 찾아보기 위함이다. 이에 필요한 기능들을 생각해봤다.\n\n- 기본적으로 Jekyll처럼 마크다운 파일을 이용해 정적 페이지를 생성\n- 전체 포스트 목록을 볼 수 있는 페이지\n- 태그별 포스트 목록을 볼 수 있는 페이지\n  - 각 포스트 목록은 페이지네이션함\n\n- 블로그 내 포스트 검색 기능\n\n우선은 이 정도가 필요할 듯하다. 기본적인 컨셉은 위키처럼 원하는 내용을 쉽게 찾아볼 수 있도록 검색과 하이퍼링크를 적극적으로 활용하고 싶다.\n\n#### 왜 Gatsby인가?\n\n예전에 정적 사이트 생성기 Jekyll로 블로그를 만들어보면서 고생한 적이 있다. Jekyll은 일단 Ruby 언어로 만들어져 환경 세팅부터 빌드까지의 과정이 복잡했고, 마음에 드는 테마를 찾아도 내 입맛에 맞게 커스터마이징하기가 너무 번거로웠다.\n\n그래서 이번에는 React 기반의 정적 사이트 생성기인 Gatsby를 사용하기로 했다. 처음에는 단순히 내게 익숙한 React 기반이라는 점 때문에 택했지만, 실제로 사용해보면서 매우 매력적인 프레임워크임을 알게 되었다. \n\n#### Gatsby란?\n\nGraphQL로 데이터를 다루고, React로 컴포넌트를 만들고, 빌드 결과물로서 정적인 파일들을 생성하는 프론트엔드 프레임워크이다.\n\n일반적인 React App은 빌드시 텅 빈 HTML과 JavaScript 파일을 생성한다. 이를 실행하면 JavaScript 코드를 통해 HTML 내용물을 렌더링하게 된다. 반면 Gatsby는 빌드 시 렌더링을 마친 정적 페이지들을 생성하고, 필요하다면 JavaScript 코드를 통해 추가적인 동작을 하게 된다.\n\nGatsby는 다음과 같은 장점이 있다.\n\n- 코드 분할, 이미지 최적화, 중요한 스타일(critical style)의 인라인화, 레이지 로딩, 리소스 프리페치 등을 통해 뛰어난 성능을 보여준다.\n- 노드(node)라는 데이터 단위를 통한 유연한 데이터 구조와 다양한 플러그인을 통해 다양한 파일, 데이터베이스, CMS의 데이터를 다룰 수 있고, 쉽게 원하는 기능을 추가할 수 있다.\n- 빌드된 정적 파일들은 서버와 완전히 분리되어 있으므로 데이터베이스는 악의적인 요청이나 DDOS 공격 등에 대해 안전하다.\n\n덧붙여서 공식 문서의 튜토리얼([#](https://www.gatsbyjs.com/docs/tutorial/))이 아주 알차다. React나 GraphQL을 전혀 모르더라도 충분히 따라갈 수 있도록 step-by-step으로 친절하게 설명이 되어 있다. 만약 GraphQL, 혹은 React을 처음 배운다면 Gatsby로 시작해보는 것도 좋은 선택일 것이다.\n\n#### 주요 개념\n\n![Gatsby](.\\Gatsby.jpg)\n\n- Gatsby 사이트에서 사용되는 모든 데이터는 <b>GraphQL 데이터 계층(data layer)</b>에 위치한다.\n- 로컬 파일, 데이터베이스, CMS 등 다양한 데이터 <b>소스(source)</b>들은 **source plugin**을 통해 데이터 계층에 추가될 수 있다.\n- 데이터 계층의 정보들은 <b>노드(node)</b>라는 데이터 단위로 존재한다.\n- **transformer plugin**을 통해 기존 노드들로부터 새로운 노드들을 생성할 수 있다.\n\n>  예를 들어 컴퓨터의 파일시스템에 접근하게 해주는 `gatsby-source-filesystem` 플러그인을 이용해 특정 경로의 로컬 파일을 File 노드로서 데이터 계층에 추가할 수 있다.\n>\n> 그리고 `gatsby-plugin-mdx` 플러그인을 사용하면 확장자가 `.mdx`인 File 노드들로부터 MDX 노드를 만들 수 있다. MDX 노드는 `.mdx`파일의 특성에 맞게 처리되어 파일 최상단의 YAML 정보, mdx 포맷으로 변환된 파일 내용 등의 정보를 포함한다.\n\n- 데이터 계층의 노드들은 **GraphQL 쿼리**를 사용해 리액트 컴포넌트에서 사용할 수 있다.\n- 언급했듯 다양한 플러그인을 설치하여 손쉽게 기능을 확장할 수 있다. Gatsby 플러그인을 사용하는 순서는 크게 다음과 같다.\n  1. `npm`으로 플러그인을 설치한다.\n  2. `gatsby-config.js`의 `plugins` 필드에 설치한 플러그인을 추가한다. \n  3. 플러그인을 사용한다.\n\n\n\n## 진행과정\n\n#### 0. Gatsby 프로젝트 생성\n\n`npm`으로 `gatsby-cli`를 전역으로 설치하면 `gatsby` 명령어를 사용할 수 있게 된다.\n\n```shell\n$ npm install -g gatsby-cli\n$ gatsby -v\n> Gatsby CLI version: 4.8.0\n```\n\n이제 Gatsby 프로젝트를 시작하기 위한 두 가지 방법이 있는데,\n\n- `gatsby new`로 시작해서 처음부터 구현하는 방법\n- 일종의 boilerplate인 gatsby-starter를 사용하는 방법\n\n처음에는 스타터를 이용해 빠르게 시작할까도 생각해봤지만, 새로운 React 프레임워크를 만지는 건 오랫만이라 손이 근질근질하고 직접 구현해보고픈 욕구가 생겼다. 그래서 처음부터 만들어보는 것을 택했다.\n\n`gatsby new` 명령어를 입력하면 초기설정과 함께 Gatsby 프로젝트를 생성할 수 있다. 나는 TypeScript, Emotion 정도만 선택하고 나머지는 필요할 때마다 추가하기로 했다.\n\n```shell\n$ gatsby new\n...\n> √ Will you be using JavaScript or TypeScript?\n> · TypeScript\n> √ Will you be using a CMS?\n> · No (or I'll add it later)\n> √ Would you like to install a styling system?\n> · Emotion\n```\n\n#### 1. 포스트 목록을 표시하기\n\n우선은 `src/posts`에 더미 `.mdx` 파일들을 20개 정도 만들었다. 대강 이런 식이다.\n\n- `posts/post1/index.mdx`\n\n\n```markdown\n---\ntitle: 1번째 포스트입니다\ndate: 2022-01-01\n---\n1번째 포스트의 내용입니다.\n```\n\n다음으로 몇 가지 필요한 플러그인을 추가했다.\n\n```shell\n$ npm install gatsby-plugin-root-import\n$ npm install gatsby-source-filesystem\n$ npm install gatsby-plugin-mdx @mdx-js/mdx@v1 @mdx-js/react@v1\n```\n\n- `gatsby-config.js`\n\n\n```javascript\nmodule.exports = {\n  siteMetadata: {\n    title: '개발하고 기록하기',\n  },\n  plugins: [\n    //...\n    'gatsby-plugin-root-import',\n    {\n      resolve: `gatsby-source-filesystem`,\n      options: {\n        name: `posts`,\n        path: `${__dirname}/posts/`,\n      },\n    },\n    {\n      resolve: `gatsby-plugin-mdx`,\n      options: {\n        extensions: [`.mdx`, `.md`],\n        gatsbyRemarkPlugins: [],\n      },\n    },\n  ],\n};\n```\n\n\n> - `siteMetadata` 필드: 말 그대로 사이트의 메타데이터를 입력할 수 있다. 이 메타데이터는 별도의 플러그인 없이 GraphQL 쿼리로 접근 가능한 데이터 중 하나다.\n> - `gatsby-plugin-root-import`: 절대경로 import를 사용하기 위한 플러그인.\n> - `gatsby-source-filesystem`: 컴퓨터의 파일시스템을 사용하기 위한 source 플러그인.\n> - `gatsby-plugin-mdx`: File node를 MDX node로 변환하는 transformer 플러그인.\n> - `@mdx-js/mdx`: MDX를 구현한 라이브러리.\n> - `@mdx-js/react`: MDX 구현을 React 컴포넌트에 매핑하기 위한 라이브러리.\n\n이제 `src/posts` 안에 있는 파일들은 File node로서 데이터 계층에 추가되고, 그 중 확장자가 `.mdx`인 노드들로부터 MDX node들이 생성될 것이다. `gatsby develop` 명령어로 개발자 모드로 실행하고 GraphiQL(`localhost:8000/___graphql`)로 들어가서 확인해볼 수 있다.\n\n![GraphiQL](.\\GraphiQL.png)\n\n> - id: 각 노드의 고유 id\n> - frontmatter: mdx 파일 최상단의 YAML 정보\n> - body: mdx 포맷으로 변환된 파일 내용\n\n이 GraphiQL 도구는 데이터 계층에 추가된 노드들을 탐색하고 필요한 쿼리를 작성하는 데 유용하다.\n\n이제 데이터도 추가했고 쿼리도 작성했으니 실제로 사이트에 띄워봤다.\n\n- `src/types.ts`\n\n\n```typescript\nimport {Node} from 'gatsby';\n\nexport interface SiteNode extends Node {\n  siteMetadata: {\n    title: string;\n  };\n}\n\nexport interface MdxNode extends Node {\n  frontmatter: {\n    title: string;\n    date: string;\n  };\n  body: string;\n}\n```\n\n- `src/components/layout.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {graphql, useStaticQuery} from 'gatsby';\nimport {SiteNode} from 'src/types';\n\ninterface Props {\n  title?: string;\n  children?: React.ReactNode;\n}\n\nconst query = graphql`\n  query {\n    site {\n      siteMetadata {\n        title\n      }\n    }\n  }\n`;\n\nconst Layout = ({title, children}: Props) => {\n  const data = useStaticQuery<{site: SiteNode}>(query);\n  return (\n    <main>\n      <title>{title || data.site.siteMetadata.title}</title>\n      {children}\n    </main>\n  );\n};\n\nexport default Layout;\n```\n\n> - `Layout` 컴포넌트: 블로그의 모든 페이지에 공통적으로 들어갈 요소들을 래핑한 컴포넌트. 지금은 `title` 태그 뿐이지만 추후 header, footer 등 정적인 요소를 추가할 것이다.\n\n- `src/pages/blog/index.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {graphql, PageProps} from 'gatsby';\nimport Layout from 'src/components/layout';\nimport {MdxNode} from 'src/types';\n\ninterface DataType {\n  allMdx: {\n    nodes: MdxNode[];\n  };\n}\n\nexport const pageQuery = graphql`\n  {\n    allMdx(sort: {order: DESC, fields: frontmatter___date}) {\n      nodes {\n        id\n        frontmatter {\n          title\n          date(formatString: \"YYYY-MM-DD\")\n        }\n        body\n      }\n    }\n  }\n`;\n\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\n  return (\n    <Layout>\n      <h1>Posts</h1>\n      <ul>\n        {allMdx.nodes.map((node) => (\n          <li key={node.id}>\n            <h2>{node.frontmatter.title}</h2>\n            <div>{node.frontmatter.date}</div>\n          </li>\n        ))}\n      </ul>\n    </Layout>\n  );\n};\n\nexport default BlogPage;\n```\n\n> - 일반 컴포넌트와 페이지 컴포넌트에서 GraphQL 쿼리를 사용하는 방식이 다르다.\n>   - 일반 컴포넌트는 `useStaticQuery` 훅에 쿼리를 넣어 데이터를 가져올 수 있다.\n>   - 페이지 컴포넌트는 페이지 쿼리를 `export`하여 컴포넌트의 props로 데이터를 가져올 수 있다.\n\n- 결과 (`localhost:8000/blog`)\n\n![post 목록](.\\post-목록.png)\n\n날짜에 대해 내림차순으로 데이터를 가져왔으므로 최신순으로 포스트 목록이 잘 보인다!\n\n#### 2. MDX 파일로부터 정적 페이지 생성하기\n\nGatsby는 기본적으로 **File System Route API**라는 기능을 제공한다. `src/pages` 안에  `{nodeType.fieldName}.tsx`와 같은 식으로 페이지 템플릿 컴포넌트를 작성하면 데이터 계층의 노드를 바탕으로 동적 페이지를 생성하고 라우팅한다.\n\n- `nodeType`은 어떤 노드로부터 페이지를 만들지를 결정한다.\n- `fieldName`은 노드의 어떤 필드를 URL에 사용할지를 결정한다.\n\nMDX 노드는 기본적으로 `slug` 필드를 갖는데, `.mdx` 파일의 경로 + 파일이름이 `path/file-name` 꼴로 인코딩되어 있어 URL에 사용하기 적합하다. \n\n마크다운 문법이 잘 표시되는지 확인하기 위해 포스트 내용을 조금 수정했다. 그리고 포스트 템플릿 페이지를 만들고 포스트 목록 페이지에도 포스트 페이지에 접근할 수 있도록 링크를 추가했다.\n\n- `posts/post1/index.mdx`\n\n\n```markdown\n---\ntitle: 1번째 포스트입니다\ndate: 2022-01-01\n---\n1번째 포스트의 내용입니다.\n\n# heading1\n## heading2\n### heading3\n\n- first\n- second\n- third\n```\n\n- `src/pages/blog/post/{mdx.slug}.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {graphql, Link, PageProps} from 'gatsby';\nimport Layout from 'src/components/layout';\nimport {MdxNode} from 'src/types';\nimport {MDXRenderer} from 'gatsby-plugin-mdx';\n\ninterface DataType {\n  mdx: MdxNode;\n}\n\nexport const pageQuery = graphql`\n  query ($id: String) {\n    mdx(id: {eq: $id}) {\n      frontmatter {\n        title\n        date(formatString: \"YYYY-MM-DD\")\n      }\n      body\n    }\n  }\n`;\n\nconst PostPage = ({data: {mdx}}: PageProps<DataType>) => {\n  return (\n    <Layout title={mdx.frontmatter.title}>\n      <Link to='/blog'>목록으로 가기</Link>\n      <h1>{mdx.frontmatter.title}</h1>\n      <div>작성일: {mdx.frontmatter.date}</div>\n      <MDXRenderer>{mdx.body}</MDXRenderer>\n    </Layout>\n  );\n};\n\nexport default PostPage;\n```\n\n> - 템플릿 페이지의 페이지 쿼리는 다른 페이지 쿼리와 조금 다르다. 쿼리 변수를 설정하고 원하는 노드를 찾기 위한 조건을 설정해줘야 한다. 위와 같은 경우 $id 쿼리 변수를 받아 id 필드가 $id 변수와 동일한 노드를 찾는 쿼리이다.\n>\n>   쿼리 변수로 사용될 값은 페이지 컴포넌트의 `props` 중 `pageContext`의 필드 중에서 정할 수 있는데, 일반적으로 노드 id가 사용된다.\n>\n> - `MDXRenderer` 컴포넌트를 사용해 MDX 노드의 `body`를 HTML로 바꾸어 표시할 수 있다.\n\n- `src/pages/blog/index.tsx`\n\n\n```tsx\n...\nexport const pageQuery = graphql`\n  {\n    allMdx(sort: {order: DESC, fields: frontmatter___date}) {\n      nodes {\n\t\t...\n        slug\n      }\n    }\n  }\n`;\n\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\n  return (\n    <Layout>\n      ...\n      <ul>\n        {allMdx.nodes.map((node) => (\n          <li key={node.id}>\n            <Link to={node.slug ? `/blog/post/${node.slug}` : '#'}>\n              <h2>{node.frontmatter.title}</h2>\n            </Link>\n            ...\n          </li>\n        ))}\n      </ul>\n    </Layout>\n  );\n};\n\n...\n```\n\n- 결과 (`localhost:8000/blog/post/post1/`)\n\n\n![포스트페이지](.\\포스트페이지.png)\n\n`.mdx` 파일로부터 페이지가 잘 생성되고, 또 Markdown 문법이 HTML 문법으로 잘 변환된 것을 확인할 수 있다.\n\n여기까지가 튜토리얼 6번까지 진행하며 구현할 수 있는 내용이다.\n\n#### 3. 태그별 목록 구현하기\n\n[Creating Tags Pages for Blog Posts](https://www.gatsbyjs.com/docs/adding-tags-and-categories-to-blog-posts/)\n\n웬만한 내용은 공식홈페이지에 엄청 친절하게 쓰여 있다!\n\n우선 이런 식으로 `.mdx` 더미파일에 태그들을 적당히 추가했다.\n\n- `posts/post1/index.mdx`\n\n\n```markdown\n---\ntitle: 1번째 포스트입니다\ndate: 2022-01-01\ntags: [\"tag1\", \"tag2\"]\n---\n\n...\n```\n\n이제 쿼리를 통해 MDX 노드의 frontmatter 필드에서 tags 필드가 추가된 것을 확인할 수 있다.\n\n![태그 확인](.\\태그-확인.png)\n\n다음으로 태그를 통해 포스트 목록을 보여주는 페이지를 만들어야 한다. File System Route API은 별다른 설정 없이 자동으로 페이지를 생성할 수 있지만, 직접 페이지를 생성해야 할 때에는 **Gatsby Node API**을 사용해야 한다. 지금처럼 노드가 아닌 데이터를 통해 페이지를 생성하는 경우가 그렇다.\n\nGatsby Node API를 사용하여 페이지를 생성하는 과정은 다음과 같다.\n\n1. 템플릿 컴포넌트를 작성한다.\n2. 작성한 템플릿 컴포넌트를 `gatsby-node.js`의 `createPages`에서 사용하여 페이지를 생성한다.\n\n- `src/templates/tag.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {graphql, Link, PageProps} from 'gatsby';\nimport {MdxNode} from 'src/types';\nimport Layout from 'src/components/layout';\n\ninterface PageContextType {\n  tag: string;\n}\n\ninterface DataType {\n  allMdx: {\n    edges: {node: MdxNode}[];\n    totalCount: number;\n  };\n}\n\nexport const pageQuery = graphql`\n  query ($tag: String) {\n    allMdx(\n      limit: 2000\n      sort: {fields: [frontmatter___date], order: DESC}\n      filter: {frontmatter: {tags: {in: [$tag]}}}\n    ) {\n      totalCount\n      edges {\n        node {\n          slug\n          frontmatter {\n            title\n          }\n        }\n      }\n    }\n  }\n`;\n\nconst TagPage = ({pageContext, data}: PageProps<DataType, PageContextType>) => {\n  const {tag} = pageContext;\n  const {edges, totalCount} = data.allMdx;\n  const tagHeader = `${totalCount} post${\n    totalCount === 1 ? '' : 's'\n  } tagged with \"${tag}\"`;\n\n  return (\n    <Layout>\n      <h1>{tagHeader}</h1>\n      <ul>\n        {edges.map(({node}) => {\n          const {slug} = node;\n          const {title} = node.frontmatter;\n          return (\n            <li key={slug}>\n              <Link to={node.slug ? `/blog/post/${node.slug}` : '#'}>\n                {title}\n              </Link>\n            </li>\n          );\n        })}\n      </ul>\n      <Link to='/blog/tags'>All tags</Link>\n    </Layout>\n  );\n};\n\nexport default TagPage;\n```\n\n- `gatsby-node.js`\n\n\n```tsx\nconst path = require('path');\nconst _ = require('lodash');\n\nexports.onPostBuild = ({reporter}) => reporter.info('Page build is done!');\nexports.createPages = async ({graphql, actions}) => {\n  const {createPage} = actions;\n  const result = await graphql(`\n    query {\n      tagsGroup: allMdx(limit: 2000) {\n        tags: group(field: frontmatter___tags) {\n          value: fieldValue\n          totalCount\n        }\n      }\n    }\n  `);\n\n  if (result.errors) {\n    reporter.panicOnBuild(`Error while running GraphQL query.`);\n    return;\n  }\n\n  const tags = result.data.tagsGroup.tags;\n  tags.forEach((tag) => {\n    createPage({\n      path: `/blog/tags/${_.kebabCase(tag.value)}/`,\n      component: path.resolve('src/templates/tag.tsx'),\n      context: {\n        tag: tag.value,\n      },\n    });\n  });\n};\n```\n\n- `src/pages/blog/tags.tsx`\n\n```tsx\nimport React from 'react';\nimport kebabCase from 'lodash/kebabCase';\nimport {Link, graphql, PageProps} from 'gatsby';\nimport Layout from 'src/components/layout';\n\ninterface DataType {\n  tagsGroup: {\n    tags: {\n      value: string;\n      totalCount: number;\n    }[];\n  };\n}\n\nexport const pageQuery = graphql`\n  query {\n    tagsGroup: allMdx(limit: 2000) {\n      tags: group(field: frontmatter___tags) {\n        value: fieldValue\n        totalCount\n      }\n    }\n  }\n`;\n\nconst TagsPage = ({\n  data: {\n    tagsGroup: {tags},\n  },\n}: PageProps<DataType>) => (\n  <Layout>\n    <div>\n      <h1>Tags</h1>\n      <ul>\n        {tags.map((tag) => (\n          <li key={tag.value}>\n            <Link to={`/blog/tags/${kebabCase(tag.value)}/`}>\n              {tag.value} ({tag.totalCount})\n            </Link>\n          </li>\n        ))}\n      </ul>\n    </div>\n  </Layout>\n);\n\nexport default TagsPage;\n```\n\n> - 템플릿 컴포넌트는 앞서 작성한 템플릿 페이지 컴포넌트와 거의 유사하다. `pageContext`의 `tag` 값을 쿼리 변수로 사용하고 이 쿼리 변수를 `frontmatter`의 `tags`가 포함하는 MDX 노드들을 가져온다.\n>\n> - `gatsby-node.js`에서는 Graphql 쿼리를 날려 결과값을 받아오고, 이 결과값과 템플릿 컴포넌트를 이용해 페이지를 생성한다.\n>\n> - 추가적으로 태그 목록을 확인할 수 있는 페이지를 만들었다.\n>\n> - 페이지가 잘 생성되었는지 궁금할 때엔 GraphiQL에서 다음과 같은 쿼리를 날려보면 쉽게 확인할 수 있다.\n>\n>   ```\n>   // GraphQL query\n>   {\n>     allSitePage {\n>       nodes {\n>         path\n>       }\n>     }\n>   }\n>                                               \n>   // 결과 예\n>   {\n>     \"data\": {\n>       \"allSitePage\": {\n>         \"nodes\": [\n>           {\n>             \"path\": \"/blog/tags/tag-0/\"\n>           },\n>           {\n>             \"path\": \"/blog/tags/tag-1/\"\n>           },\n>           ...\n>         ]\n>       }\n>     },\n>     \"extensions\": {}\n>   }\n>   ```\n\n- 결과1 (`localhost:8000/blog/tags`)\n\n\n![tags](.\\tags.png)\n\n- 결과2 (`localhost:8000/blog/tags/tag-1`)\n\n\n![tag1](.\\tag1.png)\n\n태그 목록으로부터 페이지가 잘 생성된 것을 확인할 수 있다.\n\n#### 중간 정리\n\n어느 정도 기능이 자리잡은 만큼 코드를 한번 정리했다.\n\n- URL을 간소화하기 위해 `/blog` 아래에 위치한 페이지들을 전부 루트 위치로 이동시켰다.\n\n- 여러 페이지에서 사용되는 UI요소를 컴포넌트로 분리했다. (`/blog`, `/tag/{tag}`에서 사용되는 포스트 목록 등)\n\n- 여러 곳에서 쓰이는 로직은 `src/utils.ts`로 분리했다.\n\n- `src/components/postList/index.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {MdxNode} from 'src/types';\nimport PostItem from './PostItem';\n\nconst PostList = ({nodes}: {nodes: MdxNode[]}) => {\n  return (\n    <ul>\n      {nodes.map((node) => (\n        <PostItem key={node.id} node={node} />\n      ))}\n    </ul>\n  );\n};\n\nexport default PostList;\n```\n\n- `src/components/postList/postItem.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {Link} from 'gatsby';\nimport {MdxNode} from 'src/types';\nimport {getPostUrl} from 'src/utils';\nimport TagButton from 'src/components/tagButton';\n\nconst PostItem = ({node}: {node: MdxNode}) => {\n  return (\n    <div>\n      <Link to={getPostUrl(node.slug)}>\n        <h2>{node.frontmatter.title}</h2>\n        <div>{node.frontmatter.date}</div>\n      </Link>\n      {node.frontmatter.tags.map((tag) => (\n        <TagButton key={tag} tag={tag} />\n      ))}\n    </div>\n  );\n};\n\nexport default PostItem;\n```\n\n- `src/utils.ts`\n\n```typescript\nimport _ from 'lodash';\n\nconst noUrl = '#';\n\nexport const getPostUrl = (slug?: string) => {\n  return slug ? `/post/${slug}` : noUrl;\n};\n\nexport const getTagUrl = (tag?: string) => {\n  return tag ? `/tag/${_.kebabCase(tag)}` : noUrl;\n}\n```\n\n그래서 여기까지 프로젝트 구조는 다음과 같다.\n\n```\nroot\n├src\n│├components\n││├layout\n││├postList\n││└tagButton\n│├images\n│├pages\n││├post\n│││└{mdx.slug}.tsx\n││├404.tsx\n││├blog.tsx\n││├index.tsx\n││└tag.tsx\n│├templates\n││└{tag}.tsx\n│├types.ts\n│└utils.ts\n├gatsby-config.js\n├gatsby-node.js\n├...\n```\n\n#### 4. 포스트 목록 페이지네이션\n\n<b>페이지네이션(pagination)</b>, 또는 페이징(paging)이란 많은 양의 데이터를 여러 페이지로 나누어 보여주는 과정을 말한다. 보여줄 데이터 양이 방대할 경우 데이터를 가져오거나 렌더링하는 과정이 오래 걸릴 수 있고, 보기에도 힘들어지므로 적절하게 페이지네이션 처리를 할 필요가 있다.\n\nGatsby 공식 문서에서 소개하는 방법([#](https://www.gatsbyjs.com/docs/adding-pagination/))은 앞서 태그 페이지를 생성한 것처럼 Gatsby Node API를 이용해 각 페이지별 정적 페이지를 생성하는 것이다. 그러나 이 방법은 페이지네이션이 필요한 페이지를 생성할 때마다 새로 `createPages()`에서 페이지 작성 코드를 추가해줘야 한다는 문제가 있다.\n\n그래서 나는 이 방법 대신 리액트 컴포넌트와 훅을 이용해 client-side 페이지네이션을 구현하기로 했다. 처음에 모든 데이터를 가져온 후 렌더링에만 페이지네이션을 적용하는 것이다. 이러면 적은 양의 데이터만 가져올 수 있다는 이점은 없어지지만, 블로그라는 사이트 특성상 데이터가 많아봐야 수백 건일 것이므로 크게 신경 쓸 부분은 아니라고 생각했다. 그리고 여전히 렌더링의 이점은 챙길 수 있다.\n\n페이지네이션에 필요한 요소로는 크게 두 가지를 생각했는데,\n\n- 원본 데이터에서 특정 페이지에 표시할 데이터를 뽑아내는 기능\n- 사용자가 페이지 이동을 할 수 있도록 UI를 제공하는 페이지 내비게이션\n\n전자는 훅으로, 후자는 훅과 컴포넌트로 구현했다. 특별히 신경 쓴 점이라면 재사용성을 고려해서 어떤 종류의 데이터라도 페이지네이션이 가능하도록 만들었다.\n\n- `src/hooks/usePagination.ts`\n\n\n```typescript\nimport {useCallback, useEffect, useMemo, useState} from 'react';\n\ninterface Options {\n  itemsPerPage?: number;\n  initialPage?: number;\n}\n\nconst usePagination = <T>(\n  data: T[],\n  {itemsPerPage = 10, initialPage}: Options = {}\n) => {\n  const [paginatedData, setPaginatedData] = useState<T[]>([]);\n  const [currPage, setCurrPage] = useState(initialPage || 1);\n\n  useEffect(() => {\n    const startIndex = (currPage - 1) * itemsPerPage;\n    const endIndex = currPage * itemsPerPage;\n    setPaginatedData(data.slice(startIndex, endIndex));\n  }, [data, currPage, itemsPerPage]);\n\n  const lastPage = useMemo(\n    () => Math.ceil(data.length / itemsPerPage),\n    [data.length, itemsPerPage]\n  );\n\n  const setPage = useCallback((page: number) => {\n    if (page > lastPage) page = lastPage;\n    if (page < 1) page = 1;\n    setCurrPage(page);\n  }, []);\n\n  return {paginatedData, currPage, setPage, lastPage};\n};\n\nexport default usePagination;\n```\n\n> - 재사용이 용이하도록 데이터의 타입은 generic type을 사용했고 페이지당 항목 수, 처음에 표시할 페이지와 같은 값들을 옵션으로 변경할 수 있게 만들었다.\n\n- `src/components/pageNav/index.tsx`\n\n\n```tsx\nimport React, {useEffect, useState} from 'react';\nimport {range} from 'src/utils/common';\nimport PageButton from './pageButton';\n\ninterface Props {\n  currPage: number;\n  lastPage: number;\n  setPage: (page: number) => void;\n  maxPageNavLength?: number;\n}\n\nconst PageNav = ({\n  currPage,\n  lastPage,\n  setPage,\n  maxPageNavLength = 10,\n}: Props) => {\n  const {pageList} = usePageNav(currPage, lastPage, maxPageNavLength);\n\n  return (\n    <div>\n      <PageButton\n        label='<'\n        page={pageList[0] - 1}\n        setPage={setPage}\n        disabled={pageList[0] === 1}\n      />\n      {pageList.map((page) => (\n        <PageButton\n          page={page}\n          setPage={setPage}\n          selected={currPage === page}\n          key={page}\n        />\n      ))}\n      <PageButton\n        label='>'\n        page={pageList[pageList.length - 1] + 1}\n        setPage={setPage}\n        disabled={pageList[pageList.length - 1] === lastPage}\n      />\n    </div>\n  );\n};\n\nconst usePageNav = (\n  currPage: number,\n  lastPage: number,\n  maxPageNavLength: number\n) => {\n  const [pageList, setPageNavList] = useState<number[]>([]);\n\n  useEffect(() => {\n    const firstPageInNav = currPage - ((currPage - 1) % maxPageNavLength);\n    const lastPageInNav = Math.min(\n      firstPageInNav + maxPageNavLength,\n      lastPage + 1\n    );\n    setPageNavList(range(firstPageInNav, lastPageInNav));\n  }, [currPage, lastPage]);\n\n  return {pageList};\n};\n\nexport default PageNav;\n```\n\n> - 마찬가지로 재사용성을 위해 페이지 내비게이션의 최대길이를 받을 수 있도록 만들었다. `pageList`는 현재 페이지와 마지막 페이지를 받아 표시할 페이지의 리스트를 계산한 것이다.\n>\n>   예를 들어 최대 페이지가 15일 때, 현재 페이지가 3이면 [1, 2, ..., 10]을, 현재 페이지가 12면 [11, 12, ..., 15]를 `return`하는 식이다.\n>\n> - `usePageNav` 훅은 이 컴포넌트에서만 쓰이는 지엽적인 로직이므로 별도의 파일로 분리하지는 않았다.\n>\n> - 페이지 내비게이션의 버튼 역할을 하는 `PageButton` 컴포넌트는 페이지가 바뀔 때마다(즉 `PageNav`의 `props`가 바뀔 때마다) 내비게이션 전체가 리렌더링되는 것을 막기 위해 `React.memo()`를 적용해서 최적화했다.\n\n- `src/pages/blog.tsx`\n\n\n```tsx\nimport React from 'react';\nimport {graphql, Link, navigate, PageProps} from 'gatsby';\nimport Layout from 'src/components/layout';\nimport {MdxNode} from 'src/types';\nimport PostList from 'src/components/postList';\nimport usePagination from 'src/hooks/usePagination';\nimport PageNav from 'src/components/pageNav';\n\n...\n\nconst BlogPage = ({data: {allMdx}}: PageProps<DataType>) => {\n  const {paginatedData, currPage, lastPage, setPage} = usePagination(\n    allMdx.nodes,\n    {itemsPerPage: 3}\n  );\n\n  return (\n    <Layout>\n      <Link to='tags'>tags</Link>\n      <h1>Posts</h1>\n      <PostList nodes={paginatedData} />\n      <PageNav\n        currPage={currPage}\n        lastPage={lastPage}\n        setPage={setPage}\n        maxPageNavLength={5}\n      />\n    </Layout>\n  );\n};\n\nexport default BlogPage;\n```\n\n> - 임시로 페이지네이션이 잘 구현되었는지 확인하기 위해 페이지당 항목 수는 3으로, 페이지 내비게이션 길이는 5로 뒀고, 현재 선택중인 페이지는 글자색을 빨간색으로 표시하게 했다.\n\n- 결과 (`localhost:8000/blog`)\n\n![pagination](https://lh3.googleusercontent.com/pw/AM-JKLWxvGAgoVHDXLt-V6zsss-FzUmTFk52laXJcdVNAXzXGUpy7jBrg7UqkHYihbMVDqHsCsD-sH4hkG4jCOGy_yidLLR_Lhd_xP6fDn113JlcQjN4YsMi-o9aM20lQzGxZjZG3UhmNjiZ9Bszw0Dsf-hM=w480-h508-no?authuser=0)\n\nclient-side 페이지네이션이 잘 구현되었다.\n\n## 후기\n\n일단 블로그로서 정말 기본적인 틀은 갖췄다. 검색 기능까지 한번에 진행하고 싶었는데 생각보다 플러그인 적용에 애를 먹어서 나중에 다시 살펴봐야 될 것 같다.\n\n현재까지 포스트 목록 표시, 포스트 페이지 생성, 태그 페이지 생성, 포스트 목록 페이지네이션 기능을 만들었고, 앞으로 추가할 예정인 기능은 우선도 순으로 다음과 같다.\n\n- 블로그 내 포스트 검색 기능 추가\n- 디자인 추가\n  - 다크모드, 반응형 디자인 적용\n- 댓글 기능 추가\n- Google Analytics 추가\n\n<br />\n\n## Issue\n\n#### 페이지 쿼리를 변경해도 반영이 되지 않는 문제\n\n- 증상: MDX 노드들을 가져오는 부분에서 중간에 페이지 쿼리에 slug 필드를 추가했을 때 변경점이 실제 데이터 fetch에 반영되지 않았다.\n\n- 원인: 쿼리를 이리저리 수정하거나 아예 지워도 이전 쿼리 상태로 동작하는 것을 보면 개발 모드에서 쿼리를 캐싱한 것이 문제가 된 것 같다.\n\n- 해결: `gatsby clean` 명령어로 캐시를 전부 날려서 해결했다.\n\n\n#### Gatsby Node API 사용 중 오류 발생\n\n- 증상: 공식 홈페이지의 예제를 가져와 문법만 TypeScript 문법으로 수정하고 실행했을 때 `Cannot query field \"fields\" on type \"Mdx\".`와 같은 오류들이 발생했다.\n- 원인: 예제는 MarkdownRemark 노드를 사용하는 것이었는데 이게 MDX 노드와 구조가 달라 발생한 문제였다. (MarkdownRemark 노드는 fields 필드 안에 body 등의 필드가 들어 있었다)\n- 해당 쿼리를 MDX 노드에 맞게 수정해서 해결했다.\n\n","frontmatter":{"title":"Gatsby 블로그 제작 - 페이지 생성","tags":["React","Gatsby","GraphQL"]}}]}}}